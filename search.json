[{"path":"index.html","id":"présentation","chapter":"Présentation","heading":"Présentation","text":"","code":""},{"path":"index.html","id":"objectifs","chapter":"Présentation","heading":"Objectifs","text":"Ce document est le support du cours Travailler avec R.Il peut être téléchargé au format PDF.Il propose une organisation du travail autour de R et RStudio pour, au-delà des statistiques, rédiger des documents efficacement avec R Markdown, aux formats variés (mémos, articles scientifiques, mémoires d’étudiants, livres, diaporamas), créer son site web et des applications R en ligne (Shiny), produire des packages et utiliser R pour l’enseignement.\nIl complète Reproducible Research R R Studio (Gandrud 2015) par une approche plus concrète, avec des solutions prêtes à l’emploi.L’optimisation de l’utilisation des nombreux outils disponibles est traitée en détail : rmarkdown, bookdown et blogdown pour la rédaction, roxygen2, testthat et pkgdown pour les packages, le contrôle de source avec git et GitHub, l’intégration continue avec les Actions GitHub et Codecov.\nDes exemples sont présentés à chaque étape, et le code nécessaire est fourni.Le chapitre 1 est consacré à l’installation des outils nécessaires : R, git et LaTeX.\nLe chapitre 2 détaille quelques aspects avancés de l’utilisation de R : les différents langages, les environnements, la performance du code.\nL’utilisation de base de R n’est pas reprise ici : de bons cours sont suggérés.\nLe chapitre 3 présente le contrôle de source avec git et GitHub.Le chapitre 4 montre comment rédiger des documents simples (articles) ou complexes (ouvrages) avec R Markdown, intégrant les données, le code pour les traiter et le texte pour les présenter.\nLe chapitre 5 présente une méthode pas à pas pour créer efficacement un package.\nLe chapitre 6 introduit l’utilisation de l’intégration continue pour produire automatiquement des documents, vérifier le code des packages et produire leurs vignettes.\nLe chapitre 7 présente Shiny, l’outil de mise en ligne d’applications R.\nEnfin, le chapitre 8 introduit les outils destinés à l’enseignement avec R.","code":""},{"path":"index.html","id":"conventions","chapter":"Présentation","heading":"Conventions","text":"Les noms des packages sont en gras dans le texte, par exemple : ggplot2.L’identifiant utilisé sur GitHub est noté GitHubID.\nLe nom des projets, identique à celui de leur dépôt sur GitHub est noté RepoID.Le signe |> dans le code des exemples indique que la suite du code devrait se trouver sur la même ligne, mais est coupée pour le formatage de ce document.\nSon usage est limité aux fichiers de configuration YAML, surtout utilisés dans le chapitre 6.\nDans tous les autres cas, le code peut être utilisé directement.","code":""},{"path":"chap-logiciels.html","id":"chap-logiciels","chapter":"1 Logiciels","heading":"1 Logiciels","text":"L’outil central est évidemment R, mais son fonctionnement est aujourd’hui difficilement envisageable sans son environnement de développement RStudio.\nPour le contrôle de source, git et GitHub sont de fait les standards.\nL’ensemble doit être complété par une distribution LaTeX pour la production de documents au format PDF.\nUn outil de gestion bibliographique est indispensable : Zotero et son extension Better BibTeX sont parfaitement adaptés au cadre de travail présenté ici.\nEnfin, d’autres logiciels d’usage plus ponctuel peuvent être nécessaires, comme Go.Leur installation et leur organisation cohérente sont présentées dans ce chapitre.","code":""},{"path":"chap-logiciels.html","id":"r","chapter":"1 Logiciels","heading":"1.1 R","text":"","code":""},{"path":"chap-logiciels.html","id":"installation","chapter":"1 Logiciels","heading":"1.1.1 Installation","text":"R est inclus dans les distributions de Linux : le paquet est nommé r-base.\nIl ne contient pas des outils de développement souvent nécessaires, donc il est préférable d’installer aussi le paquet r-base-dev.\nLa version de R est souvent un peu ancienne.\nPour disposer de la dernière version, il faut utiliser un miroir de CRAN comme source des paquets : voir la documentation complète pour Ubuntu1.Sous Windows ou Mac, installer R après l’avoir téléchargé depuis CRAN2.","code":""},{"path":"chap-logiciels.html","id":"rtools","chapter":"1 Logiciels","heading":"1.1.2 Rtools","text":"Sur Mac, l’installation de R est suffisante à partir de la version 4.0.0.Sous Windows, l’installation doit être complétée par les “Rtools”, qui contiennent les outils de développement dont ceux nécessaires à la compilation des packages contenant du code C++.Le chemin des Rtools (avant la version 4.2) doit être déclaré à R, en exécutant dans la console de RStudio la commande suivante (adaptée à la version 4.0 des Rtools) :Depuis la version 4.2, cette action est inutile.Les Rtools doivent être complétés par quelques utilitaires manquants, à installer quand le besoin apparaît (en général, un avertissement de R indiquant que le logiciel n’est pas installé).La vérification des packages renvoie un avertissement si qpdf3 n’est pas installé.\nTélécharger le fichier zip et coller tout le contenu du dossier bin dans le dossier usr/bin de Rtools (C:\\Rtools42\\usr\\bin pour la version 4.2).Un autre avertissement est renvoyé en absence de Ghostscript4 à télécharger et installer.\nCopier ensuite le contenu du dossier bin dans le dossier usr/bin de Rtools.","code":"\n# Rtools : déclaration du chemin, \n# nécessite de redémarrer RStudio\nwriteLines('PATH=\"${RTOOLS40_HOME}\\\\usr\\\\bin;${PATH}\"',\n           con = \"~/.Renviron\")"},{"path":"chap-logiciels.html","id":"mise-à-jour","chapter":"1 Logiciels","heading":"1.1.3 Mise à jour","text":"Il est conseillé d’utiliser la dernière version mineure de R : par exemple, 4.0.x jusqu’à la sortie de la version 4.1.\nIl est obligatoire d’utiliser la toute dernière version pour préparer un package soumis à CRAN.Des changements importants ont lieu entre les versions majeures (la version 4 ne permet pas d’utiliser un package compilé pour la version 3) mais aussi parfois entre versions mineures (un fichier de données binaires .rda enregistré sous la version 3.3 ne peut pas être lu par la version 3.6).\nIl est donc utile de mettre R à jour régulièrement.L’installation d’une nouvelle version ne désinstalle par automatiquement les versions anciennes, ce qui permet d’en utiliser plusieurs en cas de besoin (par exemple, si un package ancien et indispensable n’est plus disponible).\nEn usage courant, il est préférable de désinstaller manuellement les anciennes versions après l’installation d’une nouvelle.","code":""},{"path":"chap-logiciels.html","id":"sec:librairies","chapter":"1 Logiciels","heading":"1.1.4 Librairies","text":"Les packages de R se trouvent dans deux dossiers :la bibliothèque système (System Library) contient les packages fournis avec R : base, utils, graphics par exemple.\nElle se trouve dans un sous-répertoire du programme d’installation (C:\\Program Files\\R\\R-4.1.0\\library pour R version 4.1.0 sous Windows 10).La bibliothèque utilisateur (User Library) contient ceux installés par l’utilisateur.\nJusqu’à la version 4.1, elle se trouve dans le dossier personnel de l’utilisateur, dans un sous-dossier R\\win-library\\4.1\\).\nDepuis la version 4.2, ce dossier se trouve dans les paramètres locaux de l’utilisateur dont l’emplacement du dossier se trouve dans la variable d’environnement %LOCALAPPDATA%.Jusqu’à la version 4.1, si le dossier personnel de l’utilisateur est sauvegardé (par exemple, s’il est répliqué dans le cloud par OneDrive sous Windows), il n’est pas optimal d’y placer les packages : le trafic généré par leur sauvegarde serait lourd et inutile.\nPour que les packages soient installés automatiquement dans la bibliothèque système, il suffit que l’utilisateur y ait le droit d’écrire.\nSous Windows, donner le droit “Modifier” au groupe des utilisateurs de l’ordinateur sur le dossier de la bibliothèque, en plus du droit de lecture par défaut 1.1).\npartir de la version 4.2, il n’y plus de raison de modifier le fonctionnement par défaut : les paramètres locaux ne sont pas sauvegardés.\nFigure 1.1: Activation du droit de modifier la bibliothèque système sous Windows.\nSi la bibliothèque utilisateur est retenue, il faut penser à vider le dossier correspondant à l’ancienne version de R en cas changement de version mineure.L’emplacement des librairies est donné par la fonction .libPaths() :","code":"\n.libPaths()## [1] \"/Users/runner/work/_temp/Library\"                                    \n## [2] \"/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library\""},{"path":"chap-logiciels.html","id":"rstudio","chapter":"1 Logiciels","heading":"1.2 RStudio","text":"RStudio est une interface graphique pour R et bien plus : il est conçu pour simplifier la gestion des projets, faciliter la rédaction et la production de documents et intégrer le contrôle de source par exemple.","code":""},{"path":"chap-logiciels.html","id":"installation-1","chapter":"1 Logiciels","heading":"1.2.1 Installation","text":"Installer la dernière version de RStudio Desktop à partir du site de RStudio5.Une commande est disponible dans le menu “Help” de RStudio pour vérifier l’existence d’une version plus récente, à installer.","code":""},{"path":"chap-logiciels.html","id":"encodage-des-fichiers","chapter":"1 Logiciels","heading":"1.2.2 Encodage des fichiers","text":"Les fichiers manipulés dans R sont très majoritairement des fichiers texte.\nLes caractères spéciaux, notamment les accents, peuvent être codés de diverses façons mais la déclaration du codage n’est pas intégrée aux fichiers.\nLe codage par défaut dépend du système d’exploitation, ce qui pose régulièrement des problèmes de lisibilité des fichiers partagés.\nLe codage UTF8 est devenu le standard parce qu’il est universellement reconnu et supporte tous les alphabets sans ambiguïtés.Dès la première utilisation de RStudio, créer un nouveau fichier R (menu “File > New File > R Script”), l’enregistrer au format UTF8 (“File > Save Encoding…”), choisir UTF8 dans la liste des formats et cocher la case “Set default encoding source files”.\nSupprimer le fichier après l’avoir enregistré.Les nouveaux fichiers seront codés au format UTF8.\nLes fichiers codés sous un autre format ne s’afficheront pas correctement : ils pourront être réouverts avec leur codage d’origine (“File > Reopen Encoding…”), en essayant éventuellement plusieurs codages jusqu’à obtenir un affichage correct, et sauvegardés au format UTF8 ensuite.","code":""},{"path":"chap-logiciels.html","id":"dossier-de-travail","chapter":"1 Logiciels","heading":"1.2.3 Dossier de travail","text":"Le dossier de travail par défaut est le dossier personnel de l’utilisateur, appelé ~ par RStudio :Mes Documents sous Windows ;Home sous Mac ou Linux.Il faut systématiquement travailler dans des sous-dossiers de ~, par exemple : ~/Formation.Pour le bon fonctionnement des RTools, le nom complet du répertoire de travail ne doit pas contenir d’espace (utiliser les tirets bas _) ni de caractère spécial.\nLe dossier de travail en cours est obtenu par la commande getwd().L’utilisation du contrôle de source (voir chapitre 3) crée de nombreux fichiers de travail.\nLes projets sous contrôle de source ne devraient pas se trouver dans un dossier déjà sauvegardé par un autre moyen, comme un lecteur OneDrive sous Windows, sous peine d’une utilisation excessive des ressources : chaque validation de modifications engendre la sauvegarde des fichiers modifiés, mais aussi des fichiers de contrôle qui peuvent être de grande taille.","code":"\nSys.getenv(\"R_USER\")\ngetwd()## [1] \"/Users/runner/work/travailleR/travailleR\""},{"path":"chap-logiciels.html","id":"sec:solution-dossiers","chapter":"1 Logiciels","heading":"1.2.4 Solution retenue","text":"L’organisation de l’environnement travail est une affaire personnelle, qui dépend des préférences de chacun.\nL’organisation proposée ici n’est qu’une possibilité, à adapter à ses propres choix, mais en respectant les contraintes mentionnées.Sous Windows, une organisation optimale est la suivante :Dans son dossier personnel (Mes Documents, ~ pour R), un dossier R est utilisé pour les projets simples, sans contrôle de source.\nLa sauvegarde de ce dossier est gérée par ailleurs.Un dossier hors du dossier personnel est utilisé pour les projets sous contrôle de source.\nL’utilisateur doit y avoir le droit d’écrire.\nDans l’organisation de Windows, le dossier correspondant à ces critères est %LOCALAPPDATA%, typiquement C:\\Users\\NomUtilisateur\\AppData\\Local.\nLe dossier sera donc %LOCALAPPDATA%\\ProjetsR à créer : exécuter md %LOCALAPPDATA%\\ProjetsR dans une invite de commande.\nEpingler ce dossier à l’accès rapide de l’explorateur de fichiers (figure 1.2) : coller %LOCALAPPDATA%\\ProjetsR dans la barre d’adresse de l’explorateur de fichiers, valider, puis faire un clic droit sur “Accès Rapide” et épingler le dossier.\nFigure 1.2: Dossier pour les projets sous contrôle de source, sous Windows.\n","code":""},{"path":"chap-logiciels.html","id":"police-de-caractères","chapter":"1 Logiciels","heading":"1.2.5 Police de caractères","text":"La police Fira Code6 fournit des ligatures : les caractères “<-” utilisés pour l’assignation dans R sont par exemple affichés comme une flèche.\nPour l’utiliser dans l’éditeur de RStudio, il suffit de l’installer en suivant les instructions appropriées à son système d’exploitation et de la déclarer dans les options globales (menu “Tools > Global Options…”) : sélectionner Appearance et l’option Editor Font : Fira Code.","code":""},{"path":"chap-logiciels.html","id":"packages","chapter":"1 Logiciels","heading":"1.3 Packages","text":"","code":""},{"path":"chap-logiciels.html","id":"installation-depuis-cran","chapter":"1 Logiciels","heading":"1.3.1 Installation depuis CRAN","text":"L’installation classique des packages fait appel à CRAN.\nUn bouton “Install” se trouve dans la fenêtre Packages de RStudio.Les packages sont déposés sur CRAN par leurs auteur sous forme de code source, compressé dans une fichier .tar.gz.\nIls sont disponibles pour le téléchargement dès leur validation.\nIls doivent ensuite être mis au format binaire pour Windows (dans un fichier .zip), ce qui prend un peu de temps.la demande de l’installation d’un package sous Windows, CRAN propose la version source plutôt que la version binaire si elle est plus récente 1.3).\nFigure 1.3: Activation du droit de modifier la bibliothèque système sous Windows.\nLa liste des packages concernés est affichée dans la console, par exemple :Certains packages nécessitent une compilation (colonne needs_compilation), en général parce qu’ils contiennent du code C++.\nIls ne pourront être installés que par les Rtools.L’installation des packages en version source est beaucoup plus longue qu’en version binaire.\nSauf si une version précise d’un package est nécessaire, il est donc préférable de refuser l’installation des versions source.Les packages peuvent être mis à jour un peu plus tard, après leur compilation par CRAN.Le bouton “Update” dans la fenêtre Packages de RStudio permet de mettre à jour tous les packages installés.","code":"  There are binary versions available but the source \n  versions are later:\n              binary   source needs_compilation\nboot          1.3-24   1.3-25             FALSE\nclass         7.3-16   7.3-17              TRUE"},{"path":"chap-logiciels.html","id":"installation-depuis-github","chapter":"1 Logiciels","heading":"1.3.2 Installation depuis GitHub","text":"Certains packages ne sont pas disponibles sur CRAN mais seulement sur GitHub parce qu’ils sont encore en développement ou parce qu’ils ne sont pas destinés à un large usage par la communauté des utilisateurs de R.\nIl peut aussi être utile d’installer une version de développement d’un package publié sur CRAN pour un usage ponctuel comme le test de nouvelles fonctionnalités.L’installation est gérée par le package remotes.\nL’argument build_vignettes est nécessaire pour créer les vignettes du package.Le nom du package est entré sous la forme “GitHubID/NomduPackage”.\nL’installation est faite à partir du code source et nécessite donc les Rtools si une compilation est nécessaire.\ninstall_github() vérifie que la version sur GitHub est plus récente que l’éventuelle version installée sur le poste de travail et ne fait rien si elles sont identiques.","code":"\nremotes::install_github(\"EricMarcon/memoiR\", build_vignettes = TRUE)"},{"path":"chap-logiciels.html","id":"installation-depuis-bioconductor","chapter":"1 Logiciels","heading":"1.3.3 Installation depuis Bioconductor","text":"Bioconductor est une plateforme complémentaire de CRAN qui héberge des packages spécialisés dans la génomique.\nL’installation des packages de Bioconductor nécessite le package BiocManager pour sa fonction install().\nLe premier argument de la fonction est un vecteur de caractères contenant les noms des packages à installer, par exemple :La fonction install() appelée sans arguments met à jour les packages.","code":"\nBiocManager::install(c(\"GenomicFeatures\", \"AnnotationDbi\"))"},{"path":"chap-logiciels.html","id":"solution-retenue","chapter":"1 Logiciels","heading":"1.3.4 Solution retenue","text":"chaque mise à jour mineure de R, tous les packages doivent être réinstallés.\nLa façon la plus efficace de le faire est de créer un script Packages.R à placer dans ~\\R.\nIl contient une fonction qui vérifie si chaque package est déjà installé pour ne pas le refaire inutilement.La dernière partie du script est à compléter avec les packages utilisés régulièrement.Ce script est à exécuter à chaque mise à jour de R, après avoir éventuellement activé le droit d’écriture dans la librairie système (voir section 1.1.4).","code":"\n# Installation des packages de R ####\n\n# Installer les packages si nécessaire ####\nInstallPackages <- function(Packages) {\n  sapply(Packages, function(Package) \n    if (!Package %in% installed.packages()[, 1]) \n      {install.packages(Package)})\n}\n\n\n# Outils de développement ####\nInstallPackages(c(\n  # Outils de développement. Importe remotes, etc.\n  \"devtools\",\n  # Exécution de Check par RStudio\n  \"rcmdcheck\",\n  # Formatage du code R (utilisé par knitr)\n  \"formatR\",\n  # Documentation des packages dans /docs sur GitHub\n  \"pkgdown\",\n  # Bibliographie avec roxygen\n  \"Rdpack\",\n  # Mesure des performances\n  \"rbenchmark\",\n  # Documentation automatique des packages\n  \"roxygen2\",\n  # Tests des packages\n  \"testthat\"\n  ))\n\n# Markdown ####\nInstallPackages(c(\n  # Tricot\n  \"knitr\",\n  # Documents markdown complexes\n  \"bookdown\",\n  # Sites web\n  \"blogdown\",\n  # Modèles de documents\n  \"memoiR\"\n  ))\n\n\n# Tidyverse ####\nInstallPackages(\"tidyverse\")"},{"path":"chap-logiciels.html","id":"git-et-github","chapter":"1 Logiciels","heading":"1.4 git et GitHub","text":"","code":""},{"path":"chap-logiciels.html","id":"git","chapter":"1 Logiciels","heading":"1.4.1 git","text":"git est le logiciel de contrôle de source utilisé ici.\nSon utilisation est détaillée dans le chapitre 3.Pour Windows et Mac, l’installation lieu à partir du site web de git7.git est intégré dans les distributions Linux.\nPour Ubuntu, le package apt est git-.git est installé sans interface graphique, fournie par RStudio.Dans RStudio, modifier les options globales (menu “Tools > Global Options…”).\nSélectionner Terminal et l’option New Terminals open  : GitBash.Vérifier la bonne installation de git en tapant la commande git -h dans le terminal de RStudio : l’aide doit s’afficher.Après l’installation de git, il est possible que le terminal de RStudio ne fonctionne plus correctement et renvoie un message d’erreur contenant les éléments suivants :Le message d’erreur est imprécis : la librairie qui ne doit exister qu’en un seul exemplaire n’est pas cygwin1.dll mais msys-2.0.dll.\nRechercher ce fichier dans les dossier d’installation de git et de Rtools.\nIls se trouvent normalement dans usr/bin.\nRemplacer celui de git par celui de Rtools : la version des deux fichiers doit être identique.Entrer ses informations d’identification en exécutant les commandes suivantes dans le terminal :Le nom d’utilisateur est libre, de préférence “Prénom Nom”.","code":"*** fatal error - cygheap base mismatch detected\nThis problem is probably due to using incompatible \nversions of the cygwin DLL.git config user.name\ngit config user.email"},{"path":"chap-logiciels.html","id":"github","chapter":"1 Logiciels","heading":"1.4.2 GitHub","text":"GitHub est la plateforme accessible par un site web qui permet de partager le contenu des dépôts git.\nPour l’utiliser, il suffit d’ouvrir un compte avec la même adresse de messagerie que celle enregistrée dans git.Le nom du compte GitHub est noté ici GitHubID.\nChaque compte GitHub permet d’héberger des dépôts (un dépôt contient les fichiers d’un projet) à l’adresse https://github.com/GitHubID/NomDuDepot8.\nChaque dépôt peut disposer d’un site web à l’adresse https://GitHubID.github.io/NomDuDepot/9.\nEnfin, un site web global est prévu pour chaque utilisateur à l’adresse https://GitHubID.github.io/10.","code":""},{"path":"chap-logiciels.html","id":"sec:SSH","chapter":"1 Logiciels","heading":"1.4.3 Authentification SSH","text":"La communication entre git (installé sur l’ordinateur local) et GitHub (plateforme en ligne) nécessite de s’authentifier.Deux méthodes sont disponibles : HTTPS (aussi appelée SSL) et SSH.\nSSH est la plus robuste mais nécessite la création d’une clé privée.Dans le terminal de RStudio, exécuter :L’adresse de messagerie (qui remplace “user.email”) doit être celle enregistrée dans la configuration de git et le compte GitHub.\nLa clé est enregistrée dans le dossier .ssh du répertoire personnel de l’utilisateur.\nIl est possible d’ajouter un mot de passe (passphrase) à la clé, qui devra être tapé à la première utilisation de chaque session de travail.\nSi l’ordinateur est correctement sécurisé (pas d’accès physique par des tiers), la laisser vide permet de gagner en fluidité.Attention : la clé privée est strictement confidentielle et ne doit être copiée nulle part où elle pourrait être lue par un tiers (attention aux sauvegardes automatiques notamment).\nElle n’pas besoin d’être bien sauvegardée : en cas de perte, elle sera remplacée facilement.Les clés sont normalement stockées dans le dossier ~/.ssh, quel que soit le système d’exploitation, mais l’emplacement du dossier personnel ~ est ambiguë sous Windows : pour R, c’est le dossier Documents, mais pour d’autres logiciels, c’est le dossier racine de l’utilisateur, parent de Documents.Dans le terminal de RStudio, vérifier le bon fonctionnement de la clé :Si un message d’erreur indique qu’aucune clé n’est trouvée, deux solutions sont possibles :Dupliquer le dossier .ssh (avec l’explorateur de fichiers) dans Documents ;Dupliquer le dossier .ssh dans le dossier du programme RStudio (généralement C:\\Program Files\\RStudio\\), dans resources\\terminal\\bash\\.En cas de succès, un message indique que l’authenticité du serveur GitHub ne peut pas être vérifiée : un contrôle manuel est nécessaire pour la première connexion.\nVérifier auprès de GitHub que l’empreinte du serveur est correcte11 et taper yes.\nLe serveur est ajouté automatiquement à la liste des serveurs connus, dans le fichier known_hosts.Dans le dossier .ssh, deux fichiers sont créés : l’un contient la clé privée, l’autre, avec l’extension .pub, la clé publique correspondante.\nOuvrir le second avec un éditeur de texte et copier la clé publique dans le presse-papier.\nSur GitHub, afficher les réglages de son compte (menu “Settings”), sélectionner “SSH GPG Keys”, cliquer sur “New SSH Key” et coller la clé dans le champ “Key”.\nDonner un nom à la clé dans le champ “Title”.\nLe nom peut être celui de l’ordinateur sur lequel la clé été créée.\nLa clé ne doit pas être copiée sur plusieurs ordinateurs : en cas de besoin, créer une nouvelle clé sur chaque poste de travail utilisé.Si la clé est compromise (perte ou prêt de l’ordinateur qui la contient), la supprimer sur GitHub et en créer une nouvelle.","code":"ssh-keygen -t ed25519 -C \"user.email\"ssh -T git@github.com"},{"path":"chap-logiciels.html","id":"sec:pat","chapter":"1 Logiciels","heading":"1.4.4 Obtention d’un jeton d’accès personnel","text":"L’authentification HTTPS est l’alternative à l’authentification SSL : il faut choisir une méthode et s’y tenir par la suite.\nPour utiliser l’authentification HTTPS, la création d’un jeton d’accès personnel est nécessaire.Les jetons sont créés sur GitHub, dans les paramètres de son compte d’utilisateur, dans “Developer Settings > Personal Access Tokens”12.Générer un nouveau jeton, le décrire en tant que “git-RStudio” et lui donner l’autorisation “repo”, c’est-à-dire modifier tous les dépôts (il n’est pas possible de limiter l’accès à un dépôt particulier).\nLe jeton est une chaîne de caractère qui ne pourra pas être relue plus tard : elle doit être sauvegardée comme un mot de passe.","code":""},{"path":"chap-logiciels.html","id":"compilateur-latex","chapter":"1 Logiciels","heading":"1.5 Compilateur LaTeX","text":"Pour produire des documents au format PDF, une distribution LaTeX est nécessaire.\nLa solution légère consiste à installer le package tinytex qui installe à son tour une distribution LaTeX optimisée pour R Markdown.Une distribution complète permet l’utilisation de LateX au-delà de RStudio mais est inutile si l’usage de LaTeX se limite au tricot de documents R Markdown.\nMiKTeX est une très bonne solution pour Windows et Mac.","code":""},{"path":"chap-logiciels.html","id":"tinytex","chapter":"1 Logiciels","heading":"1.5.1 tinytex","text":"Installer le package puis exécuter :L’ajout de packages LaTeX non inclus dans la distribution minimale de départ est automatique mais peut être lente.La distribution peut être mise à jour par la commande :","code":"\ntinytex::install_tinytex()\ntinytex::tlmgr_update()"},{"path":"chap-logiciels.html","id":"miktex","chapter":"1 Logiciels","heading":"1.5.2 MiKTeX","text":"","code":""},{"path":"chap-logiciels.html","id":"installation-2","chapter":"1 Logiciels","heading":"1.5.2.1 Installation","text":"Télécharger le fichier d’installation13 et l’exécuter.\nPlusieurs choix sont à faire pendant l’installation :Installer le programme pour tous les utilisateurs (avec des droits d’administrateur) ;Le format par défaut du papier : choisir A4 ;Le mode d’installation des packages manquants : choisir “Always Install” pour qu’ils soient téléchargés automatiquement en cas de besoin.Pour Linux, suivre les instructions sur le site de MiKTeX.","code":""},{"path":"chap-logiciels.html","id":"mises-à-jour","chapter":"1 Logiciels","heading":"1.5.2.2 Mises à jour","text":"MiKTeX est installé avec les packages LaTeX les plus utilisés.\nSi un document nécessite un package manquant, il est chargé automatiquement.\nLes mises à jour de packages doivent être faites périodiquement avec la console MiKTeX, accessible dans le menu Démarrer.Quand elle est lancée sans élévation des privilèges, la console propose de passer en mode administrateur.\nCliquer sur “Switch Administrator mode”.Dans les paramètres (Settings), vérifier que les packages s’installent toujours automatiquement et que le format du papier est bien A4.Dans le menu des mises à jour (Updates), cliquer sur “Check updates” puis “Update now”.Si l’installation automatique est défaillante, il est possible d’installer manuellement un package dans le menu “Packages”.","code":""},{"path":"chap-logiciels.html","id":"sec:Zotero","chapter":"1 Logiciels","heading":"1.6 Zotero","text":"Zotero14 est le logiciel de gestion bibliographique le plus utilisé.\nSes extensions permettent de compléter ses fonctionnalités selon les besoins de chacun.\nBetter BibTeX permet d’exporter et de maintenir à jour une sélection des références bibliographiques (une collection de Zotero) sous la forme d’un fichier BibTeX dans un projet R, où il pourra être utilisé dans la rédaction de documents ou la documentation de packages.Télécharger le fichier d’installation et l’exécuter.\nCréer un compte utilisateur sur le site web de Zotero.\nLier l’installation locale au compte : dans le menu “Edition > Paramètres”, sélectionner “Synchronisation” et s’authentifier dans la zone “Synchronisation des données”.\nCocher ensuite la case “Synchroniser automatiquement” mais pas “Synchroniser le texte intégral des pièces jointes indexées” parce que la taille totale des textes intégraux synchronisés de cette manière entre le compte Zotero en ligne et le poste de travail est limitée à 300 Mo.\nDésactiver ensuite les deux options dans Synchronisation des fichiers.Télécharger l’extension Better BibTeX15 et l’installer avec le menu “Outils > Extensions” : cliquer sur le bouton des paramètres en haut à droite de la fenêtre, puis “Install Add-File…” et sélectionner le fichier qui vient d’être téléchargé.Paramétrer Better BibTeX à partir du menu “Edition > Paramètres”, “Better BibTeX”.\nLes options à modifier sont les suivantes :“Clés de citation > Format de clé” : [auth:capitalize][year] pour que les citations disposent d’un identifiant unique de la forme “Nom2021” ;“Clés de citation > Conserver les clés de citation uniques dans” : “Toutes les collections” pour que les identifiants des citations ne soient pas ambigus ;“Exportation > Gestion des Champs > Champs à exclure de l’exportation” : “abstract, file” pour ne pas générer des fichiers bibliographiques surchargés d’informations inutiles dans les projets R.Il est conseillé d’utiliser l’extension ZotMoov16 pour mieux contrôler l’emplacement du texte intégral (les fichiers PDF liés au références bibliographiques).\nL’installer puis la paramétrer dans “Edition > Paramètres”, “ZotMoov”.\nChoisir le dossier de stockage des textes intégraux dans “Directory Move Files ”.\nSi le dossier personnel de l’utilisateur est sauvegardé (par exemple, s’il est répliqué dans le cloud par OneDrive sous Windows), y placer ce dossier de stockage permet à la fois de sauvegarder les textes intégraux mais aussi d’y accéder à partir de plusieurs postes de travail ou directement en ligne.\nCette solution est bien plus efficace que la synchronisation par défaut de Zotero, limitée en volume.Sélectionner ensuite le dossier de téléchargement dans “Source Folder Attaching New Files”.\nLe menu contextuel “ZotMoov : Attach New File” permettra alors de lier automatiquement le dernier fichier téléchargé à la référence choisie.Enfin, dans les options avancées de Zotero (“Edition > Paramètres”, “Avancé”), choisir le répertoire de base pour les pièces jointes liées : ce doit être le même que celui choisi pour le stockage des textes intégraux.","code":""},{"path":"chap-logiciels.html","id":"go","chapter":"1 Logiciels","heading":"1.7 Go","text":"Go17 n’est utilisé que par le générateur de sites web Hugo (voir section 4.7).Télécharger le fichier d’installation et l’exécuter.\nla fin de l’installation, exécuter la commande go version dans un terminal pour vérifier son bon fonctionnement.Les mises à jour se font en installant la nouvelle version par dessus la précédente.","code":""},{"path":"chap-utiliseR.html","id":"chap-utiliseR","chapter":"2 Utiliser R","heading":"2 Utiliser R","text":"La documentation consacrée à l’apprentissage de R est florissante.\nLes ouvrages suivants sont une sélection arbitraire mais utile pour progresser :L’Introduction à R et au tidyverse (Barnier 2020) est un excellent cours de prise en main.Advanced R (Wickham 2014) est la référence pour maîtriser les subtilités du langage et bien comprendre le fonctionnement de R.R Data Science (Wickham et Grolemund 2016) présente une méthode de travail complète, cohérente avec le tidyverse.Enfin, Efficient R programming (Gillespie et Lovelace 2016) traite de l’optimisation du code.Quelques aspects avancés du codage sont vus ici.\nDes précisions sur les différents langages de R sont utiles pour la création de packages.\nLes environnements sont présentés ensuite, pour la bonne compréhension de la recherche des objets appelés par le code.\nEnfin, l’optimisation des performances du code est traitée en détail (boucles, code C++ et parallélisation) et illustrée par une étude de cas.","code":""},{"path":"chap-utiliseR.html","id":"les-langages-de-r","chapter":"2 Utiliser R","heading":"2.1 Les langages de R","text":"R comprend plusieurs langages de programmation.\nLe plus courant est S3, mais ce n’est pas le seul18.","code":""},{"path":"chap-utiliseR.html","id":"base","chapter":"2 Utiliser R","heading":"2.1.1 Base","text":"Le cœur de R est constitué des fonctions primitives et structures de données de base comme la fonction sum et les données de type matrix :Le package pryr permet d’afficher le langage dans lequel des objets sont définis.\nLa fonction typeof() affiche le type de stockage interne des objets :la fonction sum() appartient au langage de base de R et est une fonction primitive (builtin) ;les éléments de la matrice numérique contenant un seul 1 sont des réels à double précision, et la matrice elle-même est définie dans le langage de base.Les fonctions primitives sont codées en C et sont très rapides.\nElles sont toujours disponibles, quels que soient les packages chargés.\nLeur usage est donc à privilégier.","code":"\npryr::otype(sum)## [1] \"base\"\ntypeof(sum)## [1] \"builtin\"\npryr::otype(matrix(1))## [1] \"base\"\ntypeof(matrix(1))## [1] \"double\""},{"path":"chap-utiliseR.html","id":"sec:S3","chapter":"2 Utiliser R","heading":"2.1.2 S3","text":"S3 est le langage le plus utilisé, souvent le seul connu par les utilisateurs de R.C’est un langage orienté objet dans lequel les classes, c’est-à-dire le type des objets, sont déclaratives.La variable MonPrenom est ici de classe “Prenom” par une simple déclaration.Contrairement au fonctionnement d’un langage orienté objet classique19, les méthodes S3 sont liées aux fonctions, pas aux objets.Dans cet exemple, la méthode print() appliquée à la classe “Prenom” est modifiée.\nDans un langage orienté objet classique, la méthode serait définie dans la classe Prenom.\nDans R, les méthodes sont définies à partir de méthodes génériques.print est une méthode générique (“un générique”) déclaré dans base.Son code se résume à une déclaration UseMethod(\"print\") :Il existe beaucoup de méthodes S3 pour print :Chacune s’applique à une classe. print.default est utilisée en dernier ressort et s’appuie sur le type de l’objet, pas sur sa classe S3.Un objet peut appartenir à plusieurs classes, ce qui permet une forme d’héritage des méthodes.\nDans un langage orienté objet classique, l’héritage permet de définir des classes plus précises (“PrenomFrancais”) qui héritent de classes plus générales (“Prenom”) et bénéficient de cette façon de leurs méthodes sans avoir à les redéfinir.\nDans R, l’héritage consiste simplement à déclarer un vecteur de classes de plus en plus larges pour un objet :Le générique cherche une méthode pour chaque classe, dans l’ordre de leur déclaration.En résumé, S3 est le langage courant de R.\nPresque tous les packages sont écrits en S3.\nLes génériques sont partout mais passent inaperçus, par exemple dans des packages :La fonction .S3methods() permet d’afficher toutes les méthodes disponibles pour une classe, par opposition à methods() qui affiche toutes les classes pour lesquelles la méthode passée en argument est définie.De nombreuses fonctions primitives de R sont des méthodes génériques.\nUtiliser l’aide help(InternalMethods) pour les découvrir.","code":"\nMonPrenom <- \"Eric\"\nclass(MonPrenom) <- \"Prenom\"\n# Affichage par défaut\nMonPrenom## [1] \"Eric\"\n## attr(,\"class\")\n## [1] \"Prenom\"\nprint.Prenom <- function(x) cat(\"Le prénom est\", x)\n# Affichage modifié\nMonPrenom## Le prénom est Eric\npryr::otype(print)## [1] \"base\"\nprint## function (x, ...) \n## UseMethod(\"print\")\n## <bytecode: 0x1555438a8>\n## <environment: namespace:base>\nhead(methods(\"print\"))## [1] \"print.acf\"               \"print.activeConcordance\"\n## [3] \"print.AES\"               \"print.all_vars\"         \n## [5] \"print.anova\"             \"print.any_vars\"\ntypeof(MonPrenom)## [1] \"character\"\npryr::otype(MonPrenom)## [1] \"S3\"\n# Définition des classes par un vecteur\nclass(MonPrenom) <- c(\"PrenomFrancais\", \"Prenom\")\n# Ecriture alternative, avec inherits()\ninherits(MonPrenom, what = \"PrenomFrancais\")## [1] TRUE\ninherits(MonPrenom, what = \"Prenom\")## [1] TRUE\nprint.PrenomFrancais <- function(x) cat(\"Prénom français:\",\n    x)\nMonPrenom## Prénom français: Eric\nlibrary(\"entropart\")\n.S3methods(class = \"SpeciesDistribution\")## [1] autoplot plot    \n## see '?methods' for accessing help and source code"},{"path":"chap-utiliseR.html","id":"s4","chapter":"2 Utiliser R","heading":"2.1.3 S4","text":"S4 est une évolution de S3 qui structure les classes pour se rapprocher d’un langage orienté objet classique :les classes doivent être définies explicitement, pas simplement déclarées ;les attributs (c’est-à-dire les variables décrivant les objets), appelés slots, sont déclarés explicitement ;le constructeur, c’est-à-dire la méthode qui crée un nouvelle instance d’une classe (c’est-à-dire une variable contenant un objet de la classe), est explicite.En reprenant l’exemple précédent, la syntaxe S4 est la suivante :Les méthodes appartiennent toujours aux fonctions.\nElles sont déclarées par la fonction setMethod() :Les attributs sont appelés par la syntaxe variable@slot.En résumé, S4 est plus rigoureux que S3.\nQuelques packages sur CRAN : Matrix, sp, odbc… et beaucoup sur Bioconductor sont écrits en S4 mais le langage est maintenant clairement délaissé au profit de S3, notamment à cause du succès du tidyverse.","code":"\n# Définition de la classe Personne, avec ses slots\nsetClass(\"Personne\",  \n         slots = list(Nom = \"character\", Prenom = \"character\"))\n# Construction d'une instance\nMoi <- new(\"Personne\", Nom = \"Marcon\", Prenom = \"Eric\")\n# Langage\npryr::otype(Moi)## [1] \"S4\"\nsetMethod(\"print\", signature = \"Personne\", function(x, ...) {\n    cat(\"La personne est:\", x@Prenom, x@Nom)\n})\nprint(Moi)## La personne est: Eric Marcon"},{"path":"chap-utiliseR.html","id":"rc","chapter":"2 Utiliser R","heading":"2.1.4 RC","text":"RC été introduit dans R 2.12 (2010) avec le package methods.Les méthodes appartiennent aux classes, comme en C++ : elles sont déclarées dans la classe et appelées à partir des objets.RC est un langage confidentiel, bien que ce soit le premier “vrai” langage orienté objet de R.","code":"\nlibrary(\"methods\")\n# Déclaration de la classe\nPersonneRC <- setRefClass(\"PersonneRC\", \n    fields = list(Nom = \"character\", Prenom = \"character\"),\n    methods = list(print = function() cat(Prenom, Nom)))\n# Constructeur\nMoiRC <- new(\"PersonneRC\", Nom = \"Marcon\", Prenom =\"Eric\")\n# Langage\npryr::otype(MoiRC)## [1] \"RC\"\n# Appel de la méthode print\nMoiRC$print()## Eric Marcon"},{"path":"chap-utiliseR.html","id":"s6","chapter":"2 Utiliser R","heading":"2.1.5 S6","text":"S620 perfectionne RC mais n’est pas inclus dans R : il nécessite d’installer son package.Les attributs et les méthodes peuvent être publics ou privés.\nUne méthode initialize() est utilisée comme constructeur.S6 permet de programmer rigoureusement en objet mais est très peu utilisé.\nLes performances de S6 sont bien supérieures à celles de RC mais sont inférieures à celles de S321.La non-inclusion de R6 à R est montrée par pryr :","code":"\nlibrary(\"R6\")\nPersonneR6 <- R6Class(\"PersonneR6\", public = list(Nom = \"character\",\n    Prenom = \"character\", initialize = function(Nom = NA, Prenom = NA) {\n        self$Nom <- Nom\n        self$Prenom <- Prenom\n    }, print = function() cat(self$Prenom, self$Nom)))\nMoiR6 <- PersonneR6$new(Nom = \"Marcon\", Prenom = \"Eric\")\nMoiR6$print()## Eric Marcon\npryr::otype(MoiR6)## [1] \"S3\""},{"path":"chap-utiliseR.html","id":"tidyverse","chapter":"2 Utiliser R","heading":"2.1.6 Tidyverse","text":"Le tidyverse est un ensemble de packages cohérents qui ont fait évoluer la façon de programmer R.\nL’ensemble des packages indispensables peut être chargé par le package tidyverse qui n’pas d’autre utilité :Il ne s’agit pas d’un nouveau langage à proprement parler mais plutôt d’une extension de S3, avec de profondes modifications techniques, notamment l’évaluation non conventionnelle des expressions22, qu’il n’est pas essentiel de maîtriser en détail.Ses principes sont inscrits dans un manifeste23.\nSon apport le plus visible pour l’utilisateur sont l’enchaînement des commandes dans un flux (pipeline de code).En programmation standard, l’enchaînement des fonctions s’écrit par emboîtements successifs, ce qui en rend la lecture difficile, surtout quand des arguments sont nécessaires :Dans le tidyverse, les fonctions s’enchaînent, ce qui correspond souvent mieux à la réflexion du programmeur sur le traitement des données :Le tuyau %>% est un opérateur qui appelle la fonction suivante en lui passant comme premier argument le résultat de la fonction précédente.\nLes arguments supplémentaires sont passés normalement : pour la lisibilité du code, il est indispensable de les nommer.\nLa plupart des fonctions de R sont utilisables sans difficultés dans le tidyverse bien qu’elles n’aient pas été prévues pour cela : il suffit que leur premier argument soit les données à traiter.Le pipeline ne permet de passer qu’une seule valeur à la fonction suivante, ce qui interdit les fonctions multidimensionnelles, de type f(x,y).\nLa structure de données préférée est le tibble, qui est un dataframe amélioré : sa méthode print() est plus lisible, et il corrige quelques comportements non-intuitifs des dataframes, comme la conversion automatique en vecteurs des dataframes à une seule colonne.\nLes colonnes du dataframe ou du tibble permettent de passer autant de données que nécessaire.Enfin, la visualisation des données est prise en charge par ggplot2 qui s’appuie sur une grammaire des graphiques (Wickham 2010) solide sur le plan théorique.\nSchématiquement, un graphique est construit selon le modèle suivant :les données sont obligatoirement un dataframe ;la géométrie est le type de graphique choisi (points, lignes, histogrammes ou autre) ;l’esthétique (fonction aes()) désigne ce qui est représenté : c’est la correspondance entre les colonnes du dataframe et les éléments nécessaires à la géométrie ;la statistique est le traitement appliqué aux données avant de les transmettre à la géométrie (souvent “identity”, c’est-à-dire aucune transformation mais “boxplot” pour une boîte à moustache).\nLes données peuvent être transformées par une fonction d’échelle, comme scale_y_log10() ;la position est l’emplacement des objets sur le graphique (souvent “identity” ; “stack” pour un histogramme empilé, “jitter” pour déplacer légèrement les points superposés dans un geom_point) ;les coordonnées définissent l’affichage du graphique (coord_fixed() pour ne pas déformer une carte par exemple) ;enfin, les facettes offrent la possibilité d’afficher plusieurs aspects des mêmes données en produisant un graphique par modalité d’une variable.L’ensemble formé par le pipeline et ggplot2 permet des traitements complexes dans un code lisible.\nLa figure 2.1 montre le résultat du code suivant :\nFigure 2.1: Prix des diamants en fonction de leur poids. Démonstration du code de ggplot2 combiné au traitement de données du tidyverse.\nDans cette figure, deux géométries (nuage de points et régression linéaire) partagent la même esthétique (prix en fonction du poids en carats) qui est donc déclarée en amont, dans la fonction ggplot().Le tidyverse est documenté en détail dans Wickham et Grolemund (2016) et ggplot2 dans Wickham (2017).","code":"\nlibrary(\"tidyverse\")\n# Logarithme de base 2 de la moyenne de 100 tirages\n# aléatoires dans une loi uniforme\nlog(mean(runif(100)), base = 2)## [1] -1.127903\n# 100 tirages aléatoires dans une loi uniforme\nrunif(100) %>% \n  # Moyenne\n  mean %>% \n  # Logarithme\n  log(base=2)## [1] -0.9772102ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  ) +\n  <COORDINATE_FUNCTION> +\n  <FACET_FUNCTION>\n# Données sur les diamants fournies par ggplot2\ndiamonds %>% \n  # Ne conserver que les diamants de plus d'un demi-carat\n  filter(carat > 0.5) %>% \n  # Graphique : prix en fonction du poids\n  ggplot(aes(x = carat, y = price)) +\n    # Nuage de points\n    geom_point() + \n    # Echelle logarithmique\n    scale_x_log10() + \n    scale_y_log10() + \n    # Régression linéaire\n    geom_smooth(method = \"lm\")"},{"path":"chap-utiliseR.html","id":"sec:environnements","chapter":"2 Utiliser R","heading":"2.2 Environnements","text":"Les objets de R, données et fonctions, sont nommés.\nComme R est modulaire, avec la possibilité de lui ajouter un nombre indéterminé de packages, il est très probable que des conflits de nom apparaissent.\nPour les régler, R dispose d’un système rigoureux de précédence des noms : le code s’exécute dans un environnement défini, héritant d’environnements parents.","code":""},{"path":"chap-utiliseR.html","id":"organisation","chapter":"2 Utiliser R","heading":"2.2.1 Organisation","text":"R démarre dans un environnement vide.\nChaque package chargé crée un environnement fils pour former une pile des environnements, dont chaque nouvel élément est appelé “fils” du précédent, qui est son “parent”.La console se trouve dans l’environnement global, fils du dernier package chargé.Le code d’une fonction appelée de la console s’exécute dans un environnement fils de l’environnement global :","code":"\nsearch()##  [1] \".GlobalEnv\"        \"package:R6\"       \n##  [3] \"package:entropart\" \"package:lubridate\"\n##  [5] \"package:forcats\"   \"package:stringr\"  \n##  [7] \"package:dplyr\"     \"package:purrr\"    \n##  [9] \"package:readr\"     \"package:tidyr\"    \n## [11] \"package:tibble\"    \"package:ggplot2\"  \n## [13] \"package:tidyverse\" \"package:stats\"    \n## [15] \"package:graphics\"  \"package:grDevices\"\n## [17] \"package:utils\"     \"package:datasets\" \n## [19] \"package:methods\"   \"Autoloads\"        \n## [21] \"package:base\"\n# Environnement actuel\nenvironment()## <environment: R_GlobalEnv>\n# La fonction f affiche son environnement\nf <- function() environment()\n# Affichage de l'environnement de la fonction\nf()## <environment: 0x156b62890>\n# Environnement parent de celui de la fonction\nparent.env(f())## <environment: R_GlobalEnv>"},{"path":"chap-utiliseR.html","id":"recherche","chapter":"2 Utiliser R","heading":"2.2.2 Recherche","text":"La recherche des objets commence dans l’environnement local.\nS’il n’est pas trouvé, il est cherché dans l’environnement parent, puis dans le parent du parent, jusqu’à l’épuisement des environnements qui génère une erreur indiquant que l’objet n’pas été trouvé.Exemple :La variable q est définie dans l’environnement global.\nLa fonction qLocalFonction définit sa propre variable q.\nL’appel de la fonction retourne la valeur locale de la fonction parce qu’elle se trouve dans l’environnement de la fonction.La fonction qGlobalEnv retourne la variable q qu’elle ne définit pas localement.\nElle la recherche donc dans son environnement parent et trouve la variable définie dans l’environnement global.\nEn supprimant la variable de l’environnement global par rm(q), la fonction qGlobalEnv() parcourt la pile des environnements jusqu’à trouver un objet nommé q dans le package base, qui est la fonction permettant de quitter R.\nElle aurait pu trouver un autre objet si un package contenant un objet q avait été chargé.Pour éviter ce comportement erratique, une fonction ne doit jamais appeler un objet non défini dans son propre environnement.","code":"\n# Variable q définie dans l'environnement global\nq <- \"GlobalEnv\"\n# Fonction définissant q dans son environnement\nqLocalFonction <- function() {\n    q <- \"Fonction\"\n    return(q)\n}\n# La variable locale est retournée\nqLocalFonction()## [1] \"Fonction\"\n# Fonction (mal écrite) utilisant une variable qu'elle ne\n# définit pas\nqGlobalEnv <- function() {\n    return(q)\n}\n# La variable de l'environnement global est retournée\nqGlobalEnv()## [1] \"GlobalEnv\"\n# Suppression de cette variable\nrm(q)\n# La fonction base::q est retournée\nqGlobalEnv()## function (save = \"default\", status = 0, runLast = TRUE) \n## .Internal(quit(save, status, runLast))\n## <bytecode: 0x1509deda0>\n## <environment: namespace:base>"},{"path":"chap-utiliseR.html","id":"espaces-de-nom-des-packages","chapter":"2 Utiliser R","heading":"2.2.3 Espaces de nom des packages","text":"Il est temps de définir précisément ce que les packages rendent visible.\nLes packages contiennent des objets (fonctions et données) qu’ils exportent ou non.\nIls sont habituellement appelés par la fonction library() qui effectue deux opérations :elle charge le package en mémoire, ce qui permet d’accéder à tous ses objets avec la syntaxe package::objet pour les objets exportés et package:::objet pour ceux qui ne le sont pas ;elle attache ensuite le package, ce qui place son environnement en haut de la pile.Il est possible de détacher un package avec la fonction unloadNamespace() pour le retirer de la pile des environnements.\nExemple :L’appel de entropart::Diversity() charge le package (c’est-à-dire, exécute implicitement loadNamespace(\"entropart\")) mais ne l’attache pas.En pratique, il faut limiter le nombre de package attachés pour limiter le risque d’appeler une fonction non désirée, homonyme de la fonction recherchée.\nDans les cas critiques, il faut utiliser le nom complet de la fonction : package::fonction().Un problème fréquent concerne la fonction filter() de dplyr homonyme de celle de stats.\nLe package stats est habituellement chargé avant dplyr, un package du tidyverse.\nstats::filter() doit donc être appelée explicitement.Cependant, le package dplyr ou tidyverse (qui attache tous les packages du tidyverse) peut être chargé systématiquement en créant un fichier .RProfile à la racine du projet contenant la commande :Dans ce cas, dplyr est chargé avant stats et c’est sa fonction qui est inaccessible.","code":"\n# entropart chargé et attaché\nlibrary(\"entropart\")\n# Est-il attaché ?\nisNamespaceLoaded(\"entropart\")## [1] TRUE\n# Pile des environnements\nsearch()##  [1] \".GlobalEnv\"        \"package:R6\"       \n##  [3] \"package:entropart\" \"package:lubridate\"\n##  [5] \"package:forcats\"   \"package:stringr\"  \n##  [7] \"package:dplyr\"     \"package:purrr\"    \n##  [9] \"package:readr\"     \"package:tidyr\"    \n## [11] \"package:tibble\"    \"package:ggplot2\"  \n## [13] \"package:tidyverse\" \"package:stats\"    \n## [15] \"package:graphics\"  \"package:grDevices\"\n## [17] \"package:utils\"     \"package:datasets\" \n## [19] \"package:methods\"   \"Autoloads\"        \n## [21] \"package:base\"\n# Diversity(), une fonction exportée par entropart est\n# trouvée\nDiversity(1, CheckArguments = FALSE)## None \n##    1\n# Détacher et décharger entropart\nunloadNamespace(\"entropart\")\n# Est-il attaché ?\nisNamespaceLoaded(\"entropart\")## [1] FALSE\n# Pile des environnements, sans entropart\nsearch()##  [1] \".GlobalEnv\"        \"package:R6\"       \n##  [3] \"package:lubridate\" \"package:forcats\"  \n##  [5] \"package:stringr\"   \"package:dplyr\"    \n##  [7] \"package:purrr\"     \"package:readr\"    \n##  [9] \"package:tidyr\"     \"package:tibble\"   \n## [11] \"package:ggplot2\"   \"package:tidyverse\"\n## [13] \"package:stats\"     \"package:graphics\" \n## [15] \"package:grDevices\" \"package:utils\"    \n## [17] \"package:datasets\"  \"package:methods\"  \n## [19] \"Autoloads\"         \"package:base\"\n# Diversity() est introuvable\ntryCatch(Diversity(1), error = function(e) print(e))## <simpleError in Diversity(1): could not find function \"Diversity\">\n# mais peut être appelée avec son nom complet\nentropart::Diversity(1, CheckArguments = FALSE)## None \n##    1\nlibrary(\"tidyverse\")"},{"path":"chap-utiliseR.html","id":"mesure-du-temps-dexécution","chapter":"2 Utiliser R","heading":"2.3 Mesure du temps d’exécution","text":"Le temps d’exécution d’un code long peut être mesuré très simplement par la commande system.time.\nPour des temps d’exécution très courts, il est nécessaire de répéter la mesure : c’est l’objet du package microbenchmark.","code":""},{"path":"chap-utiliseR.html","id":"system.time","chapter":"2 Utiliser R","heading":"2.3.1 system.time","text":"La fonction retourne le temps d’exécution du code.","code":"\n# Ecart absolu moyen de 1000 valeurs dans une loi uniforme,\n# répété 100 fois\nsystem.time(for (i in 1:100) mad(runif(1000)))##    user  system elapsed \n##   0.008   0.002   0.010"},{"path":"chap-utiliseR.html","id":"microbenchmark","chapter":"2 Utiliser R","heading":"2.3.2 microbenchmark","text":"Le package microbenchmark est le plus avancé.L’objectif est de comparer la vitesse du calcul du carré d’un vecteur (ou d’un nombre) en le multipliant par lui-même (\\(x \\times x\\)) ou en l’élevant à la puissance 2 (\\(x^2\\)).Le tableau retourné contient les temps minimum, médian, moyen, max et les premiers et troisièmes quartiles, ainsi que le nombre de répétitions.\nLa valeur médiane est à comparer.\nLe nombre de répétition est par défaut de 100, à moduler (argument times) en fonction de la complexité du calcul.Le résultat du test, un objet de type microbenchmark, est un tableau brut des temps d’exécution.\nL’analyse statistique est faite par les méthodes print et summary.\nPour choisir les colonnes à afficher, utiliser la syntaxe suivante :Pour faire des calculs sur ces résultats, il faut les stocker dans une variable.\nPour empêcher l’affichage dans la console, la solution la plus simple est d’utiliser la fonction capture.output en affectant son résultat à une variable.Le test précédent est affiché à nouveau.Le temps de calcul est à peu près identique entre \\(x \\times x\\) et \\(x^2\\).\nLe calcul de puissance est nettement plus long, surtout si la puissance n’est pas entière, parce qu’il nécessite un calcul de logarithme.\nLe calcul de la puissance 2 est donc optimisé par R pour éviter l’usage du log.Deux représentations graphiques sont disponibles : les violons représentent la densité de probabilité du temps d’exécution ; les boîtes à moustache sont classiques.","code":"\n# Fonctions à tester\nf1 <- function(x) x * x\nf2 <- function(x) x^2\nf3 <- function(x) x^2.1\nf4 <- function(x) x^3\n# Initialisation\nX <- rnorm(10000)\n# Test\nlibrary(\"microbenchmark\")\n(mb <- microbenchmark(f1(X), f2(X), f3(X), f4(X)))## Unit: microseconds\n##   expr     min      lq      mean   median       uq     max\n##  f1(X)   1.763   6.314  16.86986   7.4210  16.3180 366.745\n##  f2(X)   4.018   7.954  17.31389   8.4870  16.0105 371.952\n##  f3(X)  98.195 102.049 114.02387 105.3495 111.4380 495.813\n##  f4(X) 127.920 133.701 147.54547 136.0790 147.6205 730.948\n##  neval\n##    100\n##    100\n##    100\n##    100\nsummary(mb)[, c(\"expr\", \"median\")]##    expr   median\n## 1 f1(X)   7.4210\n## 2 f2(X)   8.4870\n## 3 f3(X) 105.3495\n## 4 f4(X) 136.0790\ndummy <- capture.output(mbs <- summary(mb))\nsummary(mb)[, c(\"expr\", \"median\")]##    expr   median\n## 1 f1(X)   7.4210\n## 2 f2(X)   8.4870\n## 3 f3(X) 105.3495\n## 4 f4(X) 136.0790\nlibrary(\"ggplot2\")\nautoplot(mb)\nboxplot(mb)"},{"path":"chap-utiliseR.html","id":"profilage","chapter":"2 Utiliser R","heading":"2.3.3 Profilage","text":"profvis est l’outil de profilage de RStudio.Il permet de suivre le temps d’exécution de chaque ligne de code et la mémoire utilisée.\nL’objectif est de détecter les portions de code lentes, à améliorer.Le résultat est un fichier HTML contenant le rapport de profilage24.\npeut observer que le temps de tirage des nombres aléatoires est similaire à celui du calcul des cosinus.Lire la documentation complète25 sur le site de RStudio.","code":"\nlibrary(profvis)\np <- profvis({\n    # Calculs de cosinus\n    cos(runif(10^7))\n    # 1/2 seconde de pause\n    pause(1/2)\n})\nhtmlwidgets::saveWidget(p, \"docs/profile.html\")"},{"path":"chap-utiliseR.html","id":"boucles","chapter":"2 Utiliser R","heading":"2.4 Boucles","text":"Le cas le plus fréquent de code long à exécuter est celui des boucles : le même code est répété un grand nombre de fois.","code":""},{"path":"chap-utiliseR.html","id":"fonctions-vectorielles","chapter":"2 Utiliser R","heading":"2.4.1 Fonctions vectorielles","text":"La plupart des fonctions de R sont vectorielles : les boucles sont traitées de façon interne, extrêmement rapide.\nIl faut donc raisonner en termes de vecteurs plutôt que de scalaires.Il faut aussi écrire des fonctions vectorielles sur leur premier argument.\nLa fonction lnq du package entropart retourne le logarithme déformé d’ordre \\(q\\) d’un nombre \\(x\\).Pour qu’une fonction soit vectorielle, chaque ligne de son code doit permettre que le premier argument soit traité comme un vecteur.\nIci : log(x) et x^ sont une fonction et un opérateur vectoriels et la condition [x < 0] retourne aussi un vecteur.","code":"\n# Tirage de deux vecteurs de trois nombres aléatoires entre\n# 0 et 1\nx1 <- runif(3)\nx2 <- runif(3)\n# Racine carrée des trois nombres de x1\nsqrt(x1)## [1] 0.9427738 0.8665204 0.4586981\n# Sommes respective des trois nombres de x1 et x2\nx1 + x2## [1] 1.6262539 1.6881583 0.9063973\n# Code de la fonction\nentropart::lnq## function (x, q) \n## {\n##     if (q == 1) {\n##         return(log(x))\n##     }\n##     else {\n##         Log <- (x^(1 - q) - 1)/(1 - q)\n##         Log[x < 0] <- NA\n##         return(Log)\n##     }\n## }\n## <bytecode: 0x151577a50>\n## <environment: namespace:entropart>"},{"path":"chap-utiliseR.html","id":"lapply","chapter":"2 Utiliser R","heading":"2.4.2 lapply","text":"Les codes qui ne peuvent pas être écrits comme une fonction vectorielle nécessitent des boucles.lapply() applique une fonction à chaque élément d’une liste.\nElle est déclinée sous plusieurs versions :lapply() renvoie une liste (économise le temps de leur réorganisation dans un tableau) ;sapply() renvoie un dataframe en rassemblant les listes par simplify2array() ;vapply() est presque identique mais demande que le type de données du résultat soit fourni.lapply() est beaucoup plus lent qu’une fonction vectorielle.\nsapply() nécessite plus de temps pour simplify2array(), qui doit détecter comment rassembler les résultats.\nEnfin, vapply() économise le temps de détermination du type de données du résultat et permet d’accélérer le calcul avec peu d’efforts.","code":"\n# Tirage de 1000 valeurs dans une loi uniforme\nx1 <- runif(1000)\n# La racine carrée peut être calculée pour le vecteur ou\n# chaque valeur\nidentical(sqrt(x1), sapply(x1, FUN = sqrt))## [1] TRUE\nmb <- microbenchmark(sqrt(x1), lapply(x1, FUN = sqrt), sapply(x1,\n    FUN = sqrt), vapply(x1, FUN = sqrt, FUN.VALUE = 0))\nsummary(mb)[, c(\"expr\", \"median\")]##                                    expr   median\n## 1                              sqrt(x1)   1.3530\n## 2                lapply(x1, FUN = sqrt) 127.1000\n## 3                sapply(x1, FUN = sqrt) 150.2445\n## 4 vapply(x1, FUN = sqrt, FUN.VALUE = 0) 124.0045"},{"path":"chap-utiliseR.html","id":"boucles-for","chapter":"2 Utiliser R","heading":"2.4.3 Boucles for","text":"Les boucles sont gérées par la fonction .\nElles ont la réputation d’être lentes dans R parce que le code à l’intérieur de la boucle doit être interprété à chaque exécution.\nCe n’est plus le cas depuis la version 3.5 de R : les boucles sont compilées systématiquement avant leur exécution.\nLe comportement du compilateur “juste à temps” est défini par la fonction enableJIT.\nLe niveau par défaut est 3 : les fonctions sont toutes compilées, et les boucles dans le code aussi.Pour évaluer le gain de performance, le code suivant supprime toute compilation automatique, et compare la même boucle compilée ou non.Le gain est considérable : de 1 à 9.Les boucles sont maintenant nettement plus rapides que vapply.Attention, le test de performance peut être trompeur :Dans ce code, la boucle n’est pas compilée donc elle est beaucoup plus lente que dans le cadre normal de son utilisation (dans une fonction ou au niveau supérieur du code).Les boucles longues permettent un suivi de leur progression par une barre de texte, ce qui est un autre avantage.\nLa fonction suivante exécute des pauses d’un dixième de seconde pendant le temps passé en paramètre (en secondes).","code":"\nlibrary(\"compiler\")\n# Pas de compilation automatique\nenableJIT(level = 0)## [1] 3\n# Boucle pour calculer la racine carrée d'un vecteur\nBoucle <- function(x) {\n    # Initialisation du vecteur de résultat, indispensable\n    Racine <- vector(\"numeric\", length = length(x))\n    # Boucle\n    for (i in 1:length(x)) Racine[i] <- sqrt(x[i])\n    return(Racine)\n}\n# Version compilée\nBoucle2 <- cmpfun(Boucle)\n# Comparaison\nmb <- microbenchmark(Boucle(x1), Boucle2(x1))\n(mbs <- summary(mb)[, c(\"expr\", \"median\")])##          expr   median\n## 1  Boucle(x1) 351.1445\n## 2 Boucle2(x1)  39.4625\n# Compilation automatique par défaut depuis la version 3.5\nenableJIT(level = 3)## [1] 0\n# Test\nmb <- microbenchmark(vapply(x1, FUN = sqrt, 0), Boucle(x1))\nsummary(mb)[, c(\"expr\", \"median\")]##                        expr   median\n## 1 vapply(x1, FUN = sqrt, 0) 125.1525\n## 2                Boucle(x1)  39.4420\n# Préparation du vecteur de résultat\nRacine <- vector(\"numeric\", length = length(x1))\n# Test\nmb <- microbenchmark(vapply(x1, FUN = sqrt, 0), \n                     for(i in 1:length(x1)) \n                       Racine[i] <- sqrt(x1[i]))\nsummary(mb)[, c(\"expr\", \"median\")]##                                               expr   median\n## 1                        vapply(x1, FUN = sqrt, 0) 126.5260\n## 2 for (i in 1:length(x1)) Racine[i] <- sqrt(x1[i]) 961.2245\nBoucleSuivie <- function(duree = 1) {\n    # Barre de progression\n    pgb <- txtProgressBar(min = 0, max = duree * 10)\n    # Boucle\n    for (i in 1:(duree * 10)) {\n        # Pause d'un dixième de seconde\n        Sys.sleep(1/10)\n        # Suivi de la progression\n        setTxtProgressBar(pgb, i)\n    }\n}\nBoucleSuivie()## ============================================================"},{"path":"chap-utiliseR.html","id":"replicate","chapter":"2 Utiliser R","heading":"2.4.4 replicate","text":"replicate() répète une instruction.Ce code est équivalent à runif(3), avec des performances similaires à celles de vapply : de 50 à 100 fois plus lent qu’une fonction vectorielle.","code":"\nreplicate(3, runif(1))## [1] 0.9453453 0.5262818 0.7233425\nmb <- microbenchmark(replicate(1000, runif(1)), runif(1000))\nsummary(mb)[, c(\"expr\", \"median\")]##                        expr   median\n## 1 replicate(1000, runif(1)) 659.9565\n## 2               runif(1000)   5.6580"},{"path":"chap-utiliseR.html","id":"vectorize","chapter":"2 Utiliser R","heading":"2.4.5 Vectorize","text":"Vectorize() rend vectorielle une fonction qui ne l’est pas, par des boucles.\nEcrire plutôt les boucles.","code":""},{"path":"chap-utiliseR.html","id":"statistiques-marginales","chapter":"2 Utiliser R","heading":"2.4.6 Statistiques marginales","text":"apply applique une fonction aux lignes ou colonnes d’un objet en deux dimensions.colSums et ses semblables (rowSums, colMeans, rowMeans) sont optimisées.apply clarifie le code mais est plus lent que la boucle, qui est à peine plus lente que colSums.","code":"\n# Somme des colonnes numériques du jeu de données diamonds de ggplot2\n# Boucle identique à l'action de apply(, 2, )\nBoucleSomme <- function(Table) {\n  Somme <- vector(\"numeric\", length = ncol(Table))\n  for (i in 1:ncol(Table)) Somme[i] <- sum(Table[, i])\n  return(Somme)\n}\nmb <- microbenchmark(BoucleSomme(diamonds[-(2:4)]), \n                     apply(diamonds[-(2:4)], 2, sum), \n                     colSums(diamonds[-(2:4)]))\nsummary(mb)[, c(\"expr\", \"median\")]##                              expr   median\n## 1   BoucleSomme(diamonds[-(2:4)]) 1381.290\n## 2 apply(diamonds[-(2:4)], 2, sum) 3102.306\n## 3       colSums(diamonds[-(2:4)]) 1072.970"},{"path":"chap-utiliseR.html","id":"sec:cpp","chapter":"2 Utiliser R","heading":"2.5 Code C++","text":"L’intégration de code C++ dans R est largement simplifiée par le package Rcpp mais reste difficile à déboguer et donc à réserver à du code très simple (pour éviter toute erreur) et répété un grand nombre de fois (pour mériter l’effort).\nLa préparation des données et leur vérification doivent être exécutées sous R, de même que le traitement et la présentation des résultats.L’utilisation habituelle est l’inclusion de code C++ dans un package, mais l’utilisation hors package est possible :Le code C++ peut être inclus dans un document C++ (fichier avec l’extension .cpp) : il est compilé par la commande sourceCpp() qui crée les fonctions R permettant d’appeler le code C++.Dans un document RMarkdown, des bouts de code Rcpp peuvent être créés pour y insérer le code C++ : ils sont compilés et interfacés pour R au moment du tricotage.L’exemple suivant montre comment créer une fonction C++ pour calculer le double d’un vecteur numérique.Une fonction R du même nom que la fonction C++ est maintenant disponible.Les performances sont deux ordres de grandeur plus rapides que le code R (voir l’étude de cas, section 2.7).","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector timesTwo(NumericVector x) {\n  return x * 2;\n}\ntimesTwo(1:5)## [1]  2  4  6  8 10"},{"path":"chap-utiliseR.html","id":"sec:parallel","chapter":"2 Utiliser R","heading":"2.6 Paralléliser R","text":"Lorsque des calculs longs peuvent être découpés en tâches indépendantes, l’exécution simultanée (parallèle) de ces tâches permet de réduire le temps de calcul total à celui de la tâche la plus longue, auquel s’ajoute le coût de la mise en place de la parallélisation (création des tâches, récupération des résultats…).Lire l’excellente introduction de Josh Errickson26 qui détaille les enjeux et les contraintes de la parallélisation.Deux mécanismes sont disponibles pour l’exécution de code en parallèle :fork : le processus en cours d’exécution est dupliqué sur plusieurs cœurs du processeur de l’ordinateur de calcul.\nC’est la méthode la plus simple mais elle ne fonctionne pas sous Windows (limite du système d’exploitation).socket : un cluster est constitué, soit physiquement (un ensemble d’ordinateurs exécutant R est nécessaire) soit logiquement (une instance de R sur chaque cœur de l’ordinateur utilisé).\nLes membres du cluster communiquent par le réseau (le réseau interne de l’ordinateur utilisé pour un cluster logique).Différents packages de R permettent de mettre en œuvre ces mécanismes.","code":""},{"path":"chap-utiliseR.html","id":"mclapply-fork","chapter":"2 Utiliser R","heading":"2.6.1 mclapply (fork)","text":"La fonction mclapply du package parallel la même syntaxe que lapply mais parallélise l’exécution des boucles.\nSous Windows, elle n’aucun effet puisque le système ne permet pas les fork : elle appelle simplement lapply.\nCependant, un contournement existe pour émuler mclapply sous Windows en appelant parLapply, qui utilise un cluster.Le code suivant teste la parallélisation d’une fonction qui renvoie son argument inchangé après une pause d’un quart de seconde.\nCe document est tricoté avec 3 cœurs, qui sont tous utilisés sauf un pour ne pas saturer le système.La mise en place de la parallélisation un coût d’environ 0.15 secondes ici.\nLe temps d’exécution est bien plus long en parallèle sous Windows parce que la mise en place du cluster prend bien plus de temps que la parallélisation n’en fait gagner.\nLa parallélisation est intéressante pour des tâches plus longues, comme une pause d’un seconde.Le temps additionnel nécessaire pour l’exécution parallèle du nouveau code est relativement plus faible : les coûts deviennent inférieurs à l’économie quand le temps de chaque tâche s’allonge.Si le nombre de tâches parallèles dépasse le nombre de cœurs utilisés, les performances s’effondrent parce que la tâche supplémentaire doit être exécutée après les premières.Le temps reste ensuite stable jusqu’au double du nombre de cœurs.\nLa figure 2.2 montre l’évolution du temps de calcul en fonction du nombre de tâches.\nFigure 2.2: Temps d’exécution en parallèle de tâches nécessitant une seconde (chaque tâche est une pause d’une seconde). Le nombre de tâches varie de 1 à deux fois le nombre de cœurs utilisés (égal à 2) plus une.\nLa forme théorique de cette courbe est la suivante :pour une tâche, le temps est égal à une seconde plus le temps de mise en place de la parallélisation ;le temps devrait rester stable jusqu’au nombre de cœurs utilisés ;quand les cœurs sont tous utilisés (pointillés rouges), le temps devrait augmenter d’une seconde puis rester stable jusqu’à la limite suivante.En pratique, le temps de calcul est déterminé par d’autres facteurs difficilement prévisibles.\nLa bonne pratique est d’adapter le nombre de tâches au nombre de cœurs sous peine de perte de performance.","code":"\n##\n## mclapply.hack.R\n##\n## Nathan VanHoudnos\n## nathanvan AT northwestern FULL STOP edu\n## July 14, 2014\n##\n## A script to implement a hackish version of \n## parallel:mclapply() on Windows machines.\n## On Linux or Mac, the script has no effect\n## beyond loading the parallel library. \n\nrequire(parallel)    ## Loading required package: parallel\n## Define the hack\n# mc.cores argument added: Eric Marcon\nmclapply.hack <- function(..., mc.cores=detectCores()) {\n  ## Create a cluster\n  size.of.list <- length(list(...)[[1]])\n  cl <- makeCluster( min(size.of.list, mc.cores) )\n  \n  ## Find out the names of the loaded packages \n  loaded.package.names <- c(\n    ## Base packages\n    sessionInfo()$basePkgs,\n    ## Additional packages\n    names( sessionInfo()$otherPkgs ))\n  \n  tryCatch( {\n    \n    ## Copy over all of the objects within scope to\n    ## all clusters. \n    this.env <- environment()\n    while( identical( this.env, globalenv() ) == FALSE ) {\n      clusterExport(cl,\n                    ls(all.names=TRUE, env=this.env),\n                    envir=this.env)\n      this.env <- parent.env(environment())\n    }\n    clusterExport(cl,\n                  ls(all.names=TRUE, env=globalenv()),\n                  envir=globalenv())\n    \n    ## Load the libraries on all the clusters\n    ## N.B. length(cl) returns the number of clusters\n    parLapply( cl, 1:length(cl), function(xx){\n      lapply(loaded.package.names, function(yy) {\n        require(yy , character.only=TRUE)})\n    })\n    \n    ## Run the lapply in parallel \n    return( parLapply( cl, ...) )\n  }, finally = {        \n    ## Stop the cluster\n    stopCluster(cl)\n  })\n}\n\n## Warn the user if they are using Windows\nif( Sys.info()[['sysname']] == 'Windows' ){\n  message(paste(\n    \"\\n\", \n    \"   *** Microsoft Windows detected ***\\n\",\n    \"   \\n\",\n    \"   For technical reasons, the MS Windows version of mclapply()\\n\",\n    \"   is implemented as a serial function instead of a parallel\\n\",\n    \"   function.\",\n    \"   \\n\\n\",\n    \"   As a quick hack, we replace this serial version of mclapply()\\n\",\n    \"   with a wrapper to parLapply() for this R session. Please see\\n\\n\",\n    \"     http://www.stat.cmu.edu/~nmv/2014/07/14/\n    implementing-mclapply-on-windows \\n\\n\",\n    \"   for details.\\n\\n\"))\n}\n\n## If the OS is Windows, set mclapply to the\n## the hackish version. Otherwise, leave the\n## definition alone. \nmclapply <- switch( Sys.info()[['sysname']],\n                    Windows = {mclapply.hack}, \n                    Linux   = {mclapply},\n                    Darwin  = {mclapply})\n\n## end mclapply.hack.R\nf <- function(x, time = 0.25) {\n    Sys.sleep(time)\n    return(x)\n}\n# Laisser un coeur libre pour le système\nnbCoeurs <- detectCores() - 1\n# Série : temps théorique = nbCoeurs/4 secondes\n(tserie <- system.time(lapply(1:nbCoeurs, f)))##    user  system elapsed \n##   0.006   0.000   0.689\n# Parallèle : temps théorique = 1/4 seconde\n(tparallele <- system.time(mclapply(1:nbCoeurs, f, mc.cores = nbCoeurs)))##    user  system elapsed \n##   0.001   0.019   0.396\n# Série\nsystem.time(lapply(1:nbCoeurs, f, time = 1))##    user  system elapsed \n##   0.000   0.000   2.063\n# Parallèle\nsystem.time(mclapply(1:nbCoeurs, f, time = 1, mc.cores = nbCoeurs))##    user  system elapsed \n##   0.000   0.013   1.141\nsystem.time(mclapply(1:nbCoeurs, f, time = 1, mc.cores = nbCoeurs))##    user  system elapsed \n##   0.002   0.021   1.129\nsystem.time(mclapply(1:(nbCoeurs + 1), f, time = 1, mc.cores = nbCoeurs))##    user  system elapsed \n##   0.002   0.013   2.321\nTaches <- 1:(2 * nbCoeurs+1)\nTemps <- sapply(Taches, function(nbTaches) {\n      system.time(mclapply(1:nbTaches, f, time=1, mc.cores=nbCoeurs))\n              })\nlibrary(\"tidyverse\")\ntibble(Taches, Temps=Temps[\"elapsed\", ]) %>% \n  ggplot +\n  geom_line(aes(x = Taches, y = Temps)) +\n  geom_vline(xintercept = nbCoeurs, col = \"red\", lty = 2) +\n  geom_vline(xintercept = 2 * nbCoeurs, col = \"red\", lty = 2)"},{"path":"chap-utiliseR.html","id":"parlapply-socket","chapter":"2 Utiliser R","heading":"2.6.2 parLapply (socket)","text":"parLapply nécessite de créer un cluster, exporter les variables utiles sur chaque noeud, charger les packages nécessaires sur chaque noeud, exécuter le code et enfin arrêter le cluster.\nLe code de chaque étape se trouve dans la fonction mclapply.hack ci-dessus.Pour un usage courant, mclapply est plus rapide, sauf sous Windows, et plus simple (y compris sous Windows grâce au contournement ci-dessus.)","code":""},{"path":"chap-utiliseR.html","id":"foreach","chapter":"2 Utiliser R","heading":"2.6.3 foreach","text":"","code":""},{"path":"chap-utiliseR.html","id":"fonctionnement","chapter":"2 Utiliser R","heading":"2.6.3.1 Fonctionnement","text":"Le package foreach permet un usage avancé de la parallélisation.\nLire ses vignettes.Indépendamment de la parallélisation, foreach redéfinit les boucles .La fonction foreach retourne une liste contenant les résultats de chaque boucle.\nLes éléments de la liste peuvent être combinés par une fonction quelconque, comme c.La fonction foreach est capable d’utiliser des itérateurs, c’est-à-dire des fonctions qui ne passent à la boucle que les données dont elle besoin sans charger les autres en mémoire.\nIci, l’itérateur icount passe les valeurs 1, 2 et 3 individuellement, sans charger le vecteur 1:3 en mémoire.Elle est donc très utile quand chaque objet de la boucle utilise une grande quantité de mémoire.","code":"\n# Manuel\nvignette(\"foreach\", \"foreach\")\n# Boucles imbriquées\nvignette(\"nested\", \"foreach\")\nfor (i in 1:3) {\n    f(i)\n}\n# devient\nlibrary(\"foreach\")## \n## Attaching package: 'foreach'## The following objects are masked from 'package:purrr':\n## \n##     accumulate, when\nforeach(i = 1:3) %do% {\n    f(i)\n}## [[1]]\n## [1] 1\n## \n## [[2]]\n## [1] 2\n## \n## [[3]]\n## [1] 3\nforeach(i = 1:3, .combine = \"c\") %do% {\n    f(i)\n}## [1] 1 2 3\nlibrary(\"iterators\")\nforeach(i = icount(3), .combine = \"c\") %do% {\n    f(i)\n}## [1] 1 2 3"},{"path":"chap-utiliseR.html","id":"parallélisation","chapter":"2 Utiliser R","heading":"2.6.3.2 Parallélisation","text":"Remplacer l’opérateur %% par %dopar% parallélise les boucles, à condition qu’un adaptateur, c’est-à-dire un package intermédiaire entre foreach et un package chargé de l’implémentation de la parallélisation, soit chargé.\ndoParallel est un adaptateur pour utiliser le package parallel livré avec R.Le coût fixe de la parallélisation est faible.","code":"\nlibrary(doParallel)\nregisterDoParallel(cores = nbCoeurs)\n# Série\nsystem.time(foreach(i = icount(nbCoeurs), .combine = \"c\") %do%\n    {\n        f(i)\n    })##    user  system elapsed \n##   0.004   0.000   0.678\n# Parallèle\nsystem.time(foreach(i = icount(nbCoeurs), .combine = \"c\") %dopar%\n    {\n        f(i)\n    })##    user  system elapsed \n##   0.003   0.018   0.404"},{"path":"chap-utiliseR.html","id":"future","chapter":"2 Utiliser R","heading":"2.6.4 future","text":"Le package future permet d’abstraire le code de l’implémentation de la parallélisation.\nIl est au centre d’un écosystème de packages facilitent son utilisation27.La stratégie de parallélisation utilisée est déclarée par la fonction plan().\nLe stratégie par défaut est sequential, monotâche.\nLes stratégies multicore et multisession reposent respectivement sur les techniques fork et socket vues plus haut.\nD’autres stratégies sont disponibles pour utiliser des clusters physiques (plusieurs ordinateurs préparés pour exécuter R ensemble) : la documentation de future détaille comment le faire.Nous utiliserons ici la stratégie multisession qui fonctionne sur l’ordinateur local, quel que soit sont système d’exploitation.Le package future.apply permet de paralléliser sans effort toutes les boucles *apply() et replicate() en préfixant leur nom par future_.Les boucles foreach peuvent être parallélisées avec le package doFuture en remplaçant simplement %dopar% par %dofuture%.La stratégie est rétablie à sequential à la fin.","code":"\nlibrary(\"future\")\n# Stratégie socket sur tous les coeurs disponibles sauf 1\nusedCores <- availableCores() - 1\nplan(multisession, workers = usedCores)\nlibrary(\"future.apply\")\nsystem.time(future_replicate(usedCores - 1, f(usedCores)))##    user  system elapsed \n##   0.020   0.000   0.388\nlibrary(\"doFuture\")\nsystem.time(foreach(i = icount(nbCoeurs), .combine = \"c\") %dofuture%\n    {\n        f(i)\n    })##    user  system elapsed \n##   0.036   0.001   0.451\nplan(sequential)"},{"path":"chap-utiliseR.html","id":"sec:cas","chapter":"2 Utiliser R","heading":"2.7 Etude de cas","text":"Cette étude de cas permet de tester les différentes techniques vues plus haut pour résoudre un problème concret.\nL’objectif est de calculer la distance moyenne entre deux points d’un semis aléatoire de 1000 points dans une fenêtre carrée de côté 1.Son espérance est calculable28.\nElle est égale à \\(\\frac{2+\\sqrt{2}+5\\ln{(1+\\sqrt{2})}}{15} \\approx 0,5214\\).","code":""},{"path":"chap-utiliseR.html","id":"création-des-données","chapter":"2 Utiliser R","heading":"2.7.1 Création des données","text":"Le semis de points est créé avec le package spatstat.","code":"\nNbPoints <- 1000\nlibrary(\"spatstat\")\nX <- runifpoint(NbPoints)"},{"path":"chap-utiliseR.html","id":"spatstat","chapter":"2 Utiliser R","heading":"2.7.2 Spatstat","text":"La fonction pairdist() de spatstat retourne la matrice des distances entre les points.\nLa distance moyenne est calculée en divisant la somme par le nombre de paires de points distincts.La fonction est rapide parce qu’elle est codée en langage C dans le package spatstat pour le cœur de ses calculs.","code":"\nmb <- microbenchmark(d <- sum(pairdist(X))/NbPoints/(NbPoints -\n    1))\n# suppressMessages pour éliminer les messages superflus\nsuppressMessages(autoplot(mb))\nd## [1] 0.5154879"},{"path":"chap-utiliseR.html","id":"apply","chapter":"2 Utiliser R","heading":"2.7.3 apply","text":"La distance peut être calculée par deux sapply() imbriqués.Un peu de temps peut être gagnée en remplaçant sapply par vapply : le format des résultats n’pas à être déterminé par la fonction.\nLe gain est négligeable sur un long calcul comme celui-ci mais important pour des calculs courts.\nLe format de sortie n’est pas toujours évident à écrire :il doit respecter la taille des données : un vecteur de taille 1000 pour la boucle externe, un scalaire pour la boucle interne.il doit respecter leur type : 0 pour un entier, 0.0 pour un réel. Dans la boucle externe, l’ajout de 0.0 au vecteur d’entiers le transforme en vecteur de réels.Une amélioration plus significative consiste à ne calculer les racines carrées qu’à la fin de la boucle, pour profiter de la vectorisation de la fonction.Les calculs sont effectués deux fois (distance entre les points \\(\\) et \\(j\\), mais aussi entre les points \\(j\\) et \\(\\)) : un test sur les indices permet de diviser presque le temps par 2 (pas tout à fait parce que les boucles sans calcul, qui retournent \\(0\\), prennent du temps).En parallèle, le temps de calcul n’est pas amélioré sous Windows parce que les tâches individuelles sont trop courtes.\nSous MacOS ou Linux, le calcul est accéléré.","code":"\nfsapply1 <- function() {\n    distances <- sapply(1:NbPoints, function(i) sapply(1:NbPoints,\n        function(j) sqrt((X$x[i] - X$x[j])^2 + (X$y[i] - X$y[j])^2)))\n    return(sum(distances)/NbPoints/(NbPoints - 1))\n}\nsystem.time(d <- fsapply1())##    user  system elapsed \n##   2.360   0.009   2.369\nd## [1] 0.5154879\nfsapply2 <- function() {\n    distances <- vapply(1:NbPoints, function(i) vapply(1:NbPoints,\n        function(j) sqrt((X$x[i] - X$x[j])^2 + (X$y[i] - X$y[j])^2),\n        0), 1:1000 + 0)\n    return(sum(distances)/NbPoints/(NbPoints - 1))\n}\nsystem.time(d <- fsapply2())##    user  system elapsed \n##   2.176   0.004   2.180\nd## [1] 0.5154879\nfsapply3 <- function() {\n    distances <- vapply(1:NbPoints, function(i) vapply(1:NbPoints,\n        function(j) (X$x[i] - X$x[j])^2 + (X$y[i] - X$y[j])^2,\n        0), 1:1000 + 0)\n    return(sum(sqrt(distances))/NbPoints/(NbPoints - 1))\n}\nsystem.time(d <- fsapply3())##    user  system elapsed \n##   2.175   0.004   2.179\nd## [1] 0.5154879\nfsapply4 <- function() {\n    distances <- vapply(1:NbPoints, function(i) {\n        vapply(1:NbPoints, function(j) {\n            if (j > i) {\n                (X$x[i] - X$x[j])^2 + (X$y[i] - X$y[j])^2\n            } else {\n                0\n            }\n        }, 0)\n    }, 1:1000 + 0)\n    return(sum(sqrt(distances))/NbPoints/(NbPoints - 1) * 2)\n}\nsystem.time(d <- fsapply4())##    user  system elapsed \n##   1.262   0.003   1.265\nd## [1] 0.5154879\nfsapply5 <- function() {\n    distances <- mclapply(1:NbPoints, function(i) {\n        vapply(1:NbPoints, function(j) {\n            if (j > i) {\n                (X$x[i] - X$x[j])^2 + (X$y[i] - X$y[j])^2\n            } else {\n                0\n            }\n        }, 0)\n    })\n    return(sum(sqrt(simplify2array(distances)))/NbPoints/(NbPoints -\n        1) * 2)\n}\nsystem.time(d <- fsapply5())##    user  system elapsed \n##   1.419   0.503   1.040\nd## [1] 0.5154879"},{"path":"chap-utiliseR.html","id":"future.apply","chapter":"2 Utiliser R","heading":"2.7.4 future.apply","text":"La fonction fsapply4() optimisée plus haut peut être parallélisée directement en préfixant la fonction vapply par future_.\nSeule la boucle principale est parallélisée : l’imbrication de future_vapply() ferait s’écrouler la performance.","code":"\nlibrary(\"future.apply\")\n# Stratégie socket sur tous les coeurs disponibles sauf 1\nplan(multisession, workers = availableCores() - 1)\nfuture_fsapply4_ <- function() {\n    distances <- future_vapply(1:NbPoints, function(i) {\n        vapply(1:NbPoints, function(j) {\n            if (j > i) {\n                (X$x[i] - X$x[j])^2 + (X$y[i] - X$y[j])^2\n            } else {\n                0\n            }\n        }, 0)\n    }, 1:1000 + 0)\n    return(sum(sqrt(distances))/NbPoints/(NbPoints - 1) * 2)\n}\nsystem.time(d <- future_fsapply4_())##    user  system elapsed \n##   0.046   0.006   0.954\nd## [1] 0.5154879\nplan(sequential)"},{"path":"chap-utiliseR.html","id":"boucle-for","chapter":"2 Utiliser R","heading":"2.7.5 boucle for","text":"Une boucle est plus rapide et consomme moins de mémoire parce qu’elle ne stocke pas la matrice de distances.C’est la façon la plus simple et efficace d’écrire ce code sans parallélisation et en se limitant au langage de R.","code":"\ndistance <- 0\nffor <- function() {\n    for (i in 1:(NbPoints - 1)) {\n        for (j in (i + 1):NbPoints) {\n            distance <- distance + sqrt((X$x[i] - X$x[j])^2 +\n                (X$y[i] - X$y[j])^2)\n        }\n    }\n    return(distance/NbPoints/(NbPoints - 1) * 2)\n}\n# Temps de calcul, mémorisé\n(for_time <- system.time(d <- ffor()))##    user  system elapsed \n##   0.786   0.003   0.790\nd## [1] 0.5154879"},{"path":"chap-utiliseR.html","id":"boucle-foreach","chapter":"2 Utiliser R","heading":"2.7.6 boucle foreach","text":"La parallélisation exécute des boucles à l’intérieur d’une boucle foreach, ce qui est assez efficace.\nEn revanche, les distances sont calculées deux fois.Il est possible d’imbriquer deux boucles foreach mais elles sont extrêmement lentes en comparaison d’une boucle simple.\nLe test est lancé ici avec 10 fois moins de points, donc 100 fois moins de distances à calculer.Les boucles foreach imbriquées sont à réserver à des tâches très longues (plusieurs secondes au moins) pour amortir les coûts fixes de leur mise en place.","code":"\nregisterDoParallel(cores = detectCores())\nfforeach3 <- function(Y) {\n  distances <- foreach(\n    i = icount(Y$n), \n    .combine = '+') %dopar% {\n      distance <- 0\n      for (j in 1:Y$n) {\n        distance <- distance + \n          sqrt((Y$x[i] - Y$x[j])^2 + (Y$y[i] - Y$y[j])^2)\n      }\n      distance\n    }\n  return(distances / Y$n / (Y$n - 1))\n}\nsystem.time(d <- fforeach3(X))##    user  system elapsed \n##   1.900   0.149   0.746\nd## [1] 0.5154879\nNbPointsReduit <- 100\nY <- runifpoint(NbPointsReduit)\nfforeach1 <- function(Y) {\n    distances <- foreach(i = 1:Y$n, .combine = \"cbind\") %:% foreach(j = 1:Y$n,\n        .combine = \"c\") %do% {\n        if (j > i) {\n            (Y$x[i] - Y$x[j])^2 + (Y$y[i] - Y$y[j])^2\n        } else {\n            0\n        }\n    }\n    return(sum(sqrt(distances))/Y$n/(Y$n - 1) * 2)\n}\nsystem.time(d <- fforeach1(Y))##    user  system elapsed \n##   0.881   0.007   0.890"},{"path":"chap-utiliseR.html","id":"rcpp","chapter":"2 Utiliser R","heading":"2.7.7 RCpp","text":"La fonction C++ permettant de calculer les distances est la suivante.Elle est appelée dans R très simplement.\nLe temps d’exécution est très court.","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble MeanDistance(NumericVector x, NumericVector y) {\n  double distance=0;\n  double dx, dy;\n  for (int i=0; i < (x.length()-1); i++) {\n    for (int j=i+1; j < x.length(); j++) {\n    // Calcul de la distance\n        dx = x[i]-x[j];\n        dy = y[i]-y[j];\n        distance += sqrt(dx*dx + dy*dy);\n    }\n  }\n  return distance/(double)(x.length()/2*(x.length()-1));\n}\nmb <- microbenchmark(d <- MeanDistance(X$x, X$y))\n# suppressMessages pour éliminer les messages superflus\nsuppressMessages(autoplot(mb))\nd## [1] 0.5154879"},{"path":"chap-utiliseR.html","id":"rcppparallel","chapter":"2 Utiliser R","heading":"2.7.8 RcppParallel","text":"RcppParallel permet d’interfacer du code C++ parallélisé, au prix d’une syntaxe plus complexe qu’avec RCpp.\nUne documentation est disponible29.La fonction C++ exportée dans R ne réalise pas les calculs mais organise seulement l’exécution en parallèle d’une autre fonction, non exportée, de type Worker.Deux fonctions (C++) de parallélisation sont disponibles pour deux types de tâches :parallelReduce pour l’accumulation d’une valeur, utilisée ici pour additionner les distances.parallelFor pour remplir une matrice de résultats.La syntaxe du Worker est un peu laborieuse mais assez simple à adapter : les constructeurs initialisent les variables C à partir des valeurs transmises par R et déclarent la parallélisation.L’usage dans R est identique à celui des fonctions C++ interfacées par RCpp.Le temps de mise en place des tâches parallèles est bien plus long que le temps de calcul en série.En multipliant le nombre de points par 50, le temps de calcul en série doit être multiplié par 2500 environ.En parallèle, le temps augmente peu : la parallélisation devient réellement efficace.\nCe temps est à comparer à celui de la boucle de référence, multiplié par 2500, soit 1974 secondes.","code":"// [[Rcpp::depends(RcppParallel)]]\n#include <Rcpp.h>\n#include <RcppParallel.h>\nusing namespace Rcpp;\nusing namespace RcppParallel;\n\n// Fonction de travail, non exportée\nstruct TotalDistanceWrkr : public Worker\n{\n  // Vecteurs source\n  const RVector<double> Rx;\n  const RVector<double> Ry;\n  \n  // Valeur accumulée\n  double distance;\n   \n  // Constructeurs\n  TotalDistanceWrkr(const NumericVector x, const NumericVector y) :\n    Rx(x), Ry(y), distance(0) {}\n  TotalDistanceWrkr(const TotalDistanceWrkr& totalDistanceWrkr, Split) :\n    Rx(totalDistanceWrkr.Rx), Ry(totalDistanceWrkr.Ry),  distance(0) {}\n  \n  // Comptage des voisins\n  void operator()(std::size_t begin, std::size_t end) {\n    double dx, dy;\n    unsigned int Npoints = Rx.length();\n\n    for (unsigned int i = begin; i < end; i++) {\n      for (unsigned int j=i+1; j < Npoints; j++) {\n          // Calcul de la distance au carré\n          dx = Rx[i]-Rx[j];\n          dy = Ry[i]-Ry[j];\n          distance += sqrt(dx*dx + dy*dy);\n      }\n    }\n  }\n\n  // Ajouter le résultat de cette tâche\n  void join(const TotalDistanceWrkr& rhs) { \n    distance += rhs.distance; \n  }\n};\n\n\n// Fonction exportée\n// [[Rcpp::export]]\ndouble TotalDistance(NumericVector x, NumericVector y) {\n  \n  // Declaration d'une instance de TotalDistanceWrkr\n  TotalDistanceWrkr totalDistanceWrkr(x, y);\n  \n  // Appel de parallel_reduce pour démarrer la tâche\n  parallelReduce(0, x.length(), totalDistanceWrkr);\n  \n  // Retour du résultat\n  return totalDistanceWrkr.distance;\n}\n(mb <- microbenchmark(d <- TotalDistance(X$x, X$y)/NbPoints/(NbPoints -\n    1) * 2))## Unit: microseconds\n##                                                      expr\n##  d <- TotalDistance(X$x, X$y)/NbPoints/(NbPoints - 1) * 2\n##      min     lq     mean  median       uq      max neval\n##  219.186 238.62 276.8759 240.957 248.4395 2642.327   100\n# suppressmessages pour éliminer les messages superflus\nsuppressMessages(autoplot(mb))\nd## [1] 0.5154879\nNbPoints <- 50000\nX <- runifpoint(NbPoints)\nsystem.time(d <- MeanDistance(X$x, X$y))##    user  system elapsed \n##   4.358   0.005   4.364\nsystem.time(d <- TotalDistance(X$x, X$y)/NbPoints/(NbPoints -\n    1) * 2)##    user  system elapsed \n##   1.268   0.002   0.425"},{"path":"chap-utiliseR.html","id":"conclusions-sur-loptimisation-de-la-vitesse-du-code","chapter":"2 Utiliser R","heading":"2.7.9 Conclusions sur l’optimisation de la vitesse du code","text":"De cette étude de cas, plusieurs enseignements peuvent être retirés :une boucle est une bonne base pour des calculs répétitifs, plus rapide que vapply(), simple à lire et à écrire ;les boucles foreach sont extrêmement efficaces pour paralléliser des boucles  ;des fonctions optimisées peuvent exister dans les packages de R pour des tâches courantes (ici, la fonction pairdist() de spatstat est deux ordres de grandeur plus rapide que la boucle ) ;le package future.apply permet de paralléliser très simplement du code déjà écrit avec des fonctions *apply(), indépendamment du matériel utilisé ;le recours au code C++ permet d’accélérer significativement les calculs, de trois ordres de grandeur ici ;la parallélisation du code C++ divise encore le temps de calcul par environ la moitié du nombre de cœurs pour de longs calculs.Au-delà de cet exemple, l’optimisation du temps de calcul sous R peut être compliquée si elle passe par la parallélisation et l’écriture de code C++.\nL’effort doit donc être concentré sur les calculs réellement long alors que la lisibilité du code doit rester la priorité pour le code courant.\nLe code C est assez facile à intégrer grâce à RCpp et sa parallélisation n’est pas très coûteuse avec RCppParallel.L’utilisation de boucles n’est plus pénalisante depuis la version 3.5 de R.\nL’écriture de code vectoriel, utilisant sapply() se justifie toujours pour sa lisibilité.Le choix de paralléliser le code doit être évalué selon le temps d’exécution de chaque tâche parallélisable.\nS’il dépasse quelques secondes, la parallélisation se justifie.","code":""},{"path":"chap-utiliseR.html","id":"sec:targets","chapter":"2 Utiliser R","heading":"2.8 Flux de travail","text":"Le package targets permet de gérer un flux de travail (workflow), c’est-à dire de décomposer le code en tâches élémentaires appelées cibles qui s’enchaînent, dont le résultat est stocké dans une variable, elle-même enregistrée sur le disque.\nEn cas de changement dans le code ou les données utilisées, seules les cibles concernées sont réévaluées.Le fonctionnement du flux est proche de celui d’un cache, mais ne dépend pas de l’ordinateur sur lequel il s’exécute.\ntargets permet de visualiser les tâches obsolètes, d’intégrer le flux à un projet de document (voir section 4.9), et même de faire appel à un cluster de calcul pour traiter les tâches en parallèle.","code":""},{"path":"chap-utiliseR.html","id":"principe-de-fonctionnement","chapter":"2 Utiliser R","heading":"2.8.1 Principe de fonctionnement","text":"La documentation30 de targets est détaillée et fournit un exemple travaillé pour apprendre à utiliser le package31.\nElle n’est pas reprise ici, mais les principes du fonctionnement du flux sont expliqués.Le flux de travail est unique pour un projet donné.\nIl est codé dans le fichier _targets.R à la racine du projet.\nIl contient :des commandes globales, comme le chargement des packages ;une liste de cibles, qui décrivent le code à exécuter et la variable qui stocke leur résultat.Le flux est exécuté par la fonction tar_make() qui met à jour les cibles qui le nécessitent.\nSon contenu est placé dans le dossier _targets.\nLes variables stockées sont lues par tar_read().Si le projet nécessite de longs calculs, targets permet de n’exécuter que ceux qui sont nécessaires.\nSi le projet est partagé ou placé sous contrôle de source (chapitre 3), le résultat des calcul est intégré l’est aussi.\nEnfin, si le projet est un document (chapitre 4), son formatage est complètement indépendant du calcul de son contenu, pour un gain de temps qui peut être considérable.","code":""},{"path":"chap-utiliseR.html","id":"exemple-minimal","chapter":"2 Utiliser R","heading":"2.8.2 Exemple minimal","text":"L’exemple suivant est encore plus simple que celui du manuel de targets, qui permettra d’aller plus loin.\nIl reprend l’étude de cas précédente : un jeu de points est généré puis la distance moyenne entre les points obtenus est calculée.\nUne carte des points est tracée en plus.\nChacune de ces trois opérations est une cible dans le vocabulaire de targets.Le fichier du flux de travail est donc le suivant :Les commandes globales consistent à charger le package targets lui-même puis lister les packages nécessaires au code.\nL’exécution du flux lieu dans une nouvelle instance de R.Les cibles sont ensuite listées.\nChacune est déclarée par la fonction tar_target() dont le premier argument est le nom de la cible, qui sera celui de la variable qui recevra le résultat.\nLe deuxième argument est le code qui produit le résultat.\nLes cibles sont très simples ici et peuvent être écrites en une seule commande.\nQuand ce n’est pas le cas, chaque cible peut être écrite sous la forme d’une fonction, stockée dans un fichier de code séparé chargé par la fonction source() au début du fichier de flux.La commande tar_visnetwork permet d’afficher l’enchaînement des cibles et leur état éventuellement obsolète.L’ordre de déclaration des cibles dans la liste sans importance : elles sont ordonnées automatiquement.Le flux est exécuté par tar_make().Le flux est maintenant à jour et tar_make() ne refait aucun calcul.Les résultats sont lus par tar_read().","code":"\n# Fichier _targets.R \nlibrary(\"targets\")\ntar_option_set(packages = c(\"spatstat\", \"dbmss\"))\nlist(\n  # Tirage des points\n  tar_target(X,\n    runifpoint(NbPoints)\n  ),\n  # Paramétrage\n  tar_target(NbPoints,\n    1000\n  ),\n  # Distance moyenne\n  tar_target(d,\n    sum(pairdist(X)) / NbPoints / (NbPoints - 1)\n  ),\n  # Carte\n  tar_target(map, \n    autoplot(as.wmppp(X))\n  )\n)\nlibrary(\"targets\")\ntar_visnetwork()\ntar_make()## ▶ dispatched target NbPoints\n## ● completed target NbPoints [0.661 seconds, 53 bytes]\n## ▶ dispatched target X\n## ● completed target X [0.001 seconds, 11.058 kilobytes]\n## ▶ dispatched target d\n## ● completed target d [0.008 seconds, 55 bytes]\n## ▶ dispatched target map\n## ● completed target map [0.016 seconds, 187.39 kilobytes]\n## ▶ ended pipeline [0.773 seconds]\ntar_visnetwork()\ntar_make()## ✔ skipped target NbPoints\n## ✔ skipped target X\n## ✔ skipped target d\n## ✔ skipped target map\n## ✔ skipped pipeline [0.042 seconds]\ntar_read(d)## [1] 0.5165293\ntar_read(map)"},{"path":"chap-utiliseR.html","id":"intérêt-pratique","chapter":"2 Utiliser R","heading":"2.8.3 Intérêt pratique","text":"Dans cet exemple, targets complique l’écriture du code et tar_make() est beaucoup plus lent que la simple exécution du code qu’il traite parce qu’il doit vérifier si les cibles sont à jour.\nDans un projet réel qui nécessite de longs calculs, le traitement du statut des cibles est négligeable et le gain de temps apporté par la seule évaluation des cibles nécessaires est considérable.\nLa définition des cibles reste une contrainte, mais force à bien structurer son projet.","code":""},{"path":"chap-git.html","id":"chap-git","chapter":"3 Git et GitHub","heading":"3 Git et GitHub","text":"Le contrôle de source consiste à enregistrer l’ensemble des modifications apportées sur les fichiers suivis.\nLes avantages sont nombreux : traçabilité et sécurité du projet, possibilité de collaborer efficacement, de revenir en arrière, de tenter de nouveaux développements sans mettre en péril la version stable…","code":""},{"path":"chap-git.html","id":"sec:principes-git","chapter":"3 Git et GitHub","heading":"3.1 Principes","text":"","code":""},{"path":"chap-git.html","id":"sec:git-cds","chapter":"3 Git et GitHub","heading":"3.1.1 Contrôle de source","text":"L’outil standard est aujourd’hui git.Les commandes de git peuvent être exécutées dans le terminal de RStudio.\nFigure 3.1: Capture d’écran du terminal de RStudio. La commande git status supposée décrire l’état du dépôt renvoie une erreur si le projet R n’est pas sous contrôle de source.\nLa commande git status (figure 3.1) retourne l’état du dépôt (repository), c’est-à-dire l’ensemble des données gérées par git pour suivre le projet en cours.RStudio intègre une interface graphique pour git suffisante pour se passer de la ligne de commande dans le cadre d’une utilisation standard, présentée ici.","code":""},{"path":"chap-git.html","id":"git-et-github-1","chapter":"3 Git et GitHub","heading":"3.1.2 git et GitHub","text":"git est le logiciel installé sur le poste de travail.GitHub est une plateforme, accessible par le web32, qui permet de partager le contenu des dépôts git (pour travailler à plusieurs) et de partager de la documentation sous la forme d’un site web (GitHub Pages).Comme GitHub permet au minimum la sauvegarde des dépôts git, les deux sont toujours utilisés ensemble.\nGitHub n’est pas la seule plateforme utilisable mais la principale.\nLes alternatives sont Bitbucket33 et GitLab34 par exemple.","code":""},{"path":"chap-git.html","id":"sec:creerdepot","chapter":"3 Git et GitHub","heading":"3.2 Créer un nouveau dépôt","text":"","code":""},{"path":"chap-git.html","id":"a-partir-dun-projet-existant","chapter":"3 Git et GitHub","heading":"3.2.1 A partir d’un projet existant","text":"Dans un projet R existant, activer le contrôle de source dans les options du projet (figure 3.2).\nLa commande exécutée est git init.\nRedémarrer RStudio à la demande.\nFigure 3.2: Activation du contrôle de source dans le menu “Tools > Project Options…”.\nUne nouvelle fenêtre Git apparaît dans le panneau supérieur droit.\nElle contient la liste des fichiers du projet (figure 3.3).\nFigure 3.3: Fichiers du projet, pas encore pris en compte par git.\nce stade, les fichiers ne sont pas pris en compte par git : leur statut est un double point d’interrogation jaune.\nPour git, le répertoire de travail local est un bac à sable où toutes les modifications sont possibles sans conséquences.Le fichier .gitignore contient la liste des fichiers qui n’ont jamais vocation à être pris en compte, qu’il est donc inutile d’afficher dans la liste : les fichiers intermédiaires produits automatiquement par exemple.\nLa syntaxe des fichiers .gitignore est détaillée dans la documentation de git35.\nEn règle générale, utiliser un fichier existant : les modèles de documents notamment incluent leur fichier .gitignore.","code":""},{"path":"chap-git.html","id":"prendre-en-compte-des-fichiers","chapter":"3 Git et GitHub","heading":"3.2.2 Prendre en compte des fichiers","text":"Dans la fenêtre git, cocher la case Staged permet de prendre en compte (Stage) chaque fichier.\nLa commande exécutée est git add <NomDeFichier>.\nLes fichiers pris en compte une première fois ont le statut “” pour “Added”.Les fichiers pris en compte font partie de l’index de git.","code":""},{"path":"chap-git.html","id":"valider-des-modifications","chapter":"3 Git et GitHub","heading":"3.2.3 Valider des modifications","text":"\nFigure 3.4: Fenêtre de validation des modifications prises en compte.\nLes fichiers pris en compte peuvent être validés (Commit) en cliquant sur le bouton “Commit” dans la fenêtre Git.\nUne nouvelle fenêtre s’ouvre (figure 3.4), qui permet de visualiser toutes les modifications par fichier (ajouts en verts, suppressions en rouge).\nLe grain de modification traité par git est la ligne de texte, terminée par un retour à la ligne.\nLes fichiers binaires comme les images sont traités en bloc.Chaque validation (Commit) est accompagnée d’un texte de description.\nLa première ligne est la description courte.\nUne description détaillée peut être ajoutée après un saut de ligne.\nPour la lisibilité de l’historique du projet, chaque commit correspond donc à une action, correspondant à la description courte : tous les fichiers modifiés ne sont pas forcément pris en compte et validés en une fois.\nLa commande exécutée est git commit -m \"Message de validation\".\nFigure 3.5: Fenêtre de demande d’identification.\nLes validations sont liées à leur auteur, qui doit être identifié par git.\nEn règle générale, git utilise les informations du système.\nS’il n’y parvient pas, une fenêtre demande à l’utilisateur de s’identifier avant d’effectuer son premier commit (figure 3.5).\nLes commandes indiquées sont à exécuter dans le terminal de RStudio.\nElles peuvent aussi être utilisées pour vérifier les valeurs connues par git :Dès la première validation, la branche principale du dépôt, appelée “master”, est créée.\nUne branche est une version du dépôt, avec son propre historique et donc ses propres fichiers.\nLes branches permettent :de développer de nouvelles fonctionnalités dans un projet, sans perturber la branche principale qui peut contenir une version stable.\nSi le développement est retenu, sa branche pourra être fusionnée avec la branche master pour constituer une nouvelle version stable.de contenir des fichiers totalement différents de ceux de la branche principale, pour d’autres objectifs.\nSur GitHub, les pages web de présentation du projet peuvent être placés dans une branche appelée “gh-pages” qui ne sera jamais fusionnée.Le dépôt git est complètement constitué.\nDans le vocabulaire de git, il comprend trois arbres (figure 3.6) :le répertoire de travail, ou bac à sable, qui contient les fichiers non pris en compte : inconnus, modifiés, supprimés ou renommés (case Staged décochée) ;l’index, qui contient les fichiers pris en compte (case Staged cochée) ;la tête, qui contient les fichiers validés.\nFigure 3.6: Les trois arbres de git. Source : https://rogerdudler.github.io/git-guide/index.fr.html\nLe statut des fichiers est représenté par deux icônes dans la fenêtre Git de RStudio : deux points d’interrogation quand ils n’ont pas été pris en compte par git.\nEnsuite, l’icône de droite décrit la différence entre le le répertoire de travail et l’index.\nCelle de gauche décrit la différence entre l’index et la tête.\nUn fichier modifié aura donc l’icône M affichée à droite avant d’être pris en compte, puis à gauche après prise en compte.\nIl est possible, même s’il vaut mieux l’éviter, de modifier à nouveau un fichier pris en compte avant qu’il soit validé : alors, les deux icônes seront affichées.","code":"git config user.name\ngit config user.email"},{"path":"chap-git.html","id":"créer-un-dépôt-vide-sur-github","chapter":"3 Git et GitHub","heading":"3.2.4 Créer un dépôt vide sur GitHub","text":"\nFigure 3.7: Création d’un dépôt sur GitHub.\nUn dépôt vide sur GitHub doit être créé (figure 3.7) :sur GitHub, cliquer sur le bouton vert “New repository” ;saisir le nom du dépôt, identique à celui du projet R local ;ajouter une description, qui apparaîtra uniquement sur la page GitHub du dépôt ;choisir le statut du dépôt :\npublic : visible par tout le monde ;\nprivé : visible seulement par les collaborateurs du projet, ce qui exclut de compléter par des pages web de présentation.\npublic : visible par tout le monde ;privé : visible seulement par les collaborateurs du projet, ce qui exclut de compléter par des pages web de présentation.ne pas ajouter de README, .gitignore ou licence : le projet doit être vide ;cliquer sur “create Repository” ;copier l’adresse du dépôt (https://github.com/… ou git@github.com:…).Le choix de l’adresse est lié à la méthode d’authentification.\nL’authentification SSH (voir section 1.4.3) est à privilégier.","code":""},{"path":"chap-git.html","id":"lier-git-et-github","chapter":"3 Git et GitHub","heading":"3.2.5 Lier git et GitHub","text":"Dans RStudio, un premier commit doit au moins avoir eu lieu pour que la branche principale du projet, nommée “master”, existe.\nEn haut à droite de la fenêtre Git (figure 3.3), il est affiché “(branch)” avant cela.\nEnsuite, il est affiché “master”, le nom par défaut de la branche principale du projet.\nLe projet peut alors être lié au dépôt GitHub.","code":""},{"path":"chap-git.html","id":"méthode-graphique","chapter":"3 Git et GitHub","heading":"3.2.5.1 Méthode graphique","text":"Cliquer sur le bouton violet à côté de “master” : une fenêtre apparaît (habituellement utilisée pour la création d’une nouvelle branche, voir section 3.4).\nSaisir le nom de la branche “master”, cliquer sur “Add Remotes” et compléter :Remote Name : origin ;Remote URL : coller l’adresse du dépôt GitHub ;Cliquer sur “Add”.Cocher la case “Sync Remote”.Au message indiquant qu’une branche master existe déjà, cliquer sur “Overwrite”.","code":""},{"path":"chap-git.html","id":"en-ligne-de-commande","chapter":"3 Git et GitHub","heading":"3.2.5.2 En ligne de commande","text":"Plutôt que la manipulation précédente, le lien entre Git et GitHub peut être mis en place par quelques commandes de git exécutées dans le terminal de RStudio.\nElles sont affichées sur la page d’accueil de tout dépôt vide nouvellement créé sur GitHub et peuvent donc être copiées et collées directement vers le terminal.La première commande déclare le dépôt GitHub comme dépôt distant.\nLe nom origin est une convention de git.\nIl peut être modifié mais l’organisation du projet sera plus lisible en respectant la convention.\nL’adresse du dépôt est https://github.com/GitHubID/NomDuDepot.git si l’authentification HTTPS est choisie.Les commandes suivantes activent la branche principale du projet et poussent son contenu vers GitHub.Attention au nom de la branche principale (voir section 3.4) : par défaut, elle s’appelle “master” dans un projet créé dans RStudio mais “main” sur GitHub.\nLes lignes de commande ci-dessus fournies par GitHub remplacent donc master par main et doivent être corrigées pour correspondre au nom de la branche créée par RStudio.","code":"git remote add origin git@github.com:GitHubID/NomDuDepot.git\ngit branch -M master\ngit push -u origin master"},{"path":"chap-git.html","id":"authentification","chapter":"3 Git et GitHub","heading":"3.2.5.3 Authentification","text":"Si l’authentification HTTPS est choisie, à la première connexion de RStudio à GitHub, une fenêtre permet de saisir ses identifiants GitHub (figure 3.8).\nFigure 3.8: Identification HTTPS sur GitHub.\nDepuis août 2021, GitHub n’accepte plus le mot de passe du compte de l’utilisateur pour cette authentification : le jeton personnel (PAT) créé en section 1.4.4 doit être saisi à sa place.Si l’authentification SSH est choisie et été configurée à l’installation de git (section 1.4.3), aucune action n’est nécessaire.","code":""},{"path":"chap-git.html","id":"pousser-les-premières-modifications","chapter":"3 Git et GitHub","heading":"3.2.6 Pousser les premières modifications","text":"La manipulation précédente automatiquement poussé (Push) les modifications validées sur GitHub.\nPar la suite, il faudra cliquer sur le bouton “Push” de la fenêtre Git pour le faire.Sur GitHub, les fichiers résultant des modifications enregistrées par git sont maintenant visibles.Chaque commit réalisé localement est compté par git et un message “branch ahead ‘origin/master’ n commits” affiché dans en haut de la fenêtre Git indique qu’il est temps de mettre à jour GitHub en poussant l’ensemble de ces commits.\nCliquer sur le bouton “Push” pour le faire.ce stade, le projet doit disposer d’un fichier README.md qui présente son contenu sur GitHub.\nSon contenu minimal est un titre et quelques lignes de description :Il est conseillé d’utiliser des badges36, à placer juste après le titre, pour déclarer l’état de maturité du projet, par exemple :","code":"# Nom du Projet\n\nDescription en quelques lignes.\n![stability-wip](https://img.shields.io/badge/|>\nstability-work_in_progress-lightgrey.svg)"},{"path":"chap-git.html","id":"cloner-un-dépôt-de-github","chapter":"3 Git et GitHub","heading":"3.2.7 Cloner un dépôt de GitHub","text":"\nFigure 3.9: Clonage d’un dépôt à partir de GitHub.\nTout dépôt sur GitHub peut être installé (dit cloné) sur le poste de travail en copiant son adresse qui apparaît en cliquant sur le bouton vert (figure 3.9).Dans RStudio, créer un nouveau projet et, dans l’assistant, choisir “Version Control”, “Git” et coller l’adresse dans le champ “Repository URL”.\nLe nom répertoire à créer pour le projet est déduit automatiquement de l’adresse.\nChoisir le répertoire dans lequel celui du projet va être créé et cliquer sur “Create Project”.\nLe projet créé est lié au dépôt distant sur GitHub.Pour travailler à plusieurs sur le même projet, le propriétaire du projet doit donner l’accès au projet à des collaborateurs (figure 3.10), c’est-à-dire d’autres utilisateurs GitHub dans les réglages du dépôt (Settings).\nFigure 3.10: Attribution des droits d’accès sur GitHub.\nLes collaborateurs sont invités par un message envoyé par GitHub.","code":""},{"path":"chap-git.html","id":"usage-courant","chapter":"3 Git et GitHub","heading":"3.3 Usage courant","text":"","code":""},{"path":"chap-git.html","id":"tirer-modifier-valider-pousser","chapter":"3 Git et GitHub","heading":"3.3.1 Tirer, modifier, valider, pousser","text":"Toute séance de travail sur un projet commence en tirant (Bouton “Pull”) de la fenêtre Git pour intégrer au dépôt local les mises à jour effectuées sur GitHub par d’autres collaborateurs.Les modifications apportées aux fichiers du projet sont ensuite prises en compte (cocher les cases Staged) et validées (Commit) avec un message explicatif.\nUne bonne pratique consiste à valider les modifications à chaque fois qu’une tâche élémentaire, qui peut être décrite dans le message explicatif, est terminée plutôt que d’effectuer des commits regroupant de nombreux changements avec une description vague.Dès que possible, pousser (Push) les mises à jour pour qu’elles soient visibles par les collaborateurs.","code":""},{"path":"chap-git.html","id":"régler-les-conflits","chapter":"3 Git et GitHub","heading":"3.3.2 Régler les conflits","text":"Il n’est pas possible de pousser les modifications validées si un collaborateur modifié le dépôt distant sur GitHub.\nIl faut alors les tirer pour les intégrer au dépôt local avant de pousser les modifications fusionnées.Un conflit lieu si un Pull importe dans le fichier local une modification qui ne peut pas être fusionnée automatiquement parce qu’une modification contradictoire eu lieu localement.\nGit considère chaque ligne comme un élément indivisible : la modification de la même ligne sur le dépôt distant et le dépôt local génère donc un conflit.Git insère dans le fichier contenant un conflit les deux versions avec une présentation particulière :Les lignes de formatage contenant les <<<<, les ==== et les >>>> doivent être supprimés et une seule version des lignes problématiques conservée, qui peut être différente des deux versions originales.\nLa résolution du conflit doit être prise en compte et validée.Pour limiter les conflits dans un document contenant du texte (typiquement, un document R Markdown), une bonne pratique consiste à traiter chaque phrase comme une ligne, terminée par un retour à la ligne qui ne sera pas visible dans le document mis en forme : un saut de ligne est nécessaire pour séparer les paragraphes.","code":"<<<<<<<<< HEAD # Version importée du conflit\nLignes en conflit, version importée\n========= # limite entre les deux versions\nLignes en conflit, version locale\n>>>>>>>>> # Fin du conflit"},{"path":"chap-git.html","id":"voir-les-différences","chapter":"3 Git et GitHub","heading":"3.3.3 Voir les différences","text":"Dans la fenêtre Git de RStudio, le menu contextuel (affiché par un clic droit) “Diff” peut être utilisé pour afficher les modifications apportées à chaque fichier (figure 3.11).\nFigure 3.11: Différences entre le répertoire de travail et la tête.\n","code":""},{"path":"chap-git.html","id":"revenir-en-arrière","chapter":"3 Git et GitHub","heading":"3.3.4 Revenir en arrière","text":"Le menu contextuel “Revert” permet d’annuler toutes les modifications apportées à un fichier (affichées par Diff) et de rétablir son contenu validé la dernière fois (son état dans la tête).Il n’est pas simple de revenir en arrière au-delà de la dernière validation parce que les modifications ont pu être prises en compte par des collaborateurs : leur suppression rendrait le projet incohérent.","code":""},{"path":"chap-git.html","id":"voir-lhistorique","chapter":"3 Git et GitHub","heading":"3.3.5 Voir l’historique","text":"Le bouton en forme d’horloge de la fenêtre Git de RStudio affiche l’historique du projet (figure 3.12).\nFigure 3.12: Historique des validations dans le dépôt.\nEn haut se trouve la tête, puis toutes les validations (commits) qui l’ont constituée.\nPour chaque validation, les différences de chaque fichier peuvent être affichées en cliquant sur le nom du fichier dans la partie basse de la fenêtre.","code":""},{"path":"chap-git.html","id":"sec:branches","chapter":"3 Git et GitHub","heading":"3.4 Branches","text":"Les branches d’un projet sont des versions différentes mais simultanées.\nUn usage typique est le développement d’une nouvelle fonctionnalité.\nSi son écriture prend du temps, le projet est perturbé par le chantier en cours : le code peut ne plus fonctionner.\nSi le développement s’avère impossible ou inutile, il faut pouvoir l’abandonner sans dommage.\nPour l’isoler pendant sa réalisation et se permettre de le valider ou de l’abandonner à la fin, il faut le placer dans une branche.La branche principale du projet s’appelle “master” ou “main” à partir de novembre 202037.\nElle doit toujours être dans un état stable : c’est elle qui est clonée à partir de GitHub par d’autres utilisateurs éventuels.Le changement de convention pour le nom de la branche “master” fait qu’à partir de novembre 2020, les projets créés sur GitHub clonés dans RStudio ont pour branche principale “main” alors que les projets créés sur RStudio puis liés à GitHub conservent le nom “master”.","code":""},{"path":"chap-git.html","id":"créer-une-nouvelle-branche","chapter":"3 Git et GitHub","heading":"3.4.1 Créer une nouvelle branche","text":"Cliquer sur le bouton violet “New Branch” dans la fenêtre git de RStudio.\nSaisir son nom et cliquer sur “Create”.La nouvelle branche est maintenant active.Les commandes git peuvent aussi être exécutées dans le terminal (pour créer la branche et l’activer) :","code":"git branch new_branch\ngit checkout new_branch"},{"path":"chap-git.html","id":"changer-de-branche","chapter":"3 Git et GitHub","heading":"3.4.2 Changer de branche","text":"Sélectionner la branche à activer dans la liste des branches locales de la la fenêtre git.Les commits s’appliquent à la branche active.\nChaque branche se comporte comme une version différente du projet.Attention : pour éviter la confusion, sauvegarder les modifications, prendre en compte et valider les changements avant de changer de branche.","code":""},{"path":"chap-git.html","id":"pousser-la-nouvelle-branche","chapter":"3 Git et GitHub","heading":"3.4.3 Pousser la nouvelle branche","text":"Les premières modifications de la nouvelle branche doivent être poussées en ligne de commande parce que les boutons “Push” et “Pull” de la fenêtre Git ne fonctionnent pas tant que la branche n’existe pas sur le dépôt distant.Exécuter, dans le terminal :","code":"git push -u origin new_branch"},{"path":"chap-git.html","id":"comportement-du-système-de-fichier","chapter":"3 Git et GitHub","heading":"3.4.4 Comportement du système de fichier","text":"chaque changement de branche, git réécrit les fichiers du projet pour qu’ils reflètent l’état de la branche.\nLes changements peuvent être observés hors de RStudio, dans l’explorateur de fichier par exemple.Les fichiers ignorés par .gitignore ne sont pas modifiés.\nIl est donc indispensable que les fichiers .gitignore des différentes branches soit identiques, sinon des fichiers ignorés dans une branche apparaîtront comme ajoutés dans la branche affichée après un changement.Les branches de développement ont un contenu proche de celui de la branche principale.\nCe n’est pas le cas de branches spécialisées vues plus loin, comme gh-pages (voir section 3.7) qui contient le site web de présentation du dépôt.\nIl est préférable de ne pas tenter d’afficher ces branches dans RStudio : leur contenu est produit automatiquement et ne doit pas être modifié manuellement.\nSi c’est indispensable, il faudra y copier le fichier .gitignore de la branche principale et garder à l’esprit que les fichiers ignorés appartiennent en réalité à une autre branche que celle affichée.","code":""},{"path":"chap-git.html","id":"fusionner-avec-merge","chapter":"3 Git et GitHub","heading":"3.4.5 Fusionner avec merge","text":"La fusion d’une branche de développement avec la branche principale marque l’atteinte de son objectif : son code va être intégré au projet.\nL’interface graphique de RStudio ne prévoit pas les fusions, il faut donc utiliser le terminal : tout d’abord, se placer dans la branche cible (possible avec l’interface graphique) :Ensuite, fusionner :Dans la majorité des situations, la fusion sera automatique (“Fast Forward”).\nIl est possible que des conflits apparaissent : utiliser la commande git status pour afficher la liste des fichiers concernés, les ouvrir, régler le confit et effectuer un commit.La branche fusionnée n’est pas supprimée : elles peut être utilisée à nouveau pour d’autres développements ou supprimée manuellement avec la commande suivante :","code":"git checkout mastergit merge new_branchgit branch -d new_branch"},{"path":"chap-git.html","id":"fusionner-avec-une-requête-de-tirage","chapter":"3 Git et GitHub","heading":"3.4.6 Fusionner avec une requête de tirage","text":"L’autre façon de fusionner est plus formelle mais aussi plus générale : elle permet de fusionner une branche dans un dépôt d’un autre utilisateur pour y contribuer, ou de faire valider sa branche par un autre membre de l’équipe dans un projet collaboratif.Pour contribuer au projet d’un autre utilisateur de GitHub38, il faut commencer par en créer un fork, c’est-à-dire une copie sous la forme d’un dépôt lié à l’original.\nIl sera possible de tirer les modifications de l’original pour rester à jour39 (par opposition à une simple copie instantanée possible en téléchargeant un Zip du projet) et, à la fin du développement, de fusionner le fork au dépôt original (par opposition à un clone qui ne permettrait pas de contribuer par la suite).Ensuite, il faut créer une branche de développement comme précédemment, la modifier et finalement demander au propriétaire du dépôt de la fusionner.\nCe processus est décrit en détail dans la documentation de git .Dans le cadre plus simple d’une branche de son propre projet comme dans le cas d’un fork, la branche de développement est prête à être fusionnée.\nElle doit avoir être poussée sur GitHub.\nSur la page GitHub du projet, un bouton “Create Pull Request” permet de demander la fusion.\nUn message décrivant les modifications proposées avec leur argumentaire doit être ajouté.Le propriétaire du projet (les membres de l’équipe dans le cadre d’un projet collaboratif, ou soi-même si l’équipe se réduit à une personne) est averti de la requête de tirage.\nSur la page du projet original, il est possible de voir le message, la liste des modifications (chronologie des commits ou comparaison des fichiers), d’engager un discussion avec l’auteur de la requête…\nSi la requête n’est pas retenue, elle peut être fermée.\nSi elle est validée, le bouton “Merge Pull Request” permet de fusionner la branche de développement avec la branche “master” (ou une autre) du projet source.Les requêtes de tirage sont le seul moyen de contribuer à un dépôt sur lequel ne dispose pas de droits d’écriture.\nC’est aussi le moyen de fusionner une branche de développement dans sont propre projet en en gardant une trace explicite (dans la rubrique Pull requests de la page GitHub du projet).\nDans le cadre d’un projet collaboratif, les propositions d’un membre (auteur de la requête) peuvent être validées par un autre (qui accepte la fusion).","code":""},{"path":"chap-git.html","id":"usage-avancé","chapter":"3 Git et GitHub","heading":"3.5 Usage avancé","text":"","code":""},{"path":"chap-git.html","id":"commandes-de-git","chapter":"3 Git et GitHub","heading":"3.5.1 Commandes de git","text":"Au-delà de l’usage courant permis par l’interface graphique de RStudio, des manipulations avancées des projets sont permises en utilisant git en ligne de commande.\nQuelques exemples utiles sont présentés ici.Un petit guide des commandes est proposé par Roger Dudler40.\nIl résume les commandes essentielles, donc intégrées à l’interface graphique de RStudio.\nDes liens vers des références plus complètes sont donnés en bas de la page.","code":""},{"path":"chap-git.html","id":"taille-dun-dépôt","chapter":"3 Git et GitHub","heading":"3.5.2 Taille d’un dépôt","text":"Pour connaître l’espace disque occupé par un dépôt, utiliser la commande git count-objects -vH41.Les données pour ce document au stade de la rédaction sont présentées à titre d’exemple.La taille totale est sur la ligne size.\nLes packs sont une méthode utilisée par git pour réduire la taille du dépôt : des fichiers similaires sont stockés sous la forme d’une partie commune et de différences.\nLa ligne prune-packable donne la taille d’objets stockés à la fois sous forme individuelle et dans des packs.\nSi leur taille est importante, exécuter git prune-packed pour la ramener à zéro.La ligne size-garbage donne la taille des objets qui peuvent être supprimés.\ngit gc les supprime, mais pas seulement : il optimise le stockage.Ici, la majorité des objets du dépôt été placée dans un pack (mais sa taille est supérieure à celle des objets individuels).Il est généralement inutile d’effectuer la collecte des déchets manuellement : git gère bien l’organisation de ses dépôts.GitHub limite la taille des dépôts.\nEn mai 2020, la limite est de 100 Go.\nLa taille de tous les dépôts d’un utilisateur authentifié peut être affichée dans les réglages de son compte (“Personal Settings”, “Repositories”)42.","code":"$ git count-objects -v\ncount: 200\nsize: 2.66 MiB\nin-pack: 0\npacks: 0\nsize-pack: 0\nprune-packable: 0\ngarbage: 0\nsize-garbage: 0$ git gc\nEnumerating objects: 194, done.\nCounting objects: 100% (194/194), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (188/188), done.\nWriting objects: 100% (194/194), done.\nTotal 194 (delta 83), reused 0 (delta 0)\n\n$ git count-objects -vH\ncount: 1\nsize: 5.72 KiB\nin-pack: 194\npacks: 1\nsize-pack: 4.00 MiB\nprune-packable: 0\ngarbage: 0\nsize-garbage: 0 bytes"},{"path":"chap-git.html","id":"supprimer-un-dossier","chapter":"3 Git et GitHub","heading":"3.5.3 Supprimer un dossier","text":"Toutes les modifications apportées à un dépôt sont stockées dans son historique.\nIl peut être utile d’en supprimer dans quelques cas particuliers :si un fichier contenant des informations confidentielles été validé par mégarde.\nLa validation de sa suppression ne le retire pas de l’historique, et les informations confidentielles restent visibles en consultant l’historique.si des fichiers volumineux ne sont plus nécessaires, par exemple des fichiers PDF produits par R Markdown (chapitre 4), binaires (donc inadaptés à git) et reproductibles à partir du code.Typiquement, le dossier docs est utilisé pour stocker les documents produits à partir de code R Markdown.\nLes fichiers HTML et PDF doivent s’y trouver pour constituer les pages GitHub du projet.\nChaque modification du dépôt génère une nouvelle version de ces fichiers dont le volume de l’historique devient rapidement considérable.\nUne solution efficace consiste à déléguer la création de ces fichiers à un système d’intégration continue (chapitre 6) et à retirer le dossier docs de la branche principale (master) du dépôt.\nIl faut alors supprimer tout son historique pour récupérer la place qu’il occupe, qui peut être l’essentiel de la taille du dépôt.Les commandes de suppression complète d’un dossier d’un dépôt son présentées ici43.\nLe dépôt doit être propre, c’est-à-dire sans modifications non validées, et les versions distantes et locales synchronisées.Les trois commandes suivantes suppriment complètement le dossier docs de l’historique du dépôt git :Le dossier n’est pas supprimé du répertoire de travail.\nIl doit donc être ajouté au fichier .gitignore pour ne plus être suivi.\nLa modification de .gitignore doit être validée.\nCes opérations peuvent être réalisées avec l’interface de RStudio ou en ligne de commande :Le nettoyage du dépôt est nécessaire pour supprimer physiquement les données retirées :Enfin, le dépôt doit être poussé.\nL’option --force implique le remplacement du contenu du dépôt distant par celui du dépôt local : toutes les modifications faites par des collaborateurs sont effacées, c’est pourquoi cette opération de nettoyage implique l’arrêt complet du projet pendant qu’elle lieu.Ce code peut être utilisé pour supprimer totalement n’importe quel fichier ou dossier d’un dépôt en remplaçant simplement docs dans la commande git filter-branch initiale.\nLa réduction de la taille du dépôt peut être suivie en utilisant git count-objects -vH avant l’opération, avant git gc (la taille du dépôt reste stable mais été déplacée vers garbage) et à la fin (la taille du dépôt est sensiblement réduite).","code":"git filter-branch --tree-filter \"rm -rf docs\" |>\n    --prune-empty HEAD\ngit for-each-ref --format=\"%(refname)\" refs/original/ |>\n    | xargs -n 1 git update-ref -decho docs/ >> .gitignore\ngit add .gitignore\ngit commit -m 'Removing docs folder from git history'git gcgit push origin master --force"},{"path":"chap-git.html","id":"revenir-en-arrière-1","chapter":"3 Git et GitHub","heading":"3.5.4 Revenir en arrière","text":"Il est possible de restaurer un dépôt dans un état précédent en plaçant sa tête (figure 3.6) au niveau d’un ancien commit.\nToutes les modifications ultérieures sont alors détruites.\nCette opération ne doit pas être réalisée sur un dépôt partagé : les autres utilisateurs ne pourraient plus pousser leurs modifications.Afficher l’historique du dépôt et rechercher l’identifiant (SHA) du dernier commit à conserver.\nDans le terminal de RStudio, exécuter :Tout l’historique du dépôt après le point de restauration choisi est perdu.Une méthode moins radicale et utilisable sur un dépôt partagé consiste à exécuter un commit qui annule les modifications d’un autre mais ne détruit aucune donnée de l’historique.\nCette opération n’annule qu’un seul commit à la fois et doit donc être répétée pour en annuler plusieurs, en commençant par le plus récent.\nDans le terminal de RStudio, exécuter :Pour annuler le dernier commit, exécuter :Utiliser HEAD évite simplement de rechercher l’identifiant correspondant.","code":"git reset --hard <SHA>\ngit push -fgit revert <SHA>git revert HEAD"},{"path":"chap-git.html","id":"sec:confidentiel","chapter":"3 Git et GitHub","heading":"3.6 Données confidentielles dans un dépôt public","text":"Un dépôt public sur GitHub pose problème quand des données utilisées dans le projet ne le sont pas.Une solution peu satisfaisante consiste à ne pas inclure les données au projet, ce qui le rend non reproductible.\nUne meilleure solution est de les crypter, en permettant à certains utilisateurs de les décrypter.\nC’est l’objet du package secret.Un coffre-fort (dossier vault) est créé dans le projet.\nIl contient une liste d’utilisateurs autorisés : chacun d’entre eux doit disposer d’une paire de clés de cryptage, une clé publique incluse dans le coffre-fort et une clé privée, gardée secrète.\nLes données sont cryptées avec toutes les clés publiques disponibles (et donc dupliquées).\nLes utilisateurs utilisent ensuite chacun sa clé privée pour le décryptage.Pour ne pas multiplier les copies des données, le propriétaire du dépôt intérêt à créer un utilisateur générique pour le projet, dont il communiquera la clé privée hors de GitHub.\nLe coffre contiendra les clés du propriétaire du projet et de l’utilisateur générique seulement.\nEn cas de compromission de la clé privée de l’utilisateur générique, il suffira de le retirer du coffre-fort et d’en créer un nouveau.","code":""},{"path":"chap-git.html","id":"génération-dune-paire-de-clés-pour-le-propriétaire-du-projet","chapter":"3 Git et GitHub","heading":"3.6.1 Génération d’une paire de clés pour le propriétaire du projet","text":"Les clés sont générées par le logiciel ssh, installé avec git ou par défaut sous Linux.La procédure est identique à celle de la section 1.4.3, mais la clé utilisée doit être au format RSA (pris en charge par le package secret, contrairement au format ed25519, plus sûr, utilisé pour l’authenfication sur GitHub).Exécuter la commande suivante dans le terminal de RStudio pour créer une clé RSA :Stocker la clé publique sur GitHub dans “Settings > SSH GPG Keys”.\nRepérer la position de la clé : si une clé d’authentification déjà été enregistrée pour deux postes de travail par exemple, la clé RSA sera la troisième.","code":"ssh-keygen -t rsa -b 4096 -C \"user.email\""},{"path":"chap-git.html","id":"génération-dune-paire-de-clés-pour-le-projet","chapter":"3 Git et GitHub","heading":"3.6.2 Génération d’une paire de clés pour le projet","text":"Générer une clé au format RSA dans le terminal de RStudio :Entrer le nom de la clé : <RepoID>.rsa.Ne pas saisir de phrase de validation (mot de passe) pour permettre l’utilisation de la clé sans interaction.La clé privée <RepoID>.rsa ne doit être diffusée qu’aux ayant-droits du projet.\nIl faut donc ajouter la ligne *.rsa au fichier .gitignore du projet pour ne pas pousser la clé sur GitHub.Pour permettre l’intégration continue du projet (chapitre 6), la clé privée doit être stockée comme un secret du dépôt GitHub contenant le projet.\nAppliquer la procédure de la section 6.2.2 pour créer un secret nommé “RSA” et coller le contenu du fichier <RepoID>.rsa dans le champ “Value” du formulaire.L’utilisation du secret est décrite dans la section 6.2.5.","code":"ssh-keygen -t rsa -b 4096\" "},{"path":"chap-git.html","id":"création-dun-coffre-fort","chapter":"3 Git et GitHub","heading":"3.6.3 Création d’un coffre-fort","text":"Exécuter :","code":"\nlibrary(\"secret\")\nvault <- \"vault\"\ncreate_vault(vault)"},{"path":"chap-git.html","id":"ajout-des-utilisateurs","chapter":"3 Git et GitHub","heading":"3.6.4 Ajout des utilisateurs","text":"Le propriétaire du projet est ajouté à partir de sa clé publique stockée sur GitHub, qui est la troisième dans notre exemple.La clé de l’utilisateur générique du projet est ajoutée par :","code":"\n# Identifiant GitHub du propriétaire du projet\ngithub_user <- \"EricMarcon\"\n# Lecture et stockage de la clé, i est le numéro de la clé\nadd_github_user(github_user, vault = vault, i = 3)\nlibrary(\"openssl\")## Linking to: OpenSSL 3.2.2 4 Jun 2024\nproject_id <- \"NomDuProjet\"\n# Lecture de la clé\nrsa_project <- read_pubkey(paste0(project_id, \".rsa.pub\"))\n# Ajout au coffre-fort\nadd_user(project_id, public_key = rsa_project, vault = vault)"},{"path":"chap-git.html","id":"stockage-des-données","chapter":"3 Git et GitHub","heading":"3.6.5 Stockage des données","text":"Les données, stockées dans des variables de R, sont stockées une à une par la fonction add_secret().\nDans l’exemple suivant, la variable s’appelle X et vaut 1.Le contenu du coffre-fort peut être vérifié :Les données seront lues dans le code du projet par la commande get_secret().\nLa clé privée de l’utilisateur générique du projet, communiquée par un moyen sécurisé aux ayant-droits, doit se trouver dans le dossier du projet.La clé peut être vérifiée :","code":"\nX <- 1\nadd_secret(\n  # Nom de la donnée\n  \"X\", \n  # Valeur\n  value = X, \n  # Utilisateurs autorisés: propriétaire et générique\n  users = c(paste0(\"github-\", github_user), project_id), \n  # Coffre-fort\n  vault = vault)\n# Liste des données du coffre\nlist_secrets(vault = vault)##   secret        email\n## 1      X github-E....\n# Liste des propriétaire de la donnée 'X'\nlist_owners(\"X\", vault = vault)## [1] \"github-EricMarcon\" \"NomDuProjet\"\n# Sélection de la clé privée\nSys.setenv(USER_KEY = usethis::proj_path(paste0(project_id, \".rsa\")))## ✔ Setting active project to\n##   \"/Users/runner/work/travailleR/travailleR\".\n# Lecture de la donnée 'X'\nget_secret(\"X\", vault = vault)## [1] 1\nlocal_key()## [4096-bit rsa private key]\n## md5: e81dcb0745a755286c2dc1fc4c6ad117\n## sha256: cca11ef82e17c3b77b699e7f3c23e083e8f0f79cb70be8274799f076c44b0c2d"},{"path":"chap-git.html","id":"sec:github-pages","chapter":"3 Git et GitHub","heading":"3.7 Pages GitHub","text":"Tout projet sur GitHub doit avoir contenir un fichier README.md pour le présenter.\nCe fichier est écrit au format Markdown.Le fichier peut être placé dans le dossier docs pour fournir à fois la page d’accueil du dépôt et de son site web.\nLe package memoiR fournit des commandes permettant d’automatiser ces tâches dans les projets de documents.\nUn dépôt contenant un article écrit en R Markdown (voir section 4.3.2) est utilisé comme exemple44.Son fichier README.md existe aux deux emplacements : il est écrit par le développeur à la racine du projet et dupliqué dans docs.","code":""},{"path":"chap-git.html","id":"activation","chapter":"3 Git et GitHub","heading":"3.7.1 Activation","text":"Pour activer les pages GitHub, il faut ouvrir les propriétés du dépôt (Settings) et modifier la rubrique “GitHub Pages” (dans “Options”).\nSélectionner la branche du projet et le dossier contenant les pages web, ici : master et /docs.\nEn option, le choix d’un thème personnalise l’apparence des pages.Le site web est accessible à une adresse45 du domaine github.io.Le fichier README.md affiché en page d’accueil un aspect très différent mais le même contenu que celui affiché avec le code sur la page du dépôt dans GitHub.L’intérêt des pages GitHub est de permettre un accès simple aux documents formatés quand le dépôt contient une production écrite et ou à la documentation des packages R.\nCes contenus seront présentés dans le chapitre suivant.Un site web principal est proposé avec chaque compte GitHub, à l’adresse https://GitHubID.github.io46.\nIl sera utilisé pour héberger un site web personnel produit par blogdown.","code":""},{"path":"chap-git.html","id":"badges","chapter":"3 Git et GitHub","heading":"3.7.2 Badges","text":"Les badges sont de petites images, éventuellement mises à jour dynamiquement, qui renseignent rapidement sur le statut d’un projet.\nIls doivent être placés immédiatement après le titre du fichier README.md.Une bonne pratique consiste à indiquer l’avancement dans le cycle de vie du projet.\nLes badges correspondants sont listés sur le site du Tidyverse47.Leur code Markdown est le suivant :Le package usethis simplifie leur création en plaçant le code nécessaire dans le presse-papier.\nIl suffit ensuite de le coller dans le fichier.","code":"![stability-wip]\n(https://img.shields.io/badge/lifecycle-maturing-blue.svg)\nusethis::use_lifecycle_badge(\"maturing\")"},{"path":"chap-rediger.html","id":"chap-rediger","chapter":"4 Rédiger","heading":"4 Rédiger","text":"R et RStudio permettent de rédiger efficacement des documents de tous formats, du simple bloc-note à la thèse, en passant par des diaporamas.\nLes outils pour le faire sont l’objet de ce chapitre, complété par la production de sites web (y compris un site personnel).Deux procédés de production de documents sont disponibles :R Markdown avec les packages knitR et bookdown.\nC’est ma méthode classique, présentée ici en détail.Quarto, conçu pour être utilisé avec d’autres langages que R et dans d’autres environnements de travail que RStudio.\nQuarto est en développement actif mais ne permet pas encore de produire des documents avec la même qualité que R Markdown : par exemple, la ponctuation des documents en français n’est pas gérée correctement en PDF48, les tableaux ne peuvent pas inclure d’équations49 et la largeur des figures est incohérente dans les documents PDF formatés avec plusieurs colonnes50.\nL’usage de Quarto est bien documenté sur son site51 et n’est pas présenté ici.","code":""},{"path":"chap-rediger.html","id":"bloc-note-markdown-r-notebook","chapter":"4 Rédiger","heading":"4.1 Bloc-note Markdown (R Notebook)","text":"Dans un fichier .R, le code doit toujours être commenté pour faciliter sa lecture.\nQuand l’explication du code nécessite plusieurs lignes de commentaire par ligne ou bloc de code, il est temps d’inverser la logique et de placer le code dans un texte.Le concept de programmation lettrée (literate programming) été développé par Knuth (1984).\nIl s’agit de décrire les objectifs et les méthodes par du texte, dans lequel le code s’intègre.L’outil le plus simple est le bloc-note Markdown (Menu “File > New File > R Notebook”).\nLe modèle de document contient son mode d’emploi.Le langage qui permet de formater le texte est Markdown52, un langage de balisage simple à utiliser :Les paragraphes sont séparés par des sauts de ligne ;Le document est structuré par des titres : leur ligne commence par un nombre de # correspondant à leur niveau ;Les formats de caractères sont limités à l’essentiel : italique ou gras (texte entouré par une ou deux *) ;D’autres codes simples permettent tous les formatages utiles.Ce langage est le pivot du logiciel pandoc53, dédié à la conversion de documents de formats différents.Le package rmarkdown (Xie 2015) fait le lien entre R et Markdown, en s’appuyant sur l’interface de RStudio qui n’est pas indispensable mais simplifie énormément son utilisation.\nLe dialecte de Markdown utilisé par le package est appelé R Markdown.\nSa syntaxe est résumée dans une antisèche54.\nSa documentation complète est en ligne (Xie, Allaire, et Grolemund 2018).Les équations sont écrites au format LaTeX55.L’organisation la plus simple d’un document R Markdown est visible dans le modèle de bloc-note.\nIl commence par un en-tête au format YAML56:La première entrée est le titre, la seconde le format de sortie : plus précisément le nom de la fonction chargée de traiter le document.Le document contient du texte formaté en Markdown et des bouts de code (code chunks) entourés par trois accents graves (la syntaxe markdown d’un bloc de code) et une description du langage, ici r.\nCes bouts de code sont traités par knitr qui transforme le résultat de l’exécution du code R en Markdown et l’intègre au texte du document.Traiter un document R Markdown s’appelle le tricoter (knit).\nLa chaîne de production est la suivante :knitr traite les bouts de code : calculs, production de figures ;rmarkdown intègre la production des bouts de code et texte pour produire un fichier Markdown standard ;pandoc (installé avec RStudio) convertit ce fichier au format HTML, LaTeX ou Word ;LaTeX produit un fichier PDF quand ce format est demandé.RStudio permet de lancer le tricot par des boutons plutôt que par des commandes : dans la fenêtre source (celle du haut à gauche), un bouton “Knit” accompagne les documents R Markdown.\nPour les bloc-notes R Markdown, il est remplacé par un bouton “Preview” avec les mêmes fonctions.\nIl peut être déroulé pour choisir le format de sortie : HTML, Word, PDF (en passant par LaTeX) et, pour les bloc-notes, une commande “Preview” qui affiche le document en HTML sans exécuter les bouts de code pour gagner du temps.\nDès le premier tricot au format Word ou HTML, remarquera que le bouton “Preview” disparaît.Au final, l’utilisation de R Markdown combine plusieurs avantages :La simplicité de la rédaction : le texte brut est plus facile à lire et à formater qu’en LaTeX par exemple ;L’automatisation de la production : le formatage et la mise en page sont entièrement automatiques ;La reproductibilité : chaque document peut être autosuffisant accompagné de ses données. Relancer le tricotage régénère entièrement le document, y compris les calculs nécessaires et la production des figures.Elle aussi quelques inconvénients :Le formatage dépend de modèles, et developper de nouveaux modèles n’est pas simple ;Les erreurs de tricot sont parfois difficiles à corriger, notamment quand elles interviennent à l’étape de la compilation LaTeX ;La reproductibilité consomme du temps de calcul. Pour limiter ce problème, un système de cache permet de ne pas réévaluer tous les bouts de code R à chaque modification du texte. La production de gros documents peut aussi être déléguée à un système d’intégration continue (chapitre 6).","code":"---\ntitle: \"R Notebook\"\noutput: html_notebook\n---"},{"path":"chap-rediger.html","id":"modèles-r-markdown","chapter":"4 Rédiger","heading":"4.2 Modèles R Markdown","text":"Des modèles de document plus élaborés que le bloc-note sont fournis par des packages, dont rmarkdown.\nIls sont accessibles par le menu “File > New File > R Markdown…” (figure 4.1)).\nFigure 4.1: Nouveau document Markdown à partir d’un modèle.\nLes modèles les plus simples sont Document et Presentation.\nLes informations à fournir sont le titre et le nom de l’auteur, et le format du document attendu (qui pourra être modifié plus tard).\nCes modèles créent un seul fichier dont l’enregistrement ne sera obligatoire qu’au moment de tricoter.La syntaxe est la même que celle du bloc-note.\nDans l’entête, une entrée supplémentaire est utilisée pour la date, qui peut être calculée par R à chaque tricot :Remplacer les barres verticales | de l’exemple ci-dessus par des guillemets inversés : ce document étant écrit avec R Markdown, la date serait calculée et affichée à la place du code si les guillemets inversés étaient utilisés directement.Le code R en ligne (par opposition aux bouts de code) peut être utilisé partout dans un document R Markdown, y compris dans l’entête pour l’affichage de la date.\nIl commence par un guillemet inversé suivi de r et se termine par un autre guillemet inversé.Les documents peuvent être tricotés au format HTML, PDF (via LaTeX) ou Word.\nL’entête du fichier R Markdown est réécrit quand le tricot est lancé par le bouton de RStudio qui place en premier le format de sortie utilisé et l’ajoute si nécessaire.Les présentations peuvent être tricotées dans deux formats HTML, ioslide57 ou Slidy58, au format Beamer (PDF)59 ou en Powerpoint60.Le niveau 2 de plan (##) marque le changement de diapositive.Du code supplémentaire, présenté dans les documentations des formats HTML, permet d’utiliser des fonctionnalités spécifiques.Ces modèles sont simples mais assez peu utiles : le bloc-note R est plus facile à utiliser que le modèle de document pour des documents minimalistes.\nDes modèles plus élaborés sont disponibles.","code":"date: \"|r format(Sys.Date(), '%d/%m/%Y')|\""},{"path":"chap-rediger.html","id":"articles-avec-bookdown","chapter":"4 Rédiger","heading":"4.3 Articles avec bookdown","text":"R Markdown ne permet pas de rédiger un article scientifique.\nLa bibliographie ne pose pas de problème parce qu’elle est gérée par pandoc pour les documents HTML ou Word et sous-traitée à LaTeX pour les documents PDF.\nLes équations, figures et tableaux sont numérotés par LaTeX mais pas en HTML.\nLes références croisées (les renvois à un numéro de figure par exemple) ne sont pas supportés.\nEnfin, les légendes de figures ou tableaux ne supportent que du texte brut, sans aucun formatage.bookdown comble ces manques.\nLe package été conçu pour la rédaction d’ouvrages comportant plusieurs chapitres mais peut être utilisé pour des articles.Le package memoiR fournit les modèles présentés ici.\nIl doit être installé.","code":""},{"path":"chap-rediger.html","id":"ecrire","chapter":"4 Rédiger","heading":"4.3.1 Ecrire","text":"Les principales caractéristiques de Markdown sont résumées ici.\nUne formation rapide et plus complète est proposée par RStudio61.Le texte est écrit sans aucun autre formatage que les les retours à la ligne.\nUn simple retour à la ligne n’aucun effet sur le document produit : il permet de séparer les phrases pour simplifier le suivi du code source par git.Un saut de ligne marque un changement de paragraphe.Les différents niveaux de plan sont désignés par le nombre de croisillons correspondant en début de ligne : # pour un titre de niveau 1, ## pour un titre de niveau 2, etc.\nUn espace sépare les croisillons et le texte du titre.Les liste à puces sont marquées par un tiret (suivi d’un espace) en début de ligne.\nUn saut de ligne est nécessaire avant le début de la liste mais les éléments de la liste sont séparés par un simple retour à la ligne.\nLes listes indentées sont créées en insérant 4 espaces avant le tiret de début de ligne.\nEnfin, les listes numérotées sont créées de la même façon en remplaçant les tirets par des nombres, dont la valeur n’pas d’importance.Dans le texte, les parties en italique sont entourées par une étoile ou un tiret bas (*italique*), alors que deux étoiles marquent le gras.","code":""},{"path":"chap-rediger.html","id":"code-r","chapter":"4 Rédiger","heading":"4.3.1.1 Code R","text":"Le code R est inclus dans des bouts de code (code chunks) créés facilement en cliquant sur le bouton “Insert new code chunk” au-dessus de la fenêtre du code source dans RStudio.\nIls commencent et se terminent par trois guillemets inversés sur une nouvelle ligne.\nCes bouts de code peuvent contenir du code R mais aussi Python par exemple : le type de code est indiqué dans l’entête sur la première ligne, avant le nom du bout de code, puis une liste d’options séparées par des virgules, par exemple :Le nom et les options sont facultatifs : l’entête minimal est {r}.Les options les plus utiles sont :echo pour afficher (=TRUE) ou cacher (=FALSE) le code ;message=FALSE pour cacher les messages d’ouverture de certains packages ;warning=FALSE pour cacher les avertissements.Les options par défaut sont déclarées dans le bout de code nommé “Options” au début du document Markdown, dans la fonction opts_chunk$set().L’option include=FALSE supprime tout affichage lié au bout de code.\nDans un document tel qu’un article scientifique, qui n’affiche pas son code, elle doit être utilisée pour tous les bouts de code sauf ceux qui produisent les figures.","code":"```{r cars, echo=TRUE}\n```"},{"path":"chap-rediger.html","id":"figures","chapter":"4 Rédiger","heading":"4.3.1.2 Figures","text":"\nFigure 4.2: Titre de la figure\nLes figures peuvent être créées par le code R (figure 4.2).\nAvec Bookdown, une étiquette est associée à chaque figure : son nom est fig:xxx où xxx est le nom du bout de code R.\nLes renvois se font avec la commande \\@ref(fig:xxx).L’entête du bout de code de la figure 4.2 est :Il contient au minimum le nom de la figure et sa légende.\nSi la légende est longue, l’entête est peu lisible.\nDe plus, la légende est limitée à du texte simple.\nPour des légendes plus élaborées, il est possible de déclarer la légende dans un paragraphe séparé qui commence par le texte (ref:NomFigure).\nLa figure 4.3 bénéficie d’une légende améliorée.\nFigure 4.3: Titre avec italique, maths (\\(\\sqrt\\pi\\)) et renvoi vers la figure 4.2\nLe texte de fig.cap, “Titre de la figure” précédemment, est remplacé par (ref:pressure) à l’intérieur des guillemets qui sont conservés et la légende est saisie dans un paragraphe commençant par (ref:pressure) suivi d’un espace.\nLes légendes sont limitées à un paragraphe unique.Si une table des figures est utilisée (option lof: true dans l’entête), une légende courte est nécessaire en plus de la légende complète.\nElle est déclarée dans fig.scap.Les figures qui ne sont pas créées par R mais proviennent de fichiers sont intégrées dans un bout de code par la fonction include_graphics() dont l’argument est le fichier contenant l’image à afficher.\nPlacer systématiquement ces fichiers dans le dossier images pour une bonne organisation.","code":"\nplot(pressure)```{r pressure, fig.cap=\"Titre de la figure\"}\n```"},{"path":"chap-rediger.html","id":"tableaux","chapter":"4 Rédiger","heading":"4.3.1.3 Tableaux","text":"Les séparateurs horizontaux - et verticaux | permettent de dessiner un tableau selon la syntaxe de Markdown, mais ce n’est pas la meilleure méthode.Les tableaux peuvent aussi être produits par du code R.\nLe contenu du tableau est dans un dataframe.\nLa fonction kbl du package kableExtra prépare le tableau pour l’affichage et passe le résultat à la fonction kable_styling pour le formatage final.\nTable 4.1: Tableau créé par kable\nLa légende est précisée par l’argument caption et le référencement est possible parce que le tableau reçoit une étiquette dont le nom est tab: suivi du nom du bout de code (tableau 4.1).\nComme pour les figures, une légende améliorée peut être écrite dans un paragraphe séparé.\nUne légende courte pour une éventuelle liste des tableaux (option lot: true dans l’entête) est déclarée dans l’argument caption.short de kbl().Utiliser systématiquement l’argument booktabs = TRUE pour que l’épaisseur des lignes de séparation soit optimale en LaTeX.\nComme le tableau contient des mathématiques (dans le nom de la première colonne), l’option escape = FALSE est nécessaire.L’option de style bootstrap_options = \"striped\" fournit des tableaux plus lisibles en HTML.\nEnfin, l’option full_width = FALSE permet d’ajuster la largeur du tableau à son contenu au lieu d’occuper toute la largeur disponible.Le package flextable permet de réaliser des tableaux plus élaborés, comme dans l’exemple suivant qui affiche en couleur les longs sépales.Longueur sépalesLargeurLongueur pétalesLargeurEspèce5.13.51.40.2setosa4.93.01.40.2setosa4.73.21.30.2setosa4.63.11.50.2setosa5.03.61.40.2setosa5.43.91.70.4setosaLa documentation du package62 est disponible en ligne, ainsi qu’une galerie63.flextable ne supporte pas la numérotation des légendes hormis dans les documents Word.\nCette limite est rédhibitoire.","code":"\nlibrary(\"tidyverse\")\nmes_iris <- head(iris)\nnames(mes_iris) <- c(\"Longueur sépales ($l_s$)\", \"Largeur\",\n    \"Longueur pétales\", \"Largeur\", \"Espèce\")\nkableExtra::kbl(mes_iris, caption = \"Tableau créé par kable\",\n    booktabs = TRUE, escape = FALSE) %>%\n    kableExtra::kable_styling(bootstrap_options = \"striped\",\n        full_width = FALSE)\nlibrary(\"flextable\")## \n## Attaching package: 'flextable'## The following objects are masked from 'package:spatstat.geom':\n## \n##     border, rotate## The following object is masked from 'package:purrr':\n## \n##     compose\n# Rappel du jeu de données initial iris\niris %>%\n    # Premières lignes\nhead() %>%\n    # Création d'un objet flextable\nflextable() %>%\n    # Titre des colonnes\nset_header_labels(Sepal.Length = \"Longueur sépales\", Sepal.Width = \"Largeur\",\n    Petal.Length = \"Longueur pétales\", Petal.Width = \"Largeur\",\n    Species = \"Espèce\") %>%\n    # Sélection des longs sépales (>5) et affichage en\n    # rouge\ncolor(~Sepal.Length > 5, ~Sepal.Length, color = \"red\")"},{"path":"chap-rediger.html","id":"maths","chapter":"4 Rédiger","heading":"4.3.1.4 Maths","text":"Les équations au format LaTeX peuvent être insérées en ligne, comme \\(=\\pi r^2\\) (code : $=\\pi r^2$) ou isolées (les $ sont doublés) comme \\[e^{\\pi} = -1.\\]Elles peuvent être numérotées : voir équation (4.1), en utilisant l’environnement \\equation.\\[\\begin{equation}\n  = \\pi r^2.\n  \\tag{4.1}\n\\end{equation}\\]L’équation numérotée est créée par le code suivant :","code":"\\begin{equation}\n  A = \\pi r^2.\n  (\\#eq:disque)\n\\end{equation}"},{"path":"chap-rediger.html","id":"références-croisées","chapter":"4 Rédiger","heading":"4.3.1.5 Références croisées","text":"Les figures et tableaux ont une étiquette générée automatiquement, identique au nom du bout de code préfixé par fig: et tab:.Pour les équations, l’étiquette est ajoutée manuellement par le code (\\#eq:xxx) avant la fin de l’équation.Les sections peuvent recevoir une étiquette en terminant leur titre par {#yyy}.\nLes sections reçoivent par défaut une étiquette implicite64 correspondant à leur texte, en minuscules, où les caractères spéciaux sont remplacés par des tirets.\nLes étiquettes implicites sont instables (elles changent avec le titre de la section) et difficiles à prévoir : c’est pourquoi il est conseillé d’ajouter une étiquette explicite à chaque section faisant l’objet d’un renvoi.\nC’est le cas des chapitres, pour lesquels le nom du fichier HMTL produit est identique à l’étiquette.\nLes étiquettes de chapitres doivent respecter les règles de nomenclature des fichiers en ne contenant pas de caractères spéciaux.Des signets peuvent aussi être placés librement dans le texte avec la commande (ref:zzz).Dans tous les cas, l’appel à la référence est fait par la commande \\@ref(ref:zzz).","code":""},{"path":"chap-rediger.html","id":"bibliographie","chapter":"4 Rédiger","heading":"4.3.1.6 Bibliographie","text":"Les références bibliographiques au format BibTeX doivent être incluses dans le fichier .bib déclaré dans l’entête du document Markdown.Ce fichier peut être créé et maintenu à jour par Zotero installé avec l’extension Better BibTeX (voir section 1.6).\nIl suffit pour cela de créer une collection Zotero correspondant au projet et d’y glisser les références pertinentes.\nUtiliser ensuite le menu contextuel “Exporter la collection…” et sélectionner :Format : “Better BibTeX” pour les articles et présentations ou “Better BibLaTeX” pour les mémoires, selon que la bibliographie est gérée par BibTeX et natbib ou biber et BibLaTeX pour la production de documents PDF.Cocher la case “Garder à jour” pour que toute modification dans Zotero soit exportée automatiquement.Cliquer sur “OK” puis choisir le nom du fichier (references.bib) et son emplacement (le dossier du projet R).Les références peuvent être appelées dans le texte, entre parenthèses par le code [@Reference], ou dans le texte, en supprimant les crochets.La bibliographie est traitée par pandoc lors de la production de documents Word ou HTML.\nLe style bibliographique peut être précisé, en ajoutant la lignedans l’entête du document et en copiant le fichier de style .csl dans le dossier du projet.\nPlus d’un millier de styles sont disponibles65.Pour les documents PDF, la bibliographie est gérée par LaTeX.Pour préparer la soumission d’un manuscrit à une revue, il faudra ouvrir le fichier .tex intermédiaire produit par pandoc et copier le contenu de l’environnement {document} dans le modèle proposé par la revue, qui se chargera du formatage.","code":"bibliography: references.bibcsl:nom_du_fichier.csl"},{"path":"chap-rediger.html","id":"langues","chapter":"4 Rédiger","heading":"4.3.1.7 Langues","text":"Les langues sont à déclarer dans l’entête des document produits par les modèles de memoiR.La langue principale du document modifie le nom de certains éléments, comme la table des matières.\nLes langues supplémentaires permettent la rédaction de documents multilingues.Les champs de l’entête sont :Le changement de langue dans le document est géré en LaTeX mais pas en HTML en insérant sur une nouvelle ligne la commande suivante :La langue en cours n’d’effet que dans les sorties LaTeX : un espace est ajouté devant les ponctuations doubles en Français, la taille des espaces est plus grande en début de phrase en Anglais, etc.\nLa commande \\selectlanguage est simplement ignorée en HTML.Les noms de langues sont différents dans l’entête (codes IETF) et dans le texte (nom de la langue).\nLa correspondance et la liste complète des langues se trouve dans le tableau 3 de la documentation du package polyglossia66.Le formatage en HTML de la ponctuation des documents en français est possible par l’intermédiaire d’un filtre déclaré à pandoc 67.\nLe fichier fr-nbsp.lua doit être copié dans le répertoire du projet à partir de son dépôt GitHub et éclaré dans l’entête du document Markdown.Le filtre formate toute la ponctuation du document, quelle que soit sa langue : il ne doit donc être utilisé que pour les documents entièrement en français.","code":"lang: fr-FR\notherlangs: [en-US, it]\\selectlanguage{english}output:\n    pandoc_args:\n      - --lua-filter=fr-nbsp.lua"},{"path":"chap-rediger.html","id":"sec:memo","chapter":"4 Rédiger","heading":"4.3.2 Modèle Simple Article","text":"Le modèle Simple Article de memoiR produit un document HTML simple avec une table des matières flottante (voir l’exemple68).\nD’autres formats HTML sont disponibles : voir la gallerie69 du package.\nLe format PDF est proche du modèle article de LaTeX (exemple70).Le modèle contient sa propre documentation.","code":""},{"path":"chap-rediger.html","id":"créer","chapter":"4 Rédiger","heading":"4.3.2.1 Créer","text":"Utiliser le menu “File > New File > R Markdown…” puis sélectionner “template” (figure 4.1).\nLa liste des modèles disponible et le package qui les propose est alors affichée.Sélectionner le modèle Simple Article du package memoiR, choisir le nom du projet (“Name :”, qui sera le nom du dossier dans lequel il sera créé, et son dossier parent (“Location :”).\nDans l’organisation proposée en section 1.2.4, le dossier parent est %LOCALAPPDATA%\\ProjetsR.\nLe nom du projet ne doit contenir aucun caractère spécial (accent, espace…) pour assurer sa portabilité sur tous les systèmes d’exploitation (Windows, Linux, MacOS).Les modèles élaborés créent un dossier avec de nombreux fichiers (bibliographie, styles, modèle LaTeX…), contrairement aux modèles simples qui créent seulement un fichier.Quand un dossier est créé, par exemple par le modèle Simple Article, il faut en faire un projet RStudio : dans le menu des projets (en haut à droite de la fenêtre de RStudio), utiliser le menu “New Project…” puis “Existing Directory” et sélectionner le dossier qui vient d’être créé.","code":""},{"path":"chap-rediger.html","id":"ecrire-1","chapter":"4 Rédiger","heading":"4.3.2.2 Ecrire","text":"Les instructions pour utiliser le modèle sont contenues dans le texte fourni par défaut.","code":""},{"path":"chap-rediger.html","id":"tricoter","chapter":"4 Rédiger","heading":"4.3.2.3 Tricoter","text":"Le document peut être tricoté en plusieurs formats :html_document2 est le format HTML pour lequel le modèle été conçu : un bloc-note avec une table des matières flottante ;gitbook est un format HTML alternatif, utilisé normalement pour les ouvrages ;downcute est un format HTML proposé par le package rmdformats ;pdf_book produit un document PDF suivant le modèle LaTeX article, couramment utilisé directement en LaTeX ;word_document2 crée un ficher Word.","code":""},{"path":"chap-rediger.html","id":"sec:article-en-ligne","chapter":"4 Rédiger","heading":"4.3.2.4 Mettre en ligne","text":"Le package memoiR simplifie la mise en ligne des documents produits.La fonction build_gitignore() crée un fichier .gitignore pour le contrôle de source qui doit être activé (voir section 3.1.1).La fonction build_readme() crée un fichier README.md nécessaire à GitHub.\nIl contient le titre du projet, son résumé et des liens vers les versions HTML et PDF des documents produits.Le projet doit être lié à un dépôt GitHub (section 3.2).Deux stratégies de publications sont possible.\nDans la première, les documents sont tricotés localement et placés dans le dossier docs, qui sera le support des pages GitHub.\nDans la seconde, les documents sont tricotés par GitHub Actions à chaque fois que des modifications sont poussées sur le dépôt : parle d’intégration continue (section 6).La stratégie de production locale est traitée ici ; l’intégration continue le sera dans la section 6.3.1.La fonction build_githubpages() place tous les documents tricotés (HTML et PDF) dans le dossier docs, avec une copie du fichier README.md.\nDe cette façon, il est possible d’activer les pages GitHub du projet (sur le dossier docs de la branche master).\nLe fichier README.md sera la page d’accueil du site web produit.En pratique, tricote au format HTML pendant toute la phase de rédaction, parce que la production est très rapide.\nQuand le document est stabilisé, il faut le tricoter au format HTML et au format PDF.\nEnfin, l’exécution de build_githubpages() place tous les fichiers produits dans docs.\nIl reste à pousser le dépôt sur GitHub et activer les pages GitHub.","code":""},{"path":"chap-rediger.html","id":"autres-modèles","chapter":"4 Rédiger","heading":"4.3.3 Autres modèles","text":"Le modèle Stylish Article de memoiR est destiné à la production d’articles PDF pour l’autoarchivage (typiquement, le dépôt sur HAL) bien formatés, au format A4 en double colonne71.Le format HTML est le même que celui du modèle Simple Article.Le package rticles pour ambition de fournir des modèles pour toutes les revues scientifiques qui acceptent une soumission d’articles en LaTeX.\nIl propose donc des modèles Markdown qui produisent des fichiers PDF conformes aux exigences des revues et la possibilité de récupérer le fichier .tex intermédiaire (pandoc produit un fichier .tex transmis au compilateur LaTeX).\nLe package ne permet pas de tricot HTML parce qu’il utilise la syntaxe LaTeX dans le document R Markdown au lieu d’utiliser bookdown pour gérer les références bibliographique et les références croisées.\nIl n’est pas possible d’échanger directement du contenu R Markdown standard avec des documents écrits pour rticles, ce qui limite beaucoup l’intérêt du package.","code":""},{"path":"chap-rediger.html","id":"présentation-beamer","chapter":"4 Rédiger","heading":"4.4 Présentation Beamer","text":"Le modèle Beamer Presentation de memoiR permet de créer des présentations au format HTML et PDF (beamer) simultanément, comme le montre l’exemple72.La démarche est identique à celle des articles du même package.\nLes niveaux de titre permettent de séparer les parties de la présentation (#) et les diapositives (##).\nDeux formats sont disponibles en HTML : ioslides73 et Slidy74.\nQuelques spécificités dans le code permettent d’affiner la présentation des diapositives, pour un affichage sur deux colonnes par exemple : elles sont documentées dans le modèle.","code":""},{"path":"chap-rediger.html","id":"memoir","chapter":"4 Rédiger","heading":"4.5 memoir","text":"Le modèle Memoir du package memoiR est destiné aux documents longs, qui présentent une différence importante avec les documents précédents : un document long est composé de plusieurs chapitres, chacun placé dans son fichier .Rmd.Le format HTML est gitbook75, le standard de la lecture en ligne de documents de ce type.\nLe format PDF est dérivé du modèle LaTeX memoir76, optimisé aussi pour les documents longs.Ce document été écrit avec ce modèle.","code":""},{"path":"chap-rediger.html","id":"créer-1","chapter":"4 Rédiger","heading":"4.5.1 Créer","text":"La création d’un projet d’ouvrage est identique à celle présentée plus haut : le modèle est : Memoir.\nLe dossier créé doit être transformé en projet.Exécuter build_git() et build_readme(), activer le contrôle de source et pousser le projet sur GitHub, de la même façon que pour un article (section 4.3.2.4).Chaque chapitre de l’ouvrage est un fichier Rmd, dont le nom commence normalement par son numéro (ex. : 01-intro.Rmd).\nTous les fichiers Rmd présents dans le dossier du projet sont en réalité traités comme des chapitres, triés par ordre de nom de fichier, dont ceux fournis par le modèle (démarrage et syntaxe) qui doivent être supprimés à l’exception de 99-references.Rmd qui contient la bibliographie, placée à la fin.\nLe fichier index.Rmd est particulier : il contient l’entête du document et le premier chapitre.","code":""},{"path":"chap-rediger.html","id":"ecrire-2","chapter":"4 Rédiger","heading":"4.5.2 Ecrire","text":"Le premier chapitre est placé dans l’avant-propos de l’ouvrage imprimé : il ne doit pas être numéroté (d’où le code {-} à côté du titre) dans la version HTML.\nIl se termine obligatoirement par la commande LaTeX \\mainmatter qui marque le début du corps de l’ouvrage.Les niveaux de plan commencent par # pour les chapitres (un seul par fichier), ## pour les sections, etc.","code":""},{"path":"chap-rediger.html","id":"tricoter-1","chapter":"4 Rédiger","heading":"4.5.3 Tricoter","text":"La compilation au format PDF est faite par XeLaTeX, qui doit être installé.Pendant la rédaction, il est fortement conseillé de ne créer que le fichier HTML, ce qui est beaucoup plus rapide qu’une compilation LaTeX.\nChaque chapitre peut être visualisé très rapidement en cliquant sur le bouton “Knit” au-dessus de la fenêtre de source.\nLe livre entier est créé en cliquant sur le bouton “Build Book” de la fenêtre Build de RStudio.\nLa liste déroulante du bouton permet de créer tous les documents ou de se limiter à un format.Les fichiers produits sont placés directement dans le dossier docs, qui sera utilisé par les pages GitHub pour permettre la lecture en ligne et le téléchargement du PDF.\nLa page d’accueil du site web est créée par bookdown à partir du fichier index.Rmd : le fichier README.md n’est pas dupliqué dans docs.","code":""},{"path":"chap-rediger.html","id":"finitions","chapter":"4 Rédiger","heading":"4.5.4 Finitions","text":"La mise en page est assurée de façon totalement automatique par pandoc (en HTML) et LaTeX (en PDF).Il est souvent utile d’aider LaTeX à résoudre quelques dépassements de marge dus à de trop grandes contraintes de mise en page : pour la lisibilité optimale, les colonnes sont étroites, mais le code (texte formaté entre deux apostrophes inversées) n’autorise pas la césure.Si une ligne de texte dépasse dans la marge de droite dans le document PDF, la solution consiste à ajouter manuellement le code \\break à l’emplacement désiré pour le retour à la ligne dans le document R Markdown.\nLa commande n’aucun effet sur le document HTML mais force la césure en LaTeX.\nPour couper du texte formaté (entre astérisques pour l’italique ou plus fréquemment entre apostrophes inversées pour du code), il faut terminer le formatage avant \\break et le recommencer après.\nExemple, pour forcer le retour à la ligne avant fichier.Rmd :En HTML, un espace sera ajouté entre les deux portions de code.Les bouts de code R sont formatés automatiquement par knitr quand l’option tidy=TRUE leur est appliquée.\nLe comportement par défaut est indiqué dans les options de knitr, dans un bout de code au début du fichier index.Rmd :La largeur maximale d’une ligne de code formaté est ici de 55 caractères, optimal pour le modèle.\nIl arrive que le formatage automatique ne fonctionne pas parce que knitr ne parvient pas à trouver une coupure de ligne respectant toutes les contraintes, ce qui provoque un dépassement de marge dans le code.\nDans ce cas, formater manuellement le bout de code en lui ajoutant l’option tidy=FALSE.Les blocs de code littéral, délimités par trois apostrophes inversées, doivent être formatés manuellement, en évitant toute ligne de plus de 55 caractères.","code":"Le fichier `/chemin/`\\break`fichier.Rmd`\n# knitr options\nknitr::opts_chunk$set(\n  cache=TRUE, warning=FALSE, echo = TRUE,\n  fig.env='SCfigure', fig.asp=.75, \n  fig.align='center', out.width='80%', \n  tidy=TRUE, \n  tidy.opts=list(blank=FALSE, width.cutoff=55), \n    size=\"scriptsize\",\n  knitr.graphics.auto_pdf = TRUE)"},{"path":"chap-rediger.html","id":"site-gitbook","chapter":"4 Rédiger","heading":"4.5.5 Site gitbook","text":"Le site web contenant le document gitbook doit être paramétré dans _output.yml pour que :le titre du document apparaisse en haut de la table des matières ;une indication de l’usage de GitHub et bookdown soit affichée en bas de la table des matières ;un bouton GitHub dans la barre de titre permette d’ouvrir le dépôt du projet ;un autre bouton permette de télécharger le document PDF.Le fichier _output.yml de ce document est le suivant :La section sharing: gère les boutons de la barre de titre.\nPar défaut, les liens vers Facebook et Twitter sont activés mais celui vers GitHub ne l’est pas.\nPour qu’il fonctionne, le dépôt GitHub doit être déclaré dans l’entête du fichier index.rmd :La section toc: contient deux portions de code HTML dans lesquelles le titre du document et le lien vers son dépôt GitHub doivent être adaptés au projet.Enfin, la section download: liste les formats de documents téléchargeables et permet d’afficher un bouton de téléchargement dans la barre de titre.","code":"bookdown::gitbook:\n  css: style.css\n  config:\n    sharing:\n      github: yes\n      facebook: false\n      twitter: false\n    toc:\n      before: |\n        <li><a href=\"./\">Travailler avec R<\/a><\/li>\n      after: |\n        <li>\n          <a href=\"https://github.com/EricMarcon/travailleR\" target=\"blank\">\n            Hébergé sur GitHub, publié par bookdown\n          <\/a>\n        <\/li>\n    download: pdfgithub-repo: EricMarcon/travailleR"},{"path":"chap-rediger.html","id":"sec:rediger-ouvrage-ci","chapter":"4 Rédiger","heading":"4.5.6 Intégration continue","text":"La construction d’un ouvrage prend du temps, surtout s’il contient des calculs.\nElle doit être lancée au format gitbook et au format PDF.\nEn production, elle peut être confiée à GitHub (chapitre 6.3.1.1).","code":""},{"path":"chap-rediger.html","id":"google-analytics","chapter":"4 Rédiger","heading":"4.5.7 Google Analytics","text":"Le suivi de l’audience de l’ouvrage peut être confié à Google Analytics.\nPour cela, il faut créer un compte et ajouter une propriété Google Analytics, c’est-à-dire un site web, puis un flux de données, ici un flux web77.Google Analytics fournit un script de configuration nommé gtag.js à placer à la racine du dossier du projet.\nEnfin, déclarer le script dans l’entête des pages web en ajoutant une instruction dans _output.yml, dans sa première section.","code":"bookdown::gitbook:\n  includes:\n    in_header: gtag.js"},{"path":"chap-rediger.html","id":"site-web-r-markdown","chapter":"4 Rédiger","heading":"4.6 Site web R Markdown","text":"Un site web constitué de pages écrites avec R Markdown (sans les fonctionnalités de bookdown) et un menu peut être créé très simplement, avec un résultat de bonne facture78.","code":""},{"path":"chap-rediger.html","id":"modèle","chapter":"4 Rédiger","heading":"4.6.1 Modèle","text":"Dans RStudio, dans le menu des projets en haut à droite, cliquer sur “New Project…” puis “New Directory” puis “Simple R Markdown website”.\nSaisir le nom du projet, sélectionner le dossier dans lequel le projet sera créé en cliquant sur “Browse” et enfin cliquer sur “Create Project”.Le site par défaut contient deux pages : index, la page d’accueil, et , la page “propos”.\nLe fichier _site.yml contient le nom du site et le contenu de sa barre de navigation : un titre et le fichier correspondant.\nD’autres pages seront ajoutées en créant de nouveaux fichiers .Rmd et en les ajoutant au fichier _site.yml.","code":""},{"path":"chap-rediger.html","id":"améliorations","chapter":"4 Rédiger","heading":"4.6.2 Améliorations","text":"Le modèle de site peut facilement être amélioré en complétant _site.yml :en ajoutant une icône GitHub dans la barre de navigation pour renvoyer vers le code source du site ;en choisissant la méthode de tricot des pages, pour utiliser bookdown au lieu de rmarkdown ;en plaçant les fichiers du site dans le dossier docs et ainsi séparer le code et la production.Le fichier _site.yml complété est le suivant :L’icône de GitHub fait partie de la collection Font Awesome dont toutes les icônes gratuites79 sont utilisables avec la même syntaxe : “fa-nom”.Le lien correspondant à l’icône doit être celui du dépôt GitHub du site web.La syntaxe de la section output est la même que celle des documents vus plus haut.\nElle s’applique à toutes les pages (dont l’entête YAML est réduite au minimum).\nLes thèmes disponibles sont ceux de rmarkdown80.L’option highlight indique la façon dont le code R éventuellement affiché sera formaté.\nEnfin, la table des matières est flottante, ce qui signifie que sa position s’ajuste quand la fenêtre défile.","code":"name: \"my-website\"\nnavbar:\n  title: \"My Website\"\n  left:\n    - text: \"Home\"\n      href: index.html\n    - text: \"About\"\n      href: about.html\n  right:\n    - icon: fa-github\n      href: https://github.com/rstudio/rmarkdown\noutput_dir: \"docs\"\noutput:\n  bookdown::html_document2:\n    theme: sandstone\n    highlight: tango\n    toc: true\n    toc_float: yes"},{"path":"chap-rediger.html","id":"contôle-de-source","chapter":"4 Rédiger","heading":"4.6.3 Contôle de source","text":"Le projet doit être placé sous contrôle de source et poussé sur GitHub (chapitre 3).\nLe fichier .gitignore est le suivant :Activer les pages GitHub (section 3.7) sur le dossier docs pour héberger le site.\nAjouter un fichier vide nommé .nojekyll dans docs pour que les pages GitHub ne tentent pas de reformater le site.\npeut utiliser le terminal de RStudio pour exécuter :","code":"# R\n.Rbuildignore\n.RData\n.Rhistory\n.Rprofile\n.Rproj.user\n\n# Web Site\n/_site/\n/*_cache/\n/*_files/touch docs/.nojekyll"},{"path":"chap-rediger.html","id":"sec:blogdown","chapter":"4 Rédiger","heading":"4.7 Site web personnel : blogdown","text":"Pour créer une page web personnelle, Hugo est un générateur de site statique capable de produire des pages HTML à partir de code Markdown.\nLes sites statiques ont l’avantage, en comparaison aux sites dynamiques gérés par un système de gestion de contenu (CMS, par exemple : Wordpress, Joomla, SPIP), d’être portables sur n’importe quel serveur web sans support de base de données ni de code à exécuter côté le serveur (tel que PHP) et d’être très rapides puisque les pages sont créées une seule fois et non à chaque consultation.\nUn site Hugo peut être hébergé par exemple sur la page personnelle de tout utilisateur de GitHub dont l’adresse est de la forme “GitHubID.github.io”.Hugo propose de nombreux thèmes, qui sont des modèles de structure de sites, donc le thème Academic, destiné aux chercheurs.\nDans RStudio, le package blogdown est prévu pour produire facilement des pages web avec Hugo.\nCes pages peuvent contenir du code R : elles sont très proches d’un article, vu plus haut, dont le contenu peut être facilement copié et collé.\nNous utiliserons donc cette solution, pour un site comme celui proposé en exemple81.La structure du site web est simple :une page d’accueil, contenant divers composants paramétrables comme la biographie de l’auteur, une sélection de publications, de billets de blogs ou d’autres éléments et un formulaire de contact ;des pages détaillant les divers éléments (publications, billets, etc.) écrites en R Markdown.","code":""},{"path":"chap-rediger.html","id":"installation-des-outils","chapter":"4 Rédiger","heading":"4.7.1 Installation des outils","text":"La première étape consiste à installer le package blogdown dans R.blogdown est capable d’installer Hugo sous Windows, macOS ou Linux.La documentation complète de blogdown est disponible82.Les versions récentes de Hugo utilisent Go (le langage de programmation) pour installer leurs modules à la volée : ici le thème Academic est chargé depuis GitHub au moment de la création du site.\nGo doit donc être installé83.","code":"\ninstall.packages(\"blogdown\")\nblogdown::install_hugo()"},{"path":"chap-rediger.html","id":"créer-2","chapter":"4 Rédiger","heading":"4.7.2 Créer","text":"La façon la plus simple consiste à créer un dépôt sur GitHub à partir du modèle.\nSur la page du dépôt starter-academic84, cliquer sur le bouton “Use template”, s’authentifier éventuellement sur GitHub, puis saisir le nom du dépôt qui contiendra le projet, par exemple “MySite”.Le dépôt peut être celui du site principal de son compte GitHub (voir section 3.7), à l’adresse https://GitHubID.github.io85.\nLe nom à saisir est simplement “GitHubID.github.io” (GitHubID est le nom du compte GitHub).Créer le dépôt.\nCopier l’adresse du dépôt en cliquant sur le bouton “Code” puis sur le bouton à droite de l’adresse (figure 4.4).\nFigure 4.4: Copie de l’adresse d’un dépôt à cloner sur GitHub.\nDans RStudio, créer un nouveau projet à partir de GitHub : dans le menu des projets en haut à droite, cliquer sur “New Project…” puis “Version Control” puis “Git” puis coller l’adresse dans le champ “Repository URL” (figure 4.5).\nSélectionner le dossier dans lequel le projet sera créé en cliquant sur “Browse” et enfin cliquer sur “Create Project”.\nFigure 4.5: Collage de l’adresse du dépôt à cloner.\nLe projet créé est une copie exacte du modèle, qui doit être personnalisée.RStudio ajoute automatiquement à la fin du fichier .gitignore une ligne pour ignorer ses fichiers de travail (dossier .Rproj.user).\nAjouter une ligne de commentaire pour le signaler.\nLe contenu de .gitignore doit être le suivant :Un bug de blogdown nécessite de déplacer le fichier config.toml du dossier config/_default/ à la racine du projet.Prendre en compte ces modification dans git en faisant un commit.","code":"# R\n.Rbuildignore\n.RData\n.Rhistory\n.Rprofile\n.Rproj.user\n\n# Hugo\n/resources/\n/public/\n\n# blogdown\n/static/en/\n/static/fr/\n*.rmarkdown\n_index.html\nindex.html\n**/index_files/"},{"path":"chap-rediger.html","id":"construction-du-site","chapter":"4 Rédiger","heading":"4.7.3 Construction du site","text":"Exécuterpour construire le site web, y compris ses futures pages R Markdown.Pour afficher le site, exécuter :Il apparaît dans la fenêtre Viewer de RStudio, dont le bouton d’agrandissement permet l’affichage dans le navigateur internet par défaut du système.Pour modifier le contenu du site, il est préférable d’arrêter le serveur web par la commande :Le site produit par blogdown se trouve dans le dossier public qui peut être copié directement sur un serveur web qui l’hébergera.\nUne solution simple consiste à déclarer ce dossier comme racine des pages GitHub du projet\n(section 3.7).\nLa méthode optimale consiste à utiliser l’intégration continue (voir section 6.3.2) pour le copier à la racine de la branche gh-pages qui sera déclarée comme emplacement du site sur GitHub.","code":"\nblogdown::build_site(build_rmd = TRUE)\nblogdown:::serve_site()\nblogdown:::stop_server()"},{"path":"chap-rediger.html","id":"site-multilingue","chapter":"4 Rédiger","heading":"4.7.4 Site multilingue","text":"Si le site est multilingue, son contenu (dossier content) doit être copié dans un dossier correspondant à chaque langue.\nPar exemple, le fichier content/authors/admin/_index.md qui contient les informations sur le propriétaire du site est remplacé par content/en/authors/admin/_index.md et content/fr/authors/admin/_index.md si le site supporte l’Anglais et le Français.\nEn pratique, créer un dossier en et un dossier fr dans content.\nDéplacer tout le contenu de original de content dans en puis copier ce même contenu dans fr.","code":""},{"path":"chap-rediger.html","id":"paramétrer","chapter":"4 Rédiger","heading":"4.7.5 Paramétrer","text":"Les fichiers de configuration du site sont bien documentés et offrent de nombreuses options.\nLes principales sont passées en revue ici pour une création rapide d’un site fonctionnel.Le fichier config.toml contient les paramètres généraux du site.\nLes lignes à mettre à jour sont celle du titre du site (le nom du propriétaire puisqu’il s’agit d’un site personnel) et son adresse publique.\nPour le site exemple :Il contient aussi la ligne de sélection de la langue par défaut (“en” ou “fr” au choix) et celle qui permet de placer les fichiers produits par Hugo dans chaque dossier de langue (“true” obligatoirement pour un site multilingue) :Le dossier config/_default/ contient les autres fichiers de configuration.languages.toml contient les paramètres linguistiques et les traductions de menus.\nPour chaque langue, la version utilisée et le dossier de contenu sont précisés :Pour les langues additionnelles, le titre du site, les paramètres d’affichage des dates et la traduction des menus sont ajoutés.\nDans la section [fr] :Ces lignes sont commentées dans le modèle et doivent dont être décommentées en retirant les # en têtes de lignes.Les menus sont décrits plus bas.params.toml décrit l’aspect du site.\nLes options sont regroupées par sujet, par exemple “Theme” pour l’apparence générale.\nDans “Basic Info”, la lignesélectionne un site personnel.\nIl est possible d’utiliser Academic pour un site de projet scientifique ou un site d’unité, non documentés en détail ici.\nLes principales différences sont, pour un site collectif :la gestion des auteurs : dans le dossier /contents/<langue>/authors, un seul dossier admin est utilisé pour un site personnel alors qu’un dossier par personne est nécessaire pour un site collectif ;un composant décrit plus bas, qui permet de présenter les personnes, doit être activé.La description du site dans la langue par défaut est saisie, à destination des moteurs de recherche :Elle doit être traduite dans le fichier languages.toml, dans chaque langue.Dans “Site Features”, nous sélectionnons la coloration du code R, l’activation du formatage des équations et l’avertissement légal pour l’utilisation des cookies.La ligne edit_page doit être mise à jour : remplacer le dépôt par défaut “https://github.com/gcushen/hugo-academic” par celui du site.“Contact details” contient les informations pour contacter le propriétaire du site.\nElles doivent être saisies.“Regional Settings” contient les paramètres d’affichage de date pour la langue par défaut (ceux des autres langues sont dans languages.toml).\nIls n’ont normalement pas à être modifiés.“Comments” permet d’activer les commentaires des visiteurs en bas de pages, avec Disqus ou Comment.io (un compte est nécessaire chez le fournisseur).\n“Marketing” permet d’activer le suivi de fréquentation du site en saisissant simplement son identifiant Google Analytics (à créer avec un compte Google).\n“Content Management System” contient la ligne netlify_cms dont la valeur doit être false si le site n’est pas hébergé par Netlify.\nEnfin “Icon Pack Extensions” permet d’activer les icônes Academicons si nécessaire.","code":"title = \"Eric Marcon\"\nbaseurl = \"https://EricMarcon.github.io/\"defaultContentLanguage = \"fr\"\ndefaultContentLanguageInSubdir = true[en]\n  languageCode = \"en-us\"\n  contentDir = \"content/en\"\n[fr]\n  languageCode = \"fr-fr\"\n  contentDir = \"content/fr\"[fr]\n  languageCode = \"fr-fr\"\n  contentDir = \"content/fr\"\n  title = \"Eric Marcon\"\n  description = \"Page personnelle d'Eric Marcon\"\n  [fr.params]\n    description = \"\"\n    date_format = \"02-Jan-2006\"\n    time_format = \"15:04\"\n  [[fr.menu.main]]\n    name = \"Accueil\"\n    url = \"#about\"\n    weight = 20\n(...)site_type = \"Person\"description = \"Eric Marcon's Homepage\"highlight_languages = [\"r\"] \nmath = true\nprivacy_pack = true"},{"path":"chap-rediger.html","id":"ecrire-3","chapter":"4 Rédiger","heading":"4.7.6 Ecrire","text":"Utiliser la documentation en ligne86 en complément des informations principales détaillées ici.\nL’exemple utilisé ici est le site personnel de l’auteur87.La méthode de travail consiste à progresser pas à pas en testant puis validant chaque étape :effectuer les modifications ;construire le site et vérifier le résultat : blogdown:::serve_site() ;arrêter le site : blogdown::stop_server() ;si le résultat n’est pas satisfaisant, recommencer ;valider les modifications (commit).","code":""},{"path":"chap-rediger.html","id":"page-daccueil","chapter":"4 Rédiger","heading":"4.7.6.1 Page d’accueil","text":"La page d’accueil du site est constituée par une suite d’éléments (widgets) qui se trouvent dans /contents/<langue>/home.\nChaque élément est décrit par un fichier markdown.\nLe premier est index.md.\nIl n’est normalement jamais modifié.\nSon contenu est le suivant :Le fichier ne contient qu’un entête au format TOML, encadré par une ligne de +++.\nLe type de composant (type) indique qu’il s’agit d’une page de composants, dans laquelle les autres composants du dossier trouveront leur place.\nheadless = true signifie que la page n’pas d’en-tête.\nFigure 4.6: Composant demo dans Academic.\nLe composant demo.md (figure 4.6) est un composant de type “blank”, c’est-à-dire une page de texte libre : il sert ici à présenter le modèle Academic Kickstart et doit donc être désactivé.\nL’entête contient ses informations de formatage (titre, nombre de colonnes, couleurs…) et le contenu de la page est écrit en markdown.\nLes composants apparaissent par ordre croissant de poids (weight dans l’entête) : 15 marque le premier composant dans le modèle Academic.\nLe composant peut être désactivé en supprimant son fichier ou en modifiant sa propriété active dans l’entête :\nFigure 4.7: Composant dans Academic.\nLe composant suivant est .md (figure 4.7).\nIl présente le propriétaire du site.\nSon titre doit être localisé.\nDans le dossier /content/fr/home, sa valeur sera :L’auteur (author) doit correspondre à un dossier de /contents/<langue>/authors.\nadmin convient parfaitement pour un site personnel.\nAcademic permet de créer des sites d’équipes : dans cette configuration, un dossier par personne serait nécessaire.\nL’image affichée par le composant est le fichier avatar.jpg placé dans ce dossier.\nLimiter la taille du fichier pour la performance du site (moins d’un mégaoctet est une taille raisonnable), tout en assurant une taille minimale de quelques centaines de pixels de côté pour la qualité de l’affichage.Le contenu du composant est lu dans le fichier _index.md du même dossier, qui contient toutes les informations sur l’auteur.\nSon organisation est assez claire : modifier son contenu à partir de l’exemple fourni.\nSi des icônes de type ai sont utilisées, activer le pack d’icône Academicons dans config/_default/params.toml.\nFigure 4.8: Composant skills dans Academic.\nLe composant talents (skills, figure 4.8) présente les compétences de l’auteur de façon graphique.\nUne collection d’icônes est disponible, et des icônes nouvelles peuvent être ajoutées.\nFigure 4.9: Composant experience dans Academic.\nLe composant expérience (experience, figure 4.9) liste les expériences professionnelles.\nToutes les informations sont saisies dans son entête.Le composant accomplishments présente les formations professionnelles et permet d’accéder à leurs certificats.Le composant posts va chercher son contenu dans le dossier /contents/<langue>/post qui contient les billets de blog (voir plus bas).\nLe fichier posts.md contient des options de mise en page dans son entête.Le composant projects fonctionne de la même façon.\nLa différence entre les deux composants est leur mise en forme : posts est du type “pages”, qui affiche les éléments les plus récents, alors que projects est de type “portfolio”, qui affiche les éléments sélectionnés qui contiennent la description featured: true dans leur propre entête.\nIl est possible de créer des composants de ces types librement, en spécifiant le dossier contenant les éléments dans “page-type”.\nExemple : créer un composant nommé software.md en renommant projects.md, modifier sa ligne page_type = \"software\" et créer un dossier /contents/<langue>/software pour y placer du contenu.Les composants publications et featured sont de type “pages” et “portfolio” respectivement et prennent leur contenu dans le dossier publication.Le composant tags présente un nuage de mots à partir des mots-clés déclarés dans tous les fichiers de contenu (billets de blog, publications…) sous la forme suivante dans leur entête :Enfin, le composant contact permet d’afficher un formulaire de contact.\nIl utilise les informations du fichier config/_default/params.toml dans sa partie commençant par :Pour afficher une carte, entrer la latitude et la longitude de l’adresse dans la ligne coordinates.\nPour afficher un formulaire de messagerie, choisir le service formspree.io (email_form = 2 dans contact.md).\nPour activer le service de messagerie, il faudra construire le site web, s’envoyer un premier message en utilisant le formulaire et suivre les instructions de Formspree.Le composant people est utilisé dans les sites collectifs pour présenter les membres.\nLe composant slider permet d’afficher un carrousel (des éléments défilants) en haut de page.\nPour comprendre son fonctionnement, le plus simple consiste à l’activer.","code":"+++\n# Homepage\ntype = \"widget_page\"\nheadless = true  # Homepage is headless, other widget \npages are not.\n+++active = false  # Activate this widget? true/falsetitle = \"Biographie\"tags = [\"Mot Clé 1\", \"Autre Mot Clé\"]############################\n## Contact details\n##"},{"path":"chap-rediger.html","id":"menu-de-la-page-daccueil","chapter":"4 Rédiger","heading":"4.7.6.2 Menu de la page d’accueil","text":"La page d’accueil comporte un menu qui permet de naviguer rapidement vers ses composants ou vers d’autres pages.\nIl est paramétré dans config/_default/menus.toml.\nLes éléments du menu ont un nom affiché, un lien (commençant par # pour pointer vers un composant ou un chemin relatif dans le site comme publication/), et un poids qui définit leur ordre d’affichage, de la même façon que celui des composants de la page d’accueil.Un menu à deux éléments pour pointer vers l’accueil du site et les billets de blogs est donc le suivant :Le menu doit être traduit dans chaque langue dans le fichier config/_default/languages.toml :","code":"[[main]]\n  name = \"Home\"\n  url = \"#about\"\n  weight = 10\n\n[[main]]\n  name = \"Posts\"\n  url = \"#posts\"\n  weight = 20[fr]\n  [[fr.menu.main]]\n    name = \"Accueil\"\n    url = \"#about\"\n    weight = 10\n  [[fr.menu.main]]\n    name = \"Articles\"\n    url = \"#posts\"\n    weight = 20"},{"path":"chap-rediger.html","id":"billets","chapter":"4 Rédiger","heading":"4.7.6.3 Billets","text":"Le site est alimenté par des billets de blog placés dans le dossier /contents/<langue>/post.\nIl doivent être traduits et placés dans le dossier post de chaque langue pour être disponibles dans la langue correspondante.\nL’exemple utilisé ici est un guide pour estimer correctement la densité d’une variable bornée88.Son code est sur GitHub89.Un billet est placé dans un dossier (/content/fr/post/densite) qui contient son code R Markdown et éventuellement des images, des données pour alimenter le code et d’autres éléments appelés par le code.\nHugo supporte des fichiers markdown natifs.\nL’apport de blogdown relativement à un site Hugo natif est le support de R Markdown, donc la possibilité d’exécuter tout code R comme dans un bloc-note (dont le contenu peut être réutilisé sans modification).Le fichier principal d’un billet est index.Rmd.\nblogdown crée un fichier index.html pendant la construction du site : il peut être ignoré (dans .gitgnore) et supprimé à tout moment.\nSi une image featured.png (optimale pour un schéma) ou featured.jpg (optimale pour un photo) est placée dans le dossier, elle sera utilisée comme vignette du billet.index.Rmd comprend un entête au format yaml (entourée par des ---) ou toml (entourée par des +++) qui décrit son affichage :Les auteurs sont utilisés dans les sites collectifs.\nLes tags permettent d’alimenter le composant nuage de mots s’il est activé dans la page d’accueil.\nLes catégories permettent de rechercher des pages au contenu similaire (recherche par mot-clé sur le site).\nL’option featured: true fait apparaître le billet dans les composants de type featured sur la page d’accueil.\nL’option draft: true cache le billet.Les éléments suivants précisent l’affichage de la vignette : légende et position.\nL’option preview_only: true limite l’affichage aux miniatures (sur la page d’accueil), retirant donc l’image du billet lui-même.Les éléments d’entête nécessaires au corps de texte R Markdown, comme le nom du fichier contenant les références bibliographiques, placé dans le même dossier, sont ajoutés.Le corps du texte est celui d’un document R Markdown standard, avec du code R inclus.\nUn bout de code initial permet de fixer les options de R et charger les packages nécessaires.En pratique, la façon la plus efficace de créer un nouveau billet est de copier le dossier complet d’un billet précédent, de le renommer et de modifier son contenu.\nLa commande blogdown::new_post() peut aussi être utilisée mais ne gère pas les langues multiples (et crée donc le billet dans le dossier /contents/post à moins de préciser l’argument subdir).La reconstruction du site ne met par défaut pas à jour les pages basées sur un fichier .Rmd.\nPour le faire, il faut forcer la commande build_site().","code":"---\ntitle: \"Titre du billet\"\nsubtitle: \"Sous-titre\"\nsummary: \"Résumé\"\nauthors: []\ntags: [\"Mot Clé 1\", \"Autre Mot Clé\"]\ncategories: []\ndate: 2020-04-17\nfeatured: false\ndraft: false\n\n# Featured image\n# To use, add an image named `featured.jpg/png` to \n# your page's folder.\n# Focal points: Smart, Center, TopLeft, Top, TopRight,\n# Left, Right, BottomLeft, Bottom, BottomRight.\nimage:\n  caption: \"\"\n  focal_point: \"\"\n  preview_only: false\n  \nbibliography: references.bib\n---\nblogdown::build_site(build_rmd = TRUE)\nblogdown::serve_site()"},{"path":"chap-rediger.html","id":"publications","chapter":"4 Rédiger","heading":"4.7.6.4 Publications","text":"Les publications sont organisées comme les billets, mais placées dans le dossier /contents/<langue>/publications.L’exemple utilisé est un article de revue90 avec son code91.Un fichier cite.bib contenant la référence au format BibTeX est placé dans le dossier.\nLe nom du dossier est de préférence celui de l’identifiant de la publication.\nL’entête du fichier index.md (ici au format Markdown, mais .Rmd est possible si du code R est nécessaire) contient les mêmes informations que le fichier BibTeX, mais au format approprié (yaml), et les éléments propres à Academic (featured) :Les types de publication sont :0 = Uncategorized ;1 = Conference paper ;2 = Journal article ;3 = Preprint / Working Paper ;4 = Report ;5 = Book ;6 = Book section ;7 = Thesis ;8 = Patent.Des boutons sont affichés en haut de la page de la publication en fonction des informations trouvées :PDF : si la ligne url est présente dans l’en-tête ;Citation : si le fichier cite.bib est présent dans le dossier ;DOI : si la ligne doi est présente dans l’en-tête.Le corps de la publication contient un lien (au format HTML) vers le site Dimension qui fournit des informations bibliométriques.\nCe lien peut être réutilisé très simplement, en remplaçant simplement le DOI du document :Enfin, un fichier /contents/<langue>/publications/_index.Rmd permet de présenter la bibliographie complète.\nIl est accessible à partir du composant publications de la page d’accueil qui affiche un lien “Plus de Publications”.Le fichier exemple92 avec son code93 permet d’interroger Google Scholar pour obtenir le réseau de coauteurs, l’indice h et le nombre de citations annuelles de l’auteur.\nIl est réutilisable en modifiant simplement l’identifiant Google Scholar à la ligne 30.En faisant exécuter le code régulièrement, par exemple par GitHub (voir ci-dessous), les statistiques affichées sont maintenues à jour sans intervention humaine.","code":"---\ntitle: \"Evaluating the geographic concentration of |>\nindustries using distance-based methods\"\nauthors: [\"Eric Marcon\", \"Florence Puech\"]\npublication_types: [\"2\"]\nabstract: \"We propose (...)\"\npublication: \"*Journal of Economic Geography*\"\ndoi: \"10.1093/jeg/lbg016\"\n\ndate: 2003-10-01\nfeatured: false\n---<span class=\"__dimensions_badge_embed__\" \n  data-doi=\"10.1093/jeg/lbg016\"><\/span>\n<script async src=\"https://badge.dimensions.ai/\n  badge.js\" charset=\"utf-8\"><\/script>"},{"path":"chap-rediger.html","id":"communications","chapter":"4 Rédiger","heading":"4.7.6.5 Communications","text":"Les communications sont organisées comme les publications, dans le dossier /contents/<langue>/talk.L’exemple utilisé est une communication en Français, donc dans /contents/fr/talk94 avec son code95.Une image peut être utilisée plus facilement que pour une publication.L’entête contient des lignes particulières adaptées aux communications :Les liens (url_code par exemple) font apparaître des boutons qui permettent d’afficher respectivement le code source de la présentation, un fichier pdf et les diapositives en ligne.","code":"---\ntitle: \"Construction de l'estimateur de biodiversité |>\nChao1\"\nevent: \"Semaine des mathématiques 2020\"\nevent_url: https://eduscol.education.fr/cid59178/|>\nsemaine-des-mathematiques.html\n\nlocation: Université de Guyane\n\nsummary: []\nabstract: |\n  Pour estimer le nombre d’espèces (richesse \n  spécifique) d’une communauté à partir d’un \n  échantillon, l’estimateur Chao1 est l’outil \n  le plus utilisé.\n\n  Sa construction est expliquée et son efficacité\n  est testée sur des données simulées.\n\n# Talk start and end times.\n#   End time can optionally be hidden by \n# prefixing the line with `#`.\ndate: \"2020-03-11T11:00:00Z\"\ndate_end: \"2020-03-11T12:00:00Z\"\nall_day: false\n\n# Schedule page publish date (NOT talk date).\npublishDate: \"2020-04-14\"\n\n# Is this a featured talk? (true/false)\nfeatured: false\n\nimage:\n  caption: 'Produit scalaire des vecteurs $v_0$ |>\net $v_2$'\n  focal_point: Smart\n\nurl_code: \"https://github.com/EricMarcon/Chao1\"\nurl_pdf: \"https://EricMarcon.github.io/Chao1/|>\nChao1.pdf\"\nurl_slides: \"https://EricMarcon.github.io/Chao1/|>\nChao1.html\"\n\n# Enable math on this page?\nmath: true\n---"},{"path":"chap-rediger.html","id":"autres-éléments","chapter":"4 Rédiger","heading":"4.7.6.6 Autres éléments","text":"Il est possible d’ajouter librement des éléments supplémentaires sur le site :dans /contents/<langue>/, créer un dossier dont le nom est le type d’éléments (exemple : recette) ;ajouter des éléments dans ce dossier, chacun dans son propre dossier ;le fichier obligatoire est index.md ou index.Rmd avec un en-tête contenant possiblement tous les champs rencontrés dans les éléments post, publication et talk ;le fichier de vignette, featured.png ou featured.jpg, est facultatif ;tous les fichiers nécessaires au tricot (images, données) peuvent être ajoutés dans le même dossier ;dans /contents/<langue>/home, ajouter un composant de la page d’accueil en copiant-collant un élément existant de type “pages” (comme publications) ou “portfolio” (comme featured) et le paramétrer pour qu’il pointe sur le bon dossier (dans l’exemple : page-type=recette) et ajuster son apparence (nombre d’éléments par exemple) et sa position (poids) ;ajouter éventuellement une entrée de menu pour pointer sur le composant, avec le même poids que le composant.Les fichiers d’index peuvent porter l’extension .Rmd ou .md.\nDans le premier cas, ils seront traités par blogdown, qui supporte l’intégration de code R.\nDans l’autre cas, ils seront traités par Hugo, qui ne gère que le format markdown standard.\nLes fichiers .md nécessitent moins de ressource et sont donc préférés quand ils suffisent.","code":""},{"path":"chap-rediger.html","id":"finitions-1","chapter":"4 Rédiger","heading":"4.7.6.7 Finitions","text":"L’icône du site, qui apparaît dans la barre d’adresse des navigateurs web, se trouve dans assets/images.\nLe fichier icon.png peut être remplacé.","code":""},{"path":"chap-rediger.html","id":"sec:rediger-web-ci","chapter":"4 Rédiger","heading":"4.7.7 Intégration continue","text":"La construction du site web en production peut être confiée à GitHub (section 6.3.2), y compris sa mise à jour périodique si des pages du site traitent des données qui évoluent dans le temps.","code":""},{"path":"chap-rediger.html","id":"mises-à-jour-1","chapter":"4 Rédiger","heading":"4.7.8 Mises à jour","text":"Le thème Academic est régulièrement mis à jour.\nLa version utilisée est indiquée dans le fichier go.mod.\nPour utiliser la dernière version officielle, exécuter dans la console R la commande suivante :Les fichiers go.mod et go.sum, qui contient les codes de hachage des fichiers du module, sont mis à jour.Chaque changement de version peut nécessiter des adaptations du contenu du site, référencées dans la documentation en ligne du thème96.Mettre Hugo à jour en même temps :","code":"\nblogdown::hugo_cmd(\"mod get -u\")\nblogdown::update_hugo()"},{"path":"chap-rediger.html","id":"exportation-de-figures","chapter":"4 Rédiger","heading":"4.8 Exportation de figures","text":"Quand la production de documents avec R Markdown n’est pas possible, les figures issues de R doivent être exportées sous forme de fichiers pour être intégrés dans un autre processus d’écriture.\nIl est préférable de créer des scripts pour créer les figures de façon reproductible et au format optimal.","code":""},{"path":"chap-rediger.html","id":"formats-vectoriels-et-raster","chapter":"4 Rédiger","heading":"4.8.1 Formats vectoriels et raster","text":"Les figures doivent en général être produites dans un format vectoriel :SVG pour la publication d’affiches ou de posters ;EMF (Extended Meta-File) pour Word ou la suite Microsoft Office qui ne supporte pas d’autres formats ;EPS (Encapsulated PostScript) ou PDF (Portable Document Format) pour LaTeX.Les figures raster (composées d’un ensemble de points, comme les photographies) sont rares dans R.\nLa fonction image() utilisée pour afficher des cartes utilise par défaut des polygones plutôt que des points.\nLa figure 4.10 montre le résultat du code suivant :\nFigure 4.10: Courbes de niveau du volcan Maunga Whau, code fourni en exemple de l’aide de la fonction image().\nElle est composée d’un ensemble de rectangles colorés : il s’agit bien d’une image vectorielle.Si nécessaire, des images peuvent être produites aux formats BMP (bitmap, sans compression), JPEG (compressées avec perte de qualité), PNG (compressées sans perte de qualité, avec transparence possible) ou Tiff (compressées ou non).","code":"\nx <- 10 * (1:nrow(volcano))\ny <- 10 * (1:ncol(volcano))\nimage(x, y, volcano, col = hcl.colors(100, \"terrain\"), axes = FALSE)\ncontour(x, y, volcano, levels = seq(90, 200, by = 5), add = TRUE,\n    col = \"brown\")\naxis(1, at = seq(100, 800, by = 100))\naxis(2, at = seq(100, 600, by = 100))\nbox()"},{"path":"chap-rediger.html","id":"fonctions","chapter":"4 Rédiger","heading":"4.8.2 Fonctions","text":"Les graphiques produits par ggplot() peuvent être sauvegardés dans un fichier par la fonction ggsave().\nL’extension du nom du fichier définit son format.\nVoir l’aide de la fonction pour plus de détails.Les autres graphiques nécessitent une méthode différente.\nLa fonction postscript() produit un fichier EPS.\nLe code R doit appeler la fonction pour créer le fichier, produire la figure, puis fermer le fichier, par exemple :La largeur et la hauteur (en pouces) d’un fichier vectoriel n’ont pas d’importance, mais leur rapport fixe l’aspect de la figure.\nLa taille des textes est fixe : augmenter la taille de la figure revient donc à diminuer la taille relative des textes : procéder par essais successifs, en veillant à ce que les légendes restent lisibles à la taille finale de la figure.L’argument horizontal fixe l’orientation de la figure de façon assez imprévisible : procéder par essais.Les fonctions eps(), pdf(), bmp(), jpeg(), png() et tiff() fonctionnent de la même manière.\nSe référer à l’aide des fonctions pour le choix des options (résolution, niveau de compression, etc.).\nLa fonction emf() est fournie par le package devEMF.Les polices de caractères ne sont pas incluses dans les fichiers EPS ou PDF.\nSi nécessaire, la fonction embedFonts() permet d’y remédier, à condition que GhostScript soit installé.","code":"\n# Ouverture du fichier\npostscript(\"Fig1.eps\", width = 6, height = 4, horizontal = FALSE)\n# Création de la figure\nplot(cars)\n# Fermeture du fichier\ndev.off()## pdf \n##   2"},{"path":"chap-rediger.html","id":"package-ragg","chapter":"4 Rédiger","heading":"4.8.3 Package ragg","text":"Le package ragg97 améliore la qualité des fichiers PNG, JPEG et TIFF.\nLes fonctions optimisées sont agg_png(), agg_jpeg()et agg_tiff(). Leur usage est le même que celui des fonctions de grDevices.Les documents R Markdown produisent des images au format PNG pour leur version HTML.\nragg améliore leur qualité : le package doit être installé et dev = \"ragg_png\" doit être ajoutée aux options de knitr.\nPour ce document, les options déclarées dans index.Rmd sont les suivantes :Enfin, ragg peut être utilisé comme moteur de rendu graphique par défaut dans RStudio à partir de la version 1.4 (Menu “Tools > Global Options > General > Graphics > Backend”).","code":"\nknitr::opts_chunk$set(\n  cache=FALSE, # Cache chunk results\n  echo = TRUE, # Show/Hide R chunks\n  warning=FALSE, # Show/Hide warnings\n  # Figure alignment and size\n  fig.align='center', out.width='80%', fig.asp=.75,\n  # Graphic devices (ragg_png is better than standard png)\n  dev = c(\"ragg_png\", \"pdf\"),\n  # Code chunk format\n  tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=60),\n  size=\"scriptsize\", knitr.graphics.auto_pdf = TRUE\n  )\noptions(width=60)"},{"path":"chap-rediger.html","id":"sec:targetsmd","chapter":"4 Rédiger","heading":"4.9 Flux de travail","text":"Un flux de travail (voir section 2.8) peut être intégré dans un document R Markdown à partir de la version 0.5 du package targets.","code":"\nlibrary(\"targets\")"},{"path":"chap-rediger.html","id":"déclaration-du-flux","chapter":"4 Rédiger","heading":"4.9.1 Déclaration du flux","text":"Le flux est géré par des bouts de code de type targets.\nLeur entête minimal est targets au lieu de {r}, et ils doivent être nommés.\nCes bouts de code permettent de créer le fichier _targets.R quand ils sont exécutés en mode non interactif, notamment pendant que le document est tricoté.\nS’ils sont lancés en mode interactif, par exemple dans R Studio, leur code est exécuté.\nL’option tar_interactive = FALSE dans leur entête permet de les tester sans tricoter tout le document.Un ancien flux éventuel doit être supprimé avant d’écrire le nouveau :Le premier bout de code, avec l’option tar_globals=TRUE, écrit les options globales du flux.\nPour créer le flux présenté en section 2.8, le code est simplement :Les fonctions utilisées par les cibles sont déclarées dans ce type de bout de code : elles sont ajoutées à un fichier dans le dossier de travail _targets_r (différent du dossier _targets qui contient les fichiers de calcul des cibles).","code":"\ntar_unscript()```{targets targets_global, tar_globals=TRUE}\n# Packages\ntar_option_set(packages = c(\"spatstat\", \"dbmss\"))\n```"},{"path":"chap-rediger.html","id":"déclaration-des-cibles","chapter":"4 Rédiger","heading":"4.9.2 Déclaration des cibles","text":"Les cibles elles-mêmes sont déclarées dans des bouts de code dont le nom est celui de la variable de destination.Chaque cible nécessite un bout de code construit de cette manière.\nLa valeur de la cible est la dernière valeur retournée, à la manière d’une fonction qui n’utiliserait pas return().Pendant le tricot, ce code simplifié (tar_simple=TRUE) est transformé automatiquement en écriture de cible :La lecture du document est alourdie par cette syntaxe particulière : targets n’est pas utile pour des documents dont le code, rapide à exécuter, doit être affiché dans le texte.\nEn revanche, si le code est long à exécuter et n’est pas affiché, son intérêt est considérable pour limiter le temps de calcul.Les autres bouts de code nécessaires pour compléter le flux sont les suivants :NbPoints :d :map :","code":"```{targets X, tar_simple=TRUE}\nrunifpoint(NbPoints)\n```\ntar_target(X, {\n  runifpoint(NbPoints)\n})## Define target X from chunk code.\n## Establish _targets.R and _targets_r/targets/X.R.\ntar_target(NbPoints, {\n    1000\n})## Define target NbPoints from chunk code.\n## Establish _targets.R and _targets_r/targets/NbPoints.R.\ntar_target(d, {\n    sum(pairdist(X))/NbPoints/(NbPoints-1)\n})## Define target d from chunk code.\n## Establish _targets.R and _targets_r/targets/d.R.\ntar_target(map, {\n    autoplot(as.wmppp(X))\n})## Define target map from chunk code.\n## Establish _targets.R and _targets_r/targets/map.R."},{"path":"chap-rediger.html","id":"exécution-du-flux","chapter":"4 Rédiger","heading":"4.9.3 Exécution du flux","text":"Pour lancer le calcul des cibles, un bout de code standard ({r}) doit appeler tar_make() :tar_visnetwork() permet de vérifier que le flux est correct avant de l’exécuter.\nAu moment de la production finale du document, l’option include=FALSE peut être ajoutée à l’entête de ce bout de code pour qu’il ne produise aucun affichage.","code":"\ntar_visnetwork()\ntar_make()## ▶ dispatched target NbPoints\n## ● completed target NbPoints [0.656 seconds, 53 bytes]\n## ▶ dispatched target X\n## ● completed target X [0.001 seconds, 11.058 kilobytes]\n## ▶ dispatched target d\n## ● completed target d [0.007 seconds, 55 bytes]\n## ▶ dispatched target map\n## ● completed target map [0.014 seconds, 187.39 kilobytes]\n## ▶ ended pipeline [0.77 seconds]"},{"path":"chap-rediger.html","id":"utilisation-des-résultats","chapter":"4 Rédiger","heading":"4.9.4 Utilisation des résultats","text":"Les bouts de code qui utilisent les valeurs des cibles doivent les lire avec tar_read() :","code":"\ntar_read(map)"},{"path":"chap-rediger.html","id":"contrôle-de-source","chapter":"4 Rédiger","heading":"4.9.5 Contrôle de source","text":"Les fichiers de targets doivent être inclus au contrôle de source.\nDe cette façon, les calculs effectués localement ne seront pas répétés par GitHub Actions (chapitre 6) et la construction du document sera rapide.","code":""},{"path":"chap-package.html","id":"chap-package","chapter":"5 Package","heading":"5 Package","text":"Les packages de R permettent d’étendre les fonctionnalités du logiciel par du code fourni par la communauté des développeurs.\nIls sont la clé du succès de R parce qu’ils permettent de diffuser rapidement de nouvelles méthodes issues de la recherche ou d’ajouter de nouveaux outils qui peuvent devenir des standards, comme le tidyverse.Il est utile de produire un package quand écrit des nouvelles fonctions qui forment un ensemble cohérent.\nUn package à usage personnel ou limité à une équipe de travail est simple à mettre en place et le temps gagné en utilisant facilement la version à jour de chaque fonction amortit très rapidement le temps consacré à la fabrication du package.\nCe type de package vocation à être hébergé sur GitHub.Des packages à usage plus large, qui fournissent par exemple le code correspondant à une méthode publiée, sont placés dans le dépôt CRAN, d’où ils pourront être installés par la commande standard install.packages().\nCRAN effectue des vérifications poussées du code et n’accepte que les packages passant sans aucun avertissement sa batterie de tests.\nIls doivent respecter la politique98 du dépôt.La documentation pour la création de packages est abondante.\nL’ouvrage de référence est celui de Wickham (2015), à consulter en tant que référence.L’approche utilisée ici consiste à créer un premier package très rapidement pour comprendre que la démarche est assez simple.\nIl sera ensuite enrichi des éléments nécessaires à un package diffusé à d’autres utilisateurs que son concepteur : une documentation complète et des tests de bon fonctionnement notamment.","code":""},{"path":"chap-package.html","id":"premier-package","chapter":"5 Package","heading":"5.1 Premier package","text":"Cette introduction reprend les recommandations du blog Créer un package en quelques minutes99 de ThinkR.","code":""},{"path":"chap-package.html","id":"création","chapter":"5 Package","heading":"5.1.1 Création","text":"Les packages ont une organisation stricte dans une structure de fichiers et de répertoires figée.\nIl est possible de créer cette structure manuellement mais des packages spécialisés peuvent s’en charger :usethis automatise la création des dossiers ;roxygen2 permet d’automatiser la documentation obligatoire des packages ;devtools est la boîte à outils du développeur, permettant notamment de construire et tester les packages ;Les trois sont à installer en premier lieu :Le package à créer sera un projet RStudio.\nDans le menu des projets, sélectionner “New Project > New Directory > R package using devtools…”, choisir le nom du projet et son dossier parent.\nLe package s’appellera multiple, dans le dossier %LOCALAPPDATA%\\ProjetsR en suivant les recommandations de la section 1.2.4.Le nom du package doit respecter les contraintes des noms de projets : pas de caractères spéciaux, pas d’espaces…\nIl doit aussi être évocateur de l’objet du package.\nSi le package doit être diffusé, toute sa documentation sera rédigée en Anglais, y compris son nom.La structure minimale est crée :un fichier DESCRIPTION qui indique que le dossier contient un package et précise au minimum son nom ;un fichier NAMESPACE qui déclare comment le package intervient dans la gestion des noms des objets de R (son contenu sera mis à jour par roxygen2) ;un dossier R qui contient le code des fonctions offertes par le package (vide à ce stade).Le package peut être testé tout de suite : dans la fenêtre Build de RStudio, cliquer sur “Install Restart” construit le package et le charge dans R, après avoir redémarré le programme pour éviter tout conflit.Dans la fenêtre Packages, multiple est maintenant visible.\nIl est chargé, mais ne contient rien.","code":"\ninstall.packages(c(\"usethis\", \"roxygen2\", \"devtools\"))"},{"path":"chap-package.html","id":"première-fonction","chapter":"5 Package","heading":"5.1.2 Première fonction","text":"","code":""},{"path":"chap-package.html","id":"fichiers","chapter":"5 Package","heading":"5.1.2.1 Fichiers","text":"Les fonctions sont placées dans un ou plusieurs fichier .R dans le dossier R.\nL’organisation de ces fichiers est libre.\nPour cet exemple, un fichier du nom de chaque fonction sera créé.\nDes fichiers regroupant les fonctions similaires ou un seul fichier contenant tout le code sont des choix possibles.Le choix fait ici est le suivant :un fichier qui contiendra le code commun à tout le package : package.R ;un fichier commun à toutes les fonctions : fonctions.R.","code":""},{"path":"chap-package.html","id":"création-1","chapter":"5 Package","heading":"5.1.2.2 Création","text":"La première fonction, double(), est créée et enregistrée dans le fichier fonctions.R :ce stade, la fonction est interne au package et n’est pas accessible depuis l’environnement de travail.\nPour s’en persuader, construire le package (Install Restart) et vérifier le bon fonctionnement de la fonction :Le résultat est un vecteur composé de deux 0 parce que la fonction appelée est un homonyme du package base (voir sa documentation en tapant ?double) :Pour que la fonction de notre package soit visible, elle doit être exportée en la déclarant dans le fichier NAMESPACE.\nC’est le travail de roxygen2 qui gère en même temps la documentation de chaque fonction.\nPour l’activer, placer le curseur dans la fonction et appeler le menu “Code > Insert Roxygen Skeleton”.\nDes commentaires sont ajoutés avant la fonction :Les commentaires à destination de roxygen2 commencent par #' :la première ligne contient le titre de la fonction, c’est-à-dire un descriptif très court : son nom en général ;la ligne suivante (séparée par un saut de ligne) peut contenir sa description (rubrique Description dans l’aide) ;la suivante (après un autre saut de ligne) peut contenir plus d’informations (rubrique Details dans l’aide) ;les arguments de la fonction sont décrits par les lignes @param ;@return décrit le résultat de la fonction ;@export déclare que la fonction est exportée : elle sera donc utilisable dans l’environnement de travail ;des exemples peuvent être ajoutés.La documentation doit être complétée :Ne pas hésiter à s’inspirer de l’aide de fonctions existantes pour respecter les standards de R (ici : ?log) :penser que les fonctions sont normalement vectorielles : number est par défaut un vecteur, pas un scalaire ;certains éléments commencent par une majuscule et se terminent par un point parce que ce sont des paragraphes dans le fichier d’aide ;le titre n’pas de point final ;la description des paramètres ne commence pas par une majuscule.La prise en compte des changements dans la documentation nécessitent d’appeler la fonction roxygenize().\nDans la fenêtre Build, le menu “> Document” permet de le faire.\nEnsuite, construire le package (Install Restart) et vérifier le résultat en exécutant la fonction et en affichant son aide :Il est possible d’automatiser la mise à jour de la documentation à chaque construction du package par le menu “Build > Configure Build Tools…” : cliquer sur “Configure” et cocher la case “Automatically reoxygenize running Install Restart”.\nC’est un choix efficace pour un petit package mais pénalisant quand le temps de mise à jour de la documentation s’allonge avec la complexité du package. La reconstruction du package est le plus souvent utilisée pour tester des modifications du code : sa rapidité est essentielle.La documentation pour roxygen2 supporte le format Markdown100.ce stade, le package est fonctionnel : il contient une fonction et un début de documentation.\nIl est temps de lancer une vérification de son code : dans la fenêtre Build, cliquer sur “Check” ou utiliser la commande devtools::check().\nL’opération réoxygène le package (met à jour sa documentation), effectue un grand nombre de tests et renvoie la liste des erreurs, avertissements et notes détectées.\nL’objectif est toujours de n’avoir aucune alerte : elles doivent être traitées immédiatement.\nPar exemple, le retour suivant est un avertissement sur la non-conformité de la licence déclarée :Pour la corriger, mettre à jour, exécuter la commande de mise à jour de la licence, en commençant par votre nom :La liste des licences valides est fournie par R101.Après correction, relancer les tests jusqu’à la disparition des alertes.","code":"\ndouble <- function(number) {\n    return(2 * number)\n}\ndouble(2)\nbase::double(2)## [1] 0 0\n#' Title\n#'\n#' @param number \n#'\n#' @return\n#' @export\n#'\n#' @examples\ndouble <- function(number) {\n    return(2 * number)\n}\n#' double\n#' \n#' Double value of numbers.\n#'\n#' Calculate the double values of numbers.\n#' \n#' @param number a numeric vector.\n#'\n#' @return A vector of the same length as `number` containing the \n#'   transformed values.\n#' @export\n#'\n#' @examples\n#' double(2)\n#' double(1:4)\ndouble <- function(number) {\n    return(2 * number)\n}\ndouble(2)\n`?`(double)> checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_gpl3_license()`\n  Standardizable: FALSE\n\n0 errors v | 1 warning x | 0 notes v\nErreur : R CMD check found WARNINGs\noptions(usethis.full_name = \"Eric Marcon\")\nusethis::use_gpl3_license()"},{"path":"chap-package.html","id":"sec:package-cds","chapter":"5 Package","heading":"5.1.3 Contrôle de source","text":"Il est temps de placer le code sous contrôle de source.Activer le contrôle de source dans les options du projet (figure 3.2).\nRedémarrer RStudio à la demande.Créer un dépôt sur GitHub et y pousser le dépôt local, comme expliqué dans le chapitre 3.Créer le fichier README.md :Le développement du package est ponctué par de nombreux commits à chaque modification et une publication (push) à chaque étape, validée par une incrémentation du numéro de version.","code":"# multiple\n\nAn R package to compute mutiple of numbers."},{"path":"chap-package.html","id":"package.r","chapter":"5 Package","heading":"5.1.4 package.R","text":"Le fichier package.R est destiné à recevoir le code R et surtout les commentaires pour roxygen2 qui concernent l’ensemble du package.\nCe fichier peut aussi être nommé multiple-package.R, en préfixant son nom par celui du package, par souci de compatibilité avec usethis.\nIl peut d’ailleurs être créé sous ce nom par la commande :Le premier bloc de commentaire fournira l’aide du package (?multiple).Le mot-clé “_PACKAGE” indique que la documentation du package doit être produite.\nElle pourrait être écrite dans le bloc, avec une syntaxe identique à celle des fonctions, mais son contenu par défaut est celui du champ Description du fichier DESCRIPTION.\nLe mot clé internal masque la documentation du package dans le sommaire de son aide.La documentation est mise à jour par la commande roxygen2::roxygenise().\nAprès reconstruction du package, vérifier que l’aide est est apparue : ?multiple.","code":"\nusethis::use_package_doc()#' @keywords internal \n\"_PACKAGE\""},{"path":"chap-package.html","id":"organisation-du-package","chapter":"5 Package","heading":"5.2 Organisation du package","text":"","code":""},{"path":"chap-package.html","id":"sec:package-description","chapter":"5 Package","heading":"5.2.1 Fichier DESCRIPTION","text":"Le fichier doit être complété :Le nom du package est figé et ne doit pas être modifié.Son titre doit décrire en une ligne à quoi il sert.\nLe titre est affiché dans la fenêtre Packages à côté des noms des packages.La version doit respecter les conventions :Le premier nombre est la version majeure, 0 tant que le package n’est pas stable puis 1.\nLa version majeure ne change que si le package n’est plus compatible avec ses versions précédentes, ce qui oblige les utilisateurs à modifier leur code.Le deuxième est la version mineure, incrémentée quand des fonctionnalités nouvelles sont ajoutées.Le troisième est la version de correction : 0 à l’origine, incrémentée à chaque correction de code sans nouvelle fonctionnalité.Le quatrième est réservé au développement, et commence à 9000.\nIl est incrémenté à chaque version instable et disparaît quand une nouvelle version stable (release) est produite.Exemple : une correction de bug sur la version 1.3.0 produit la version 1.3.1.\nLes versions de développement suivantes (instables, non destinées à l’usage en production) sont 1.3.1.9000 puis 1.3.1.9001, etc.\nLe numéro de version doit être mis à jour à chaque fois que le package est poussé sur GitHub.\nQuand le développement est stabilisé, la nouvelle version, destinée à être utilisée en production, est 1.3.2 si elle n’apporte pas de nouvelle fonctionnalité ou 1.4.0 dans le cas contraire.La description des auteurs est assez lourde mais simple à comprendre.\nLes identifiants Orcid des auteurs académiques peuvent être utilisés.\nSi le package plusieurs auteurs, ils sont placés dans une fonction c() : c(person(...), person(...)) pour deux auteurs.\nDans ce cas, il faut préciser le rôle de chacun :“cre” pour le créateur du package ;“aut” pour un auteur parmi les autres ;“ctb” pour un contributeur, qui peut avoir signalé un bug ou fourni un peu de code.La description du package en un paragraphe permet de donner plus d’informations.La licence précise la façon dont le package peut être utilisé et modifié.\nGPL-3 est une bonne valeur par défaut, mais d’autres choix sont possibles102.L’option LazyData signifie que les données d’exemples fournies avec le package peuvent être utilisées sans les appeler au préalable par la fonction data() : c’est le standard actuel.Enfin, les deux dernières lignes sont gérées par roxygen2.","code":"Package: multiple\nTitle: Calculate multiples of numbers\nVersion: 0.0.0.9000\nAuthors@R: \n  person(given = \"Eric\",\n           family = \"Marcon\",\n           role = c(\"aut\", \"cre\"),\n           email = \"e.marcon@free.fr\",\n           comment = c(ORCID = \"0000-0002-5249-321X\"))\nDescription: Simple computation of multiples of numbers, \n  including fast algorithms for integers.\nLicense: GPL-3\nEncoding: UTF-8\nLazyData: true\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.1"},{"path":"chap-package.html","id":"fichier-news.md","chapter":"5 Package","heading":"5.2.2 Fichier NEWS.md","text":"Le fichier NEWS.md contient l’historique du package.\nLes nouvelles versions sont ajoutées en haut du fichier.Créer une première version du fichier :Les titres de premier niveau doivent contenir le nom du package et sa version.\nLes titres de niveau 2 sont libres, mais contiennent en général des rubriques comme “New features” et “Bug Fixes”.Pour ne pas multiplier les versions décrites, il est conseillé de modifier la version en cours et de compléter la documentation jusqu’au changement de version de correction (troisième nombre).\nEnsuite, l’entrée correspondant à cette version reste figée et une nouvelle entrée est ajoutée.","code":"# multiple 0.0.0.9000\n\n## New features\n\n* Initial version of the package"},{"path":"chap-package.html","id":"vignette","chapter":"5 Package","heading":"5.3 Vignette","text":"Une vignette est indispensable pour documenter correctement le package :Le fichier multiple.Rmd est créé dans le dossier vignettes.\nAjouter un sous-titre dans son entête : la description courte du package :Le reste de l’entête permet à R de construire la vignette à partir de code R Markdown.Le corps de la vignette contient par défaut du code R pour déclarer les options de présentation des bouts de code et le chargement du package.\nUne introduction à l’utilisation du package doit être écrite dans ce document, en R Markdown.Pendant le développement du package, la vignette peut être construite manuellement en exécutant :Les fichiers produits sont placés dans doc/ : ouvrir le fichier .html pour contrôler le résultat.RStudio ne crée pas la vignette du package quand la commande “Install Restart” de la fenêtre Build est appelée.\nPour une installation complète, deux solutions sont possibles :Construire le fichier source du package (“Build > > Build Source Package”) puis l’installer (“Packages > Install > Install > Package Archive file”).\nLe fichier source se trouve à côté de celui du projet.Pousser le code du package sur GitHub puis exécuter :La vignette peut ensuite être affichée par la commande :","code":"\nusethis::use_vignette(\"multiple\")title: \"multiple\"\nsubtitle: \"Multiples of numbers\"\ndevtools::build_vignettes(\"multiple\")\nremotes::install_github(\"multiple\", build_vignettes = TRUE)\nvignette(\"multiple\")"},{"path":"chap-package.html","id":"pkgdown","chapter":"5 Package","heading":"5.4 pkgdown","text":"Le package pkgdown permet de créer un site d’accompagnement du package103, qui reprend le fichier README.md comme page d’accueil, la vignette dans une rubrique “Get Started”, l’ensemble des fichiers d’aide avec leurs exemples exécutés (section “Reference”), le fichier NEWS.md pour un historique du package (section “Changelog”) et des informations du fichier DESCRIPTION.Créer le site avec usethis :Construire ensuite le site.\nCette commande sera exécutée à nouveau à chaque changement de version du package :Le site est placé dans le dossier docs.\nOuvrir le fichier index.htm avec un navigateur web pour le visualiser.\nDès que le projet sera poussé sur GitHub, activer les pages du dépôt pour que le site soit visible en ligne (voir section 3.7).pkgdown place le site dans le dossier docs.Ajouter l’adresse des pages GitHub dans une nouvelle ligne du fichier DESCRIPTION :L’ajouter aussi dans le fichier _pkgdown.yml qui été créé vide, ainsi que l’option suivante :pkgdown place le site dans le dossier docs/dev si le site d’une version stable (à trois nombres) du package existe dans docs et que la version en cours est une version de développement (à quatre nombres).\nDe cette façon, les utilisateurs d’une version de production du package ont accès au site sans qu’il soit perturbé par les versions de développement.Le site peut être enrichi de plusieurs façons :En ajoutant des articles au format R Markdown dans le dossier vignettes/articles.\nLa vignette ne peut pas mobiliser d’importantes ressources de calcul pour présenter des exemples parce qu’elle est construite en même temps que le package.\nLes articles sont générés par pkgdown, indépendamment, et peuvent donc être plus ambitieux ;En améliorant sa présentation (regroupement des fonctions par thèmes, ajout de badges, d’un sticker104…) : se référer à la vignette de pkgdown.Pour enrichir la documentation du package, il est possible d’utiliser un fichier README.Rmd au format R Markdown, à tricoter pour créer le README.md standard de GitHub, utilisé comme page d’accueil du site pkgdown, qui peut de cette façon présenter des exemples d’utilisation du code.\nLa démarche est détaillée dans R Packages105.\nLa complexité ajoutée est à comparer au gain obtenu : une page d’accueil simple (sans code) avec des liens vers la vignette et les articles est plus simple à mettre en œuvre.","code":"\nusethis::use_pkgdown()\npkgdown::build_site()URL: https://GitHubID.github.io/multipleurl: https://GitHubID.github.io/multiple\n\ndevelopment:\n  mode: auto"},{"path":"chap-package.html","id":"code-spécifique-aux-packages","chapter":"5 Package","heading":"5.5 Code spécifique aux packages","text":"","code":""},{"path":"chap-package.html","id":"importation-de-fonctions","chapter":"5 Package","heading":"5.5.1 Importation de fonctions","text":"Créons une nouvelle fonction dans fonctions.R qui ajoute un bruit aléatoire à la valeur double :Le bruit est tiré dans une loi normale centrée d’écart-type sd et ajouté à la valeur calculée.rnorm() est une fonction du package stats.\nMême si le package est systématiquement chargé par R, le package d’appartenance de la fonction doit obligatoirement être déclaré : les seules exceptions sont les fonctions du package base.Le package stats doit d’abord être déclaré dans DESCRIPTION qui contient une instruction Imports:.\nTous les packages utilisés par le code de multiple seront listés, séparés par des virgules.Cette “importation” signifie simplement que le package stats doit être chargé, mais pas nécessairement attaché (voir section 2.2), pour que multiple fonctionne.Ensuite, la fonction rnorm() doit être trouvable dans l’environnement du package multiple.\nIl y plusieurs façons de remplir cette obligation.\nD’abord, le commentaire suivant pourrait être fourni pour roxygen2 :Tout l’espace de nom du package stats serait attaché et accessible au package multiple.\nCe n’est pas une bonne pratique parce qu’elle multiplie les risques de conflits de noms (voir section 2.2).\nNotons que la notion d’importation utilisée ici est différente de celle de DESCRIPTION, bien qu’elles aient le même nom.Il est préférable d’importer uniquement la fonction rnorm() en la déclarant dans la documentation de la fonction :Ce n’est pas une pratique idéale non plus parce que l’origine de la fonction n’apparaîtrait pas clairement dans le code du package.La bonne pratique est de ne rien importer (au sens de roxygen2) et de qualifier systématiquement les fonctions d’autres packages avec la syntaxe package::fonction().\nC’est la solution retenue ici parce que la directive @importFrom importerait la fonction dans tout le package multiple, pas seulement dans la fonction fuzzydouble(), au risque de créer des effets de bord (modifier le comportement d’une autre fonction du package qui n’assumerait pas l’importation de rnorm()).\nFinalement, le code de la fonction est le suivant :","code":"\nfuzzydouble <- function(number, sd = 1) {\n    return(2 * number + rnorm(length(number), 0, sd))\n}Imports: stats\n#' @import stats\n#' @importFrom stats rnorm\n#' fuzzydouble\n#' \n#' Double value of numbers with an error\n#' \n#' Calculate the double values of numbers \n#' and add a random error to the result.\n#'\n#' @param number a numeric vector.\n#' @param sd the standard deviation of the Gaussian error added.\n#'\n#' @return A vector of the same length as `number`\n#'  containing the transformed values.\n#' @export\n#'\n#' @examples\n#' fuzzydouble(2)\n#' fuzzydouble(1:4)\nfuzzydouble <- function(number, sd = 1) {\n    return(2 * number + stats::rnorm(length(number), 0, sd))\n}"},{"path":"chap-package.html","id":"méthodes-s3","chapter":"5 Package","heading":"5.5.2 Méthodes S3","text":"Les méthodes S3 sont présentées en section 2.1.2.","code":""},{"path":"chap-package.html","id":"classes","chapter":"5 Package","heading":"5.5.2.1 Classes","text":"Les objets appartiennent à des classes :En plus des classes de base, les développeurs peuvent en créer d’autres.","code":"\n# Classe d'un nombre\nclass(2)## [1] \"numeric\"\n# Classe d'une fonction\nclass(sum)## [1] \"function\""},{"path":"chap-package.html","id":"méthodes","chapter":"5 Package","heading":"5.5.2.2 Méthodes","text":"L’intérêt de créer de nouvelles classes est de leur adapter des méthodes existantes, le cas le plus courant étant plot().\nIl s’agit d’une méthode générique, c’est-à-dire un modèle de fonction, sans code, à décliner selon la classe d’objet à traiter.Il existe dans R de nombreuses déclinaisons de plot qui sont des fonctions dont le nom est de la forme plot.class().\nstats fournit une fonction plot.lm() pour créer une figure à partir d’un modèle linéaire.\nDe nombreux packages créent des classes adaptées à leurs objets et proposent une méthode plot pour chaque classe.\nLes fonctions peuvent être listées :Inversement, les méthodes disponibles pour une classe peuvent être affichées :La méthode print est utilisée pour afficher tout objet (elle est implicite quand saisit seulement le nom d’un objet) :La méthode summary affiche un résumé lisible de l’objet :Les autres méthodes ont été créées spécifiquement pour les besoins du package stats.","code":"\nplot## function (x, y, ...) \n## UseMethod(\"plot\")\n## <bytecode: 0x13605c448>\n## <environment: namespace:base>\n# Quelques fonctions plot()\nhead(methods(plot))## [1] \"plot,ANY-method\"   \"plot,color-method\"\n## [3] \"plot.AccumCurve\"   \"plot.acf\"         \n## [5] \"plot.ACF\"          \"plot.addvar\"\n# Nombre total\nlength(methods(plot))## [1] 155\nmethods(class = \"lm\")##  [1] add1           alias          anova         \n##  [4] as_flextable   case.names     coerce        \n##  [7] confint        cooks.distance deviance      \n## [10] dfbeta         dfbetas        drop1         \n## [13] dummy.coef     effects        extractAIC    \n## [16] family         formula        fortify       \n## [19] hatvalues      influence      initialize    \n## [22] kappa          labels         logLik        \n## [25] model.frame    model.matrix   nobs          \n## [28] plot           predict        print         \n## [31] proj           qqnorm         qr            \n## [34] residuals      response       rstandard     \n## [37] rstudent       show           simulate      \n## [40] slotsFromS3    summary        variable.names\n## [43] vcov          \n## see '?methods' for accessing help and source code\nmy_lm <- lm(dist ~ speed, data = cars)\n# Equivalent de '> my_lm'\nprint(my_lm)## \n## Call:\n## lm(formula = dist ~ speed, data = cars)\n## \n## Coefficients:\n## (Intercept)        speed  \n##     -17.579        3.932\nsummary(my_lm)## \n## Call:\n## lm(formula = dist ~ speed, data = cars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -29.069  -9.525  -2.272   9.215  43.201 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept) -17.5791     6.7584  -2.601   0.0123 *  \n## speed         3.9324     0.4155   9.464 1.49e-12 ***\n## ---\n## Signif. codes:  \n## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 15.38 on 48 degrees of freedom\n## Multiple R-squared:  0.6511, Adjusted R-squared:  0.6438 \n## F-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12"},{"path":"chap-package.html","id":"attribution-dun-objet-à-une-classe","chapter":"5 Package","heading":"5.5.2.3 Attribution d’un objet à une classe","text":"Pour qu’un objet appartient à une classe, il suffit de le déclarer :Une façon plus élégante de le faire est d’ajouter la nouvelle classe à l’ensemble des classes auquel l’objet appartient déjà :Il n’y aucune vérification de cohérence entre la structure réelle de l’objet et une structure de la classe qui serait déclarée ailleurs : le développeur doit s’assurer que les méthodes trouveront bien les bonnes données dans les objets qui déclarent lui appartenir.\nDans le cas contraire, des erreurs se produisent :","code":"\nx <- 1\nclass(x) <- \"MyClass\"\nclass(x)## [1] \"MyClass\"\ny <- 1\nclass(y) <- c(\"MyClass\", class(y))\nclass(y)## [1] \"MyClass\" \"numeric\"\nclass(y) <- \"lm\"\ntryCatch(print(y), error = function(e) print(e))## <simpleError in x$call: $ operator is invalid for atomic vectors>"},{"path":"chap-package.html","id":"en-pratique","chapter":"5 Package","heading":"5.5.3 En pratique","text":"","code":""},{"path":"chap-package.html","id":"création-dune-méthode-générique","chapter":"5 Package","heading":"5.5.3.1 Création d’une méthode générique","text":"De nouvelles méthodes génériques peuvent être créées et déclinées selon les classes.titre d’exemple, créons une méthode générique triple qui calculera le triple des valeurs dans le package multiple, déclinée en deux fonctions distinctes : une pour les entiers et une pour les réels.\nLes calculs sur les nombres entiers plus rapides que ceux sur les réels, ce qui justifie l’effort d’écrire deux versions du code.La méthode générique ne contient pas de code au-delà de sa déclaration.\nSa signature (c’est-à-dire l’ensemble de ses arguments) est importante parce que les fonctions dérivées de cette méthode devront obligatoirement avoir les mêmes arguments dans le même ordre et pourront seulement ajouter des arguments supplémentaires avant ... (qui est obligatoire).\nComme la nature du premier argument dépendra de la classe de chaque objet, l’usage est de l’appeler x.La méthode est déclinée en deux fonctions :Dans sa version entière, x est multiplié par 3L, le suffixe L signifiant que 3 doit être compris comme un entier.\nDans sa version réelle, 3 peut être noté 3.0 pour montrer clairement qu’il s’agit d’un réel.\nSous R, 3 sans autre précision est compris comme un réel.Le choix de la fonction dépend de la classe de l’objet passé en argument.La mesure des performances par le package microbenchmark ne montre pas de différence entre les fonctions triple.integer() et triple.numeric comme attendu parce que le temps consacré au calcul lui-même est négligeable en comparaison du temps d’appel de la fonction.\nLa méthode générique consomme beaucoup plus de temps que les calculs très simples ici.\nR teste en effet l’existence de fonctions correspondant à la classe de l’objet passé en argument aux méthodes génériques.\nComme un objet peut appartenir à plusieurs classes, il recherche une fonction adaptée à la première classe, puis aux classes suivantes successivement.\nCette recherche prend beaucoup de temps et justifie de réserver l’usage de méthodes génériques à la lisibilité du code plutôt qu’à une recherche de performance : l’intérêt des méthodes génériques est de fournir à l’utilisateur du code une seule fonction pour un objectif donné (plot pour réaliser une figure) quelles que soient les données à traiter.","code":"\n# Méthode générique\ntriple <- function(x, ...) {\n    UseMethod(\"triple\")\n}\ntriple.integer<- function (x, ...){\n  return(x * 3L)\n}\ntriple.numeric<- function (x, ...){\n  return(x * 3.0)\n}\n# Argument entier\nclass(2L)## [1] \"integer\"\n# Résultat entier par la fonction triple.integer\nclass(triple(2L))## [1] \"integer\"\n# Argument réel\nclass(2)## [1] \"numeric\"\n# Résultat réel par la fonction triple.numeric\nclass(triple(2))## [1] \"numeric\"\n# Performance\nmicrobenchmark::microbenchmark(triple.integer(2L), triple.numeric(2),\n    triple(2L))## Unit: nanoseconds\n##                expr min  lq    mean median  uq    max neval\n##  triple.integer(2L) 123 123  139.81    123 123    615   100\n##   triple.numeric(2)  82 123 6500.14    123 123 637140   100\n##          triple(2L) 492 492 8804.75    533 533 826273   100"},{"path":"chap-package.html","id":"création-dune-classe","chapter":"5 Package","heading":"5.5.3.2 Création d’une classe","text":"Dans un package, créera des classes si les résultats des fonctions le justifient : structure de liste et identification de la classe à un objet (“lm” est la classe des modèles linéaires).\nPour toute classe créée, les méthodes print, summary et plot (si une représentation graphique est possible) doivent être écrites.Ecrivons une fonction multiple() dont le résultat sera un objet d’une nouvelle classe, “multiple”, qui sera une liste mémorisant les valeurs à multiplier, le multiplicateur et le résultat.L’appel à la fonction multiple() renvoie un objet de classe “multiple”, qui est aussi de classe “list”.\nEn absence de fonction print.multiple(), R cherche la fonction print.list() qui n’existe pas et se rabat sur la fonction print.default() :La fonction print.multiple doit donc être écrite pour un affichage lisible, limité au résultat :Les détails peuvent être présentés dans la fonction summary :Enfin, une fonction plot et une fonction autoplot complètent l’ensemble :Pour des raisons techniques liées à l’évaluation non conventionnelle dans le tidyverse, les noms de variables utilisées par aes() doivent être préfixées par .data$ dans les packages et rlang::.data doit être importé.\nDans le cas contraire, la vérification du package renvoie une note indiquant que les variables x et y, utilisées par les arguments de aes() n’ont pas été déclarées et n’existent peut-être pas dans l’environnement local (voir section 2.2).","code":"\nmultiple <- function(number, times = 1) {\n    # Calculate the multiples\n    y <- number * times\n    # Save in a list\n    result <- list(x = number, y = y, times = times)\n    # Set the class\n    class(result) <- c(\"multiple\", class(result))\n    return(result)\n}\n# Classe du résultat\nmy_multiple <- multiple(1:3, 2)\nclass(my_multiple)## [1] \"multiple\" \"list\"\nmy_multiple## $x\n## [1] 1 2 3\n## \n## $y\n## [1] 2 4 6\n## \n## $times\n## [1] 2\n## \n## attr(,\"class\")\n## [1] \"multiple\" \"list\"\nprint.multiple <- function(x, ...) {\n    print.default(x$y)\n}\n# Nouvel affichage\nmy_multiple## [1] 2 4 6\nsummary.multiple <- function(object, ...) {\n    print.default(object$x)\n    cat(\"multiplied by\", object$times, \"is:\\n\")\n    print.default(object$y)\n}\n# Nouvel affichage\nsummary(my_multiple)## [1] 1 2 3\n## multiplied by 2 is:\n## [1] 2 4 6\nplot.multiple <- function(x, y, ...) {\n  plot.default(y=x$y, x=x$x, type = \"p\", \n    main = paste(\"Multiplication by\", x$times), ...)\n}\n\nautoplot.multiple <- function(object, ...) {\n  data.frame(x = object$x, y = object$y) %>% \n    ggplot2::ggplot() +\n    ggplot2::geom_point(ggplot2::aes(x = .data$x, y = .data$y)) +\n    ggplot2::labs(title = paste(\"Multiplication by\", \n                                object$times))\n}\n\nplot(my_multiple)\nautoplot(my_multiple)"},{"path":"chap-package.html","id":"documentation","chapter":"5 Package","heading":"5.5.3.3 Documentation","text":"Les méthodes génériques et les fonctions qui les déclinent doivent être documentées comme n’importe quelle autre fonction.La gestion de l’espace des noms est un peu plus complexe :Les méthodes génériques doivent être exportées :Les fonctions dérivées de méthodes génériques ne doivent pas être exportées mais être déclarées comme méthodes, avec le nom de la méthode générique et la classe traitée.\nroxygen2 demande qu’une directive d’exportation soit ajoutée mais ne l’applique pas (comme il se doit) dans le fichier NAMESPACE qui est utilisé par R :Depuis la version 3 de roxygen2, la déclaration @method est inutile tant que le nom de la fonction est décomposable sans ambiguïté, comme plot.multiple : @export suffit.\nSi le nom de la fonction dérivée comporte plusieurs points, roxygen2 peut ne pas détecter automatiquement le générique et l’objet et @method doit être maintenu.Depuis la version 3 de roxygen2, la déclaration @method est inutile tant que le nom de la fonction est décomposable sans ambiguïté, comme plot.multiple : @export suffit.\nSi le nom de la fonction dérivée comporte plusieurs points, roxygen2 peut ne pas détecter automatiquement le générique et l’objet et @method doit être maintenu.Les fonctions dérivées de méthodes génériques venant d’un autre package nécessitent d’importer la méthode générique, sauf si elle est fournie par base (print est fourni par base et n’est donc pas concerné) :Les fonctions dérivées de méthodes génériques venant d’un autre package nécessitent d’importer la méthode générique, sauf si elle est fournie par base (print est fourni par base et n’est donc pas concerné) :Les génériques importés de cette manière doivent être réexportés par une directive à placer par exemple juste après le code de la fonction dérivée :roxygen2 crée automatiquement un fichier d’aide reexports.Rd dans lequel se trouve un lien vers la documentation originale des génériques réexportés.Dans DESCRIPTION, le package d’origine de chaque générique doit être listé dans la directive Imports: :Enfin, l’importation de fonctions du tidyverse nécessite aussi quelques précautions :le package tidyverse est réservé à l’usage interactif de R : il n’est pas question de l’importer dans DESCRIPTION parce que ses dépendances peuvent changer et aboutir à des résultats imprévisibles.\nLe package magrittr fournit les tuyaux, principalement %>%.\nLe package rlang fournit l’objet .data présenté ci-dessous.\nIl doivent être importés dans DESCRIPTION.Comme il n’est pas possible de préfixer les %>% par le nom du package, il faut importer la fonction en utilisant les délimiteurs prévus pour les fonctions dont le nom contient des caractères spéciaux :Les fonctions du tidyverse qui utilisent des noms de colonnes de tibbles ou dataframes génèrent des avertissements au moment de la vérification du package parce que ces noms sont confondus avec des noms de variables non définies.\nPour éviter cette confusions, l’objet .data du package rlang est utilisé (par exemple dans aes() vu plus haut).\nIl doit être importé :Finalement, le code complet est le suivant :","code":"#' @export#' @method plot multiple\n#' @export#' @importFrom graphics plot\n#' @importFrom ggplot2 autoplot#' @export\ngraphics::plot\n\n#' @export\nggplot2::autoplotImports: ggplot2, graphicsImports: magrittr, rlang, stats\n#' @importFrom magrittr `%>%`\n#' @importFrom rlang .data\n#' Multiplication of a numeric vector\n#'\n#' @param number a numeric vector\n#' @param times a number to multiply\n#'\n#' @return an object of class `multiple`\n#' @export\n#'\n#' @examples\n#' multiple(1:2,3)\nmultiple <- function(number, times = 1) {\n  # Calculate the multiples\n  y <- number * times\n  # Save in a list\n  result <- list(x = number, y = y, times = times)\n  # Set the class\n  class(result) <- c(\"multiple\", class(result))\n  return(result)\n}\n\n#' Print objects of class multiple\n#'\n#' @param x an object of class `multiple`.\n#' @param ... further arguments passed to the generic method.\n#'\n#' @export\n#'\n#' @examples\n#' print(multiple(2,3))\nprint.multiple <- function(x, ...) {\n  print.default(x$y)\n}\n\n#' Summarize objects of class multiple\n#'\n#' @param object an object of class `multiple`.\n#' @param ... further arguments passed to the generic method.\n#'\n#' @export\n#'\n#' @examples\n#' summary(multiple(2,3))\nsummary.multiple <- function(object, ...) {\n  print.default(object$x)\n  cat(\"multiplied by\", object$times, \"is:\\n\")\n  print.default(object$y)\n}\n\n#' Plot objects of class multiple\n#'\n#' @param x a vector of numbers\n#' @param y a vector of multiplied numbers\n#' @param ... further arguments passed to the generic method.\n#'\n#' @importFrom graphics plot\n#' @export\n#'\n#' @examples\n#' plot(multiple(2,3))\nplot.multiple <- function(x, y, ...) {\n  plot.default(y=x$y, x=x$x, type = \"p\", \n               main = paste(\"Multiplication by\", x$times), ...)\n}\n#' @export\ngraphics::plot## function (x, y, ...) \n## UseMethod(\"plot\")\n## <bytecode: 0x13605c448>\n## <environment: namespace:base>\n#' autoplot\n#'\n#' ggplot of the `multiple` objects.\n#'\n#' @param object an object of class `multiple`.\n#' @param ... ignored.\n#'\n#' @return a `ggplot` object\n#' @importFrom ggplot2 autoplot\n#' @importFrom magrittr `%>%`\n#' @importFrom rlang .data\n#' @export\n#'\n#' @examples\n#' autoplot(multiple(2,3))\nautoplot.multiple <- function(object, ...) {\n  data.frame(x = object$x, y = object$y) %>%\n    ggplot2::ggplot() +\n    ggplot2::geom_point(ggplot2::aes(x = .data$x, y = .data$y)) +\n    ggplot2::labs(title = paste(\"Multiplication by\", \n                                object$times))\n}\n#' @export\nggplot2::autoplot## function (object, ...) \n## {\n##     UseMethod(\"autoplot\")\n## }\n## <bytecode: 0x140190478>\n## <environment: namespace:ggplot2>"},{"path":"chap-package.html","id":"code-c","chapter":"5 Package","heading":"5.5.4 Code C++","text":"L’utilisation de code C++ été vue en section 2.5.\nPour intégrer ces fonctions dans un packages, il faut respecter les règles suivantes :les fichiers .cpp contenant le code sont placés dans le dossier /src du projet ;le code est commenté pour roxygen2 de la même façon que les fonctions R, mais avec le marqueur de commentaire du langage C :dans DESCRIPTION, importer les packages.\nRcpp, et RcppParallel si du code parallélisé est utilisé (supprimer ses références sinon), doivent être déclarés dans LinkingTo :les commentaires pour roxygen2 doivent être ajoutés à package.R (“multiple” est le nom du package) :les fichiers de travail de C++ sont exclus du contrôle de source dans .gitignore :Ces modifications sont en partie effectuées automatiquement, pour Rcpp seulement, par usethis, mais l’insertion manuelle du code est plus rapide et fiable : ne pas utiliser cette commande.La construction du package entraînera la compilation du code : les Rtools sont donc indispensables.","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n//' timesTwo\n//'\n//' Calculates the double of a value.\n//'\n//' @param x A numeric vector.\n//' @export\n// [[Rcpp::export]]\nNumericVector timesTwo(NumericVector x) {\n  return x * 2;\n}Imports: Rcpp, RcppParallel\nLinkingTo: Rcpp, RcppParallel\n#' @importFrom Rcpp sourceCpp\n#' @importFrom RcppParallel RcppParallelLibs\n#' @useDynLib multiple, .registration = TRUE# C binaries\nsrc/*.o\nsrc/*.so\nsrc/*.dll\n# usethis::use_rcpp()"},{"path":"chap-package.html","id":"package-bien-rangé","chapter":"5 Package","heading":"5.5.5 Package bien rangé","text":"Tout package moderne doit être compatible avec le tidyverse, ce qui nécessite peu d’efforts :pour permettre l’utilisation de pipelines, l’argument principal des fonctions doit être le premier ;les fonctions qui transforment des données doivent accepter un dataframe ou un tibble comme premier argument et retourner un objet du même format ;les méthodes plot() doivent être doublées de méthodes autoplot() avec les mêmes arguments qui produisent le même graphique avec ggplot2.","code":""},{"path":"chap-package.html","id":"bibliographie-1","chapter":"5 Package","heading":"5.6 Bibliographie","text":"La documentation d’un package fait appel à des références bibliographiques.\nElles peuvent être gérées automatiquement avec Rdpack et roxygen2.\nLes références utilisées dans les fichiers R Markdown (vignette, site produit par pkgdown) ne sont pas concernées.","code":""},{"path":"chap-package.html","id":"préparation","chapter":"5 Package","heading":"5.6.1 Préparation","text":"Les références bibliographiques doivent être placées dans un fichier BibTeX REFERENCES.bib placé dans le dossier inst.\nCe dossier contient des fichiers qui seront placés à la racine du dossier du package quand il sera installé.Ajouter la ligne suivante à DESCRIPTION :Ajouter aussi le package Rdpack à la liste des packages importés :Enfin, importer la fonction reprompt() de Rdpack en ajoutant les lignes suivantes à la documentation pour roxygen2 dans package.R :","code":"RdMacros: RdpackImports: magrittr, stats, Rcpp, Rdpack\n#' @importFrom Rdpack reprompt"},{"path":"chap-package.html","id":"citations","chapter":"5 Package","heading":"5.6.2 Citations","text":"Les références sont citées par la commande \\insertCite{key}{package} dans la documentation destinée à roxygen2.\npackage est le nom du package dans lequel le fichier REFERENCES.bib doit être cherché : ce sera normalement le package en cours, mais les références d’autres packages sont accessibles, à la seule condition qu’ils utilisent Rdpack.key est l’identifiant de la référence dans le fichier.\nExemple106: documentation du package divent hébergé sur GitHub, fichier .R du package :La référence citée se trouve dans inst/REFERENCES.bib :Les citations sont entre parenthèses.\nPour placer le nom de l’auteur hors de la parenthèse, ajouter la déclaration ;textual :Pour citer plusieurs références (forcément du même package), les séparer par des virgules.la fin de la documentation d’un objet utilisant des citations, ajouter systématiquement une liste des références :","code":"\n#' divent\n#'\n#' Measures of Diversity and Entropy\n#' \n#' This package is a reboot of the **entropart** package \\insertCite{Marcon2014c}{divent}.\n#'\n#' @importFrom Rdpack reprompt\n#' \n#' @references\n#' \\insertAllCited{}\n\"_PACKAGE\"## [1] \"_PACKAGE\"@Article{Marcon2014c,\n  author  = {Marcon, Eric and Herault, Bruno},\n  title   = {entropart, an R Package to Partition \n             Diversity},\n  journal = {Journal of Statistical Software},\n  year    = {2015},\n  volume  = {67},\n  number  = {8},\n  pages   = {1--26},\n}\\insertCite{Marcon2014c;textual}{divent}\n#' @references\n#' \\insertAllCited{}"},{"path":"chap-package.html","id":"données","chapter":"5 Package","heading":"5.7 Données","text":"Des données peuvent être intégrées à un package, notamment pour la clarté des exemples.La méthode la plus simple consiste à utiliser usethis.\nCréer des variables contenant les données à sauvegarder puis les sauvegarder :Un fichier .rda est créé dans le dossier data pour chaque variable créée.\nAvec l’option LazyData activée dans DESCRIPTION, les variables seront disponibles dès le chargement du package, mais ne seront effectivement chargées en mémoire qu’après leur première utilisation.Chaque variable doit être documentée dans le fichier package.R :Le nom de la variable est donné entre guillemets après le bloc de commentaires (à la place du code R d’une fonction).\n@format décrit le format des données et @source permet d’indiquer leur source.","code":"\nseq1_10 <- 1:10\nseq1_100 <- 1:100\nusethis::use_data(seq1_10, seq1_100)\n#' seq1_10\n#'\n#' A sequence of numbers from 1 to 10\n#'\n#' @format A numeric vector.\n#' @source Values computed by the R software, \n#'   \\url{https://www.r-project.org/}\n\"seq1_10\""},{"path":"chap-package.html","id":"tests-unitaires","chapter":"5 Package","heading":"5.8 Tests unitaires","text":"Dans l’idéal, tout le code inclus dans un package devrait être testé de multiples façons :contre les erreurs de syntaxe : les procédures de vérification de R s’en chargent assez bien ;pour vérifier la conformité des résultats de calculs aux valeurs attendues ;contre la survenue d’erreurs si les utilisateurs n’utilisent pas le code comme le développeur l’prévu (arguments incorrects passés aux fonctions, données inadéquates…).Les tests unitaires sont utilisés dans les deux derniers objectifs.\nIls s’appuient sur testthat à intégrer au package :Les tests doivent être ajoutés sous la forme de fichiers .R dont le nom commence obligatoirement par test dans le dossier tests/testthat.Chaque test (donc le contenu de chaque fichier) commence par son contexte, c’est-à-dire ce un ensemble de tests. Exemple, dans un fichier test_double.R :Les tests sont contenus dans des fichiers qui les regroupent par thème, par exemple test_double.R.\nLe nom de chaque test est passé comme argument de la fonction test_that() :Toutes les fonctions commençant par expect permettent de comparer leur premier argument à un résultat : dans l’exemple ci-dessus, le résultat de double(1:2) doit être 2 4 et le type de ce vecteur doit être réel à double précision.\nLe dernier test vérifie qu’une chaîne de caractère passée comme argument génère une erreur, ce qui n’est pas optimal : si le package traitait l’erreur, le message retourné pourrait être testé.La commande skip_on_cran(), à utiliser systématiquement, évite de lancer les tests sur CRAN quand le package y sera déposé : CRAN dispose de ressources limitées et restreint strictement le temps de vérification des packages sur sa plateforme.\nLes tests devront donc être réalisés sur GitHub, grâce à l’intégration continue, voir section 5.10.Les tests peuvent être lancés par le menu “> Test package” de la fenêtre Build ou par la commande devtools::test().Il est conseillé d’écrire les tests dès qu’une fonction du package est stabilisée.","code":"\nusethis::use_testthat()## \n## Attaching package: 'testthat'## The following object is masked from 'package:targets':\n## \n##     matches## The following object is masked from 'package:dplyr':\n## \n##     matches## The following object is masked from 'package:purrr':\n## \n##     is_null## The following objects are masked from 'package:readr':\n## \n##     edition_get, local_edition## The following object is masked from 'package:tidyr':\n## \n##     matches\ncontext(\"function double\")\ntest_that(\"Double values are correct\", {\n    skip_on_cran()\n    x <- 1:2\n    # 2 x 2 should be 4\n    expect_equal(double(x), c(2, 4))\n    # The result should be a number (type = 'double')\n    expect_type(double(x), \"double\")\n    # Error management\n    expect_error(double(\"a\"))\n})## Test passed 🎊"},{"path":"chap-package.html","id":"fichier-.gitignore","chapter":"5 Package","heading":"5.9 Fichier .gitignore","text":"Le fichier .gitignore obtenu à ce stade est incomplet.\nIl peut être remplacé par celui-ci :La dernière ligne concerne le dossier docs/, qui reçoit le site web produit par pkgdown.\nElle est commentée tant que la production du site est réalisée localement, mais décommentée si elle est confiée à GitHub Actions (voir section suivante).","code":"# History files\n.Rhistory\n.Rapp.history\n# Session Data files\n.RData\n# Example code in package build process\n*-Ex.R\n# Output files from R CMD build\n/*.tar.gz\n# Output files from R CMD check\n/*.Rcheck/\n# RStudio files\n.Rproj.user/\n.Rprofile\n# knitr and R markdown default cache directories\n*_cache/\n/cache/\n# Temporary files created by R markdown\n*.utf8.md\n*.knit.md\n# C binaries\nsrc/*.o\nsrc/*.so\nsrc/*.dll\n/src-i386/\n/src-x64/\n# uncomment if pkgdown is run by CI\n# docs/"},{"path":"chap-package.html","id":"sec:package-ci5","chapter":"5 Package","heading":"5.10 Intégration continue","text":"La vérification (Check) du package doit être effectuée à chaque étape du développement, ce qui consomme un temps considérable.\nElle peut être automatisée très simplement avec le service GitHub Actions, déclenché à chaque modification du dépôt sur GitHub.\nL’analyse de la couverture du code par les tests (quelles parties du codes sont testées ou non) sera ajoutée.GitHub est également capable de reconstruire la documentation du package avec pkgdown, autre opération consommatrice de ressources, après la réussite des tests.La section 6.3.3 détaille le moyen de le faire.","code":""},{"path":"chap-package.html","id":"sec:package-cran","chapter":"5 Package","heading":"5.11 CRAN","text":"Les packages dont l’audience dépasse l’entourage de l’auteur peuvent être déposés sur CRAN.\nLes règles à respecter sur CRAN sont nombreuses107. Elles sont vérifiées par la commande de vérification R CMD check avec l’option -- .cran.\nLa vérification ne doit renvoyer aucune erreur, aucun avertissement, ni aucune note avant de soumettre le package.","code":""},{"path":"chap-package.html","id":"test-du-package","chapter":"5 Package","heading":"5.11.1 Test du package","text":"La vérification du package par GitHub dans le cadre de l’intégration continue n’est pas suffisante.\nLe package doit être testé sur la version de développement de R.\nLe site R-hub builder108 permet de le faire simplement.Le package, dont la version ne doit pas être de développement (limitée à trois nombres, voir section 5.2.1), doit être construit au format source : dans la fenêtre Build de RStudio, cliquer sur “> Build Source Package”.\nSur le site R-hub builder, cliquer sur “Advanced”, sélectionner le fichier source du package et la plateforme de test : Debian Linux, R-devel, GCC.Le package rhub permet d’utiliser la même plateforme de vérification que le site R-hub builder depuis RStudio.\nLa première étape consiste à valider son adresse de messagerie avec la commande validate_email().\nEnsuite, il suffit d’appeler la fonction check_for_cran() pour lancer une vérification complète.","code":""},{"path":"chap-package.html","id":"soumission","chapter":"5 Package","heading":"5.11.2 Soumission","text":"Quand le package est au point, la soumission à CRAN se fait par le site web dédié109.En cas de rejet, traiter les demandes et soumettre à nouveau en incrémentant le numéro de version.","code":""},{"path":"chap-package.html","id":"maintenance","chapter":"5 Package","heading":"5.11.3 Maintenance","text":"Des demandes de corrections sont envoyées par CRAN de temps à autre, notamment lors des changements de version de R.\nL’adresse de messagerie du responsable du package (maintainer) doit rester valide et les demandes doivent être traitées rapidement.\nDans le cas contraire, le package est archivé.Les nouvelles versions du package sont soumises de la même façon que la première.","code":""},{"path":"chap-ci.html","id":"chap-ci","chapter":"6 Intégration continue","heading":"6 Intégration continue","text":"L’intégration continue consiste à confier à un service externe la tâche de vérifier un package, produire des documents Markdown pour les pages web d’un dépôt GitHub ou tricoter entièrement un site web à partir du code.Toutes ces tâches peuvent être accomplies localement sur le poste de travail mais prennent du temps et risquent de ne pas être répétées à chaque mise à jour.\nDans le cadre de l’intégration continue, elles le sont systématiquement, de façon transparente pour l’utilisateur.\nEn cas d’échec, un message d’alerte est envoyé.La mise en place de l’intégration continue se justifie pour des projets lourds, avec des mises à jour régulières.\nplutôt que pour des projets contenant un simple document Markdown rarement modifié.","code":""},{"path":"chap-ci.html","id":"outils","chapter":"6 Intégration continue","heading":"6.1 Outils","text":"","code":""},{"path":"chap-ci.html","id":"github-actions","chapter":"6 Intégration continue","heading":"6.1.1 GitHub Actions","text":"L’outil utilisé le plus fréquemment pour des projets R déposés sur GitHub était Travis CI110 mais le service est devenu payant en 2021.Les Actions GitHub remplacent avantageusement Travis.\nCe service est intégré à GitHub.","code":""},{"path":"chap-ci.html","id":"codecov","chapter":"6 Intégration continue","heading":"6.1.2 Codecov","text":"Pour évaluer le taux de couverture du code des packages R, c’est-à-dire la proportion du code testé d’une façon ou d’une autre (exemples, tests unitaires, vignette), le service Codecov111 s’intègre parfaitement à GitHub.Il faut ouvrir un compte, de préférence en s’authentifiant par GitHub.","code":""},{"path":"chap-ci.html","id":"github-pages","chapter":"6 Intégration continue","heading":"6.1.3 GitHub Pages","text":"Les pages web de GitHub peuvent être hébergées dans le répertoire docs de la branche master du projet : c’est la solution retenue quand elle sont produites sur le poste de travail.Si elles sont produites par intégration continue, elle le seront obligatoirement dans une branche dédiée appelée gh-pages.","code":""},{"path":"chap-ci.html","id":"principes","chapter":"6 Intégration continue","heading":"6.2 Principes","text":"Un projet de document est traité en exemple.\nL’objectif est de faire tricoter par GitHub un projet Markdown.\nCette pratique est appropriée pour les projets d’ouvrages, qui nécessitent beaucoup de ressources pour leur construction.\nDans ce type de projet, le code est tricoté par knitr pour produire plusieurs documents, typiquement aux formats HTML et PDF, accessibles sur les pages GitHub.\nQuand les documents sont produits localement, ils sont placés dans le dossier docs et poussés sur GitHub.Pour que GitHub s’en charge, quelques réglages sont nécessaires.","code":""},{"path":"chap-ci.html","id":"obtention-dun-jeton-daccès-personnel","chapter":"6 Intégration continue","heading":"6.2.1 Obtention d’un jeton d’accès personnel","text":"Pour écrire sur GitHub, le service d’intégration continue devra s’authentifier au moyen d’un jeton d’accès personnel (Personal Access Token : PAT) dont la création est décrite en section 1.4.4.Générer un nouveau jeton, le décrire en tant que “GitHub Actions” et lui donner les autorisations :“repo”, c’est-à-dire modifier tous les dépôts (il n’est pas possible de limiter l’accès à un dépôt particulier).“workflow”, c’est-à-dire exécuter lles scripts d’intégration continue.","code":""},{"path":"chap-ci.html","id":"sec:secrets-ci","chapter":"6 Intégration continue","heading":"6.2.2 Secrets du projet","text":"Sur GitHub, afficher les paramètres du projet et sélectionner “Secrets”.\nLe bouton “New Repository Secret” permet de stocker des variables utilisées dans les scripts des Actions GitHub (visibles publiquement) sans en diffuser la valeur.\nLe jeton d’accès personnel est indispensable pour que les Actions GitHub puissent écrire leur production dans le projet.\nCréer un secret nommé “GH_PAT” et saisir la valeur du jeton sauvegardée précédemment.\nAprès avoir cliqué sur “Add Secret”, le jeton ne pourra plus être lu.Pour permettre l’envoi de messages de succès ou d’échec sans diffuser son adresse de messagerie, créer un secret nommé “EMAIL” qui la contient.","code":""},{"path":"chap-ci.html","id":"activation-du-dépôt-sur-codecov","chapter":"6 Intégration continue","heading":"6.2.3 Activation du dépôt sur CodeCov","text":"L’analyse de la couverture du code des packages est utile pour détecter les portions de code non testées.\nEn revanche, l’analyse de la couverture des projets de document n’pas d’intérêt.Pour activer un dépôt, il faut d’authentifier sur le site de CodeCov avec son compte GitHub.\nLa liste des dépôts est affichée et peut être actualisée.\nSi les dépôts à traiter sont hébergés par une organisation, par exemple les dépôts d’une salle de classe GitHub, il faut actualiser la liste des organisations en suivant les instructions (un lien permet de modifier rapidement les options de GitHub pour autoriser la lecture d’une organisation par Codecov) et à nouveau mettre à jour la liste des dépôts.\nEnfin, quand le dépôt recherché est visible, il faut l’activer.\nIl est inutile d’utiliser le système de jetons de Codecov.","code":""},{"path":"chap-ci.html","id":"scripter-les-actions-de-github","chapter":"6 Intégration continue","heading":"6.2.4 Scripter les actions de GitHub","text":"Un flux de travail (workflow) de GitHub est une succession de tâches (jobs) comprenant des étapes (steps).\nUn flux de travail est déclenché par un évènement, généralement chaque push du projet, mais aussi à intervalles réguliers (cron).Typiquement, les flux créés ici contiennent deux tâches : la première installe R et les composants nécessaires et exécute des scripts R (ce qui constitue ses étapes successives) ; la seconde publie des fichiers obtenus dans les pages GitHub.Les flux de travail sont configurés dans un fichier au format YAML placé dans le dossier .github/workflows/ du projet.\nLes différentes parties du script sont présentées ci-dessous.\nLe script complet est celui de ce document, accessible sur GitHub112.","code":""},{"path":"chap-ci.html","id":"sec:declenchement","chapter":"6 Intégration continue","heading":"6.2.4.1 Déclenchement","text":"L’action est déclenchée à chaque fois que des mises à jour sont poussées sur GitHub :La branche prise en compte est master (à remplacer par main le cas échéant).Pour déclencher l’action périodiquement, il faut utiliser la syntaxe de cron (le système de planification des tâches sous Unix) :Les valeurs successives sont celles des minutes, des heures, du jour (quantième du mois), du mois et du jour de la semaine (0 pour dimanche à 6 pour samedi).\nLes * permettent d’ignorer une valeur.Les entrées push et schedule peuvent être utilisées ensemble :Actuellement, la planification n’est prise en compte que dans la branche master.","code":"on:\n  push:\n     branches:\n       - masteron:\n  schedule:\n    - cron: '0 22 * * 0'  # every sunday at 22:00on:\n  push:\n     branches:\n       - master\n  schedule:\n    - cron: '0 22 * * 0'"},{"path":"chap-ci.html","id":"nom-du-flux-de-travail","chapter":"6 Intégration continue","heading":"6.2.4.2 Nom du flux de travail","text":"Le nom du flux est libre.\nIl sera affiché par le badge qui sera ajouté dans le fichier README.md du projet (voir section 6.4).","code":"name: bookdown"},{"path":"chap-ci.html","id":"première-tâche","chapter":"6 Intégration continue","heading":"6.2.4.3 Première tâche","text":"Les tâches sont décrites dans la rubrique jobs.\nrenderbook est le nom de la première tâche : il est libre.\nIci, l’action principale consistera à produire un ouvrage bookdown avec la fonction render_book(), d’où son nom.La déclaration runs-décrit le système d’exploitation sur lequel la tâche doit s’exécuter.\nLes choix possibles sont Windows, Ubuntu ou MacOS113.\nL’intégration continue de R sur GitHub utilise habituellement MacOS qui l’avantage d’utiliser des packages R compilés donc beaucoup plus simples (certains packages nécessitent des librairies extérieures à R pour leur compilation) et rapides à installer, tout en permettant l’usage de scripts.","code":"jobs:\n  renderbook:\n    runs-on: macOS-latest"},{"path":"chap-ci.html","id":"premières-étapes","chapter":"6 Intégration continue","heading":"6.2.4.4 Premières étapes","text":"Les étapes sont décrites dans la rubrique steps.Chaque étape est décrite par son nom (libre) et ce qu’elle réalise.La force de GitHub Actions est de permettre l’utilisation d’actions écrites par d’autres et stockées dans un projet public GitHub.\nUne action est un script accompagné de métadonnées qui décrivent son usage.\nSon développement est accompagné par des numéros de version successifs.\nappelle une action par l’instruction uses:, le projet GitHub qui la contient et sa version.Dans leur projet GitHub respectif, les actions existent dans leur version de développement (@master) et dans des versions d’étape (release) accessibles par leur numéro (@v1).\nCes versions d’étape sont préférables parce qu’elles sont stables.Les actions généralistes sont mises à disposition par GitHub dans l’organisation GitHub Actions114.\nL’action “actions/checkout” permet de se placer dans la branche principale du projet traité par le flux de travail : c’est en général la première étape de tous les flux.L’action suivante est l’installation de R, mise à disposition par l’organisation R infrastructure115.L’installation de pandoc (logiciel extérieur à R mais nécessaire à R Markdown) peut être réalisée par une commande exécutée par MacOS.\nElle est appelée par run: et peut contenir plusieurs lignes (d’où le |).\nCe script dépend du système d’exploitation : brew est le gestionnaire de paquets de MacOS.\nPour éviter les spécificités d’un système, il est préférable d’utiliser une action :Il est souvent possible de choisir entre une action ou l’écriture du code correspondant.\nLe choix fait ici est de privilégier les actions pour tout ce qui trait au système, comme les installations de logiciels, mais d’utiliser des scripts pour les commandes R, comme la vérification des packages.\nL’objectif est de contrôler précisément le code R et de limiter les dépendances à des packages supplémentaires.\nLa stratégie inverse est développée dans Wickham et Bryan (2023) qui s’appuie entièrement sur des actions pour exécuter les tâches de R.","code":"    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v4\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        run: |\n          brew install pandoc      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2"},{"path":"chap-ci.html","id":"sec:packages-ci","chapter":"6 Intégration continue","heading":"6.2.4.5 Packages","text":"Cette étape utilise Rscript comme environnement de commande, ce qui lui permet d’exécuter directement des commandes R.Les packages servant à produire le document sont listés :remotes pour sa fonction install_deps() ;bookdown pour tricoter ;formatR pour la mise en forme des bouts de code (tidy=TRUE) ;tinytex pour disposer d’une distribution LaTeX.Les autres packages, ceux utilisés par le projet, sont lus dans le fichier DESCRIPTION par la fonction install_deps().Sous MacOS, les packages sont installés par défaut en version binaire, mais à partir de leur code source s’il est plus récent.\nLa création des packages binaires prend quelques jours à CRAN : cette situation n’est donc pas rare.\nLes packages ne contenant que du code R ou du code C++ sans référence à des librairies externes s’installent en revanche sans problème.\nEn revanche, si le package nécessite des librairies externes à R ou une compilation de code Fortran, l’installation échoue.\nIl serait donc nécessaire d’installer préalablement les librairies nécessaires (et éventuellement un compilateur Fortran) à l’ensemble des packages dont le projet dépend : cette solution n’est pas réaliste parce qu’elle implique l’inventaire de l’ensemble des dépendances, qui peuvent changer, et un nombre important d’installations chronophages et inutiles la plupart du temps, quand les packages binaires sont à jour.\nUne meilleure solution est de forcer l’installation des packages binaires même si le code source est plus récent : c’est l’objet des deux options de R définies avant l’appel à install.packages().Enfin, le secret GH_PAT est passé à R dans une variable d’environnement, GITHUB_PAT, nécessaire pour installer des packages à partir leur code source sur GitHub.\nGitHub limite le rythme des accès anonymes pour l’ensemble des actions GitHub (tous comptes confondus) et peut rejeter la demande : en pratique, utiliser install_github() dans une action GitHub n’est envisageable qu’avec cette variable d’environnement.","code":"      - name: Install packages\n        env:\n          GITHUB_PAT: ${{ secrets.GH_PAT }}\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"remotes\", \"bookdown\", \"formatR\", \"tinytex\"))\n          tinytex::install_tinytex(bundle = \"TinyTeX\")\n          remotes::install_deps(dependencies = TRUE)\n        shell: Rscript {0}"},{"path":"chap-ci.html","id":"tricot","chapter":"6 Intégration continue","heading":"6.2.4.6 Tricot","text":"La production de l’ouvrage est lancée par une commande R.Les paramètres déclarés dans _output.yml sont utilisés.Le fichier PDF doit être produit avant le format GitBook pour que son lien de téléchargement soit ajouté à la barre de menu du site GitBook.\nD’autre part, R doit être fermé et rouvert entre les deux rendus faute de quoi les tableaux ne sont pas créés correctement dans le GitBook116.\nLes deux étapes ne doivent pas être regroupées en une seule.","code":"      - name: Render pdf book\n        run: |\n          bookdown::render_book(\"index.Rmd\", \"bookdown::pdf_book\")\n        shell: Rscript {0}\n      - name: Render gitbook\n        run: |\n          bookdown::render_book(\"index.Rmd\", \"bookdown::gitbook\")\n        shell: Rscript {0}"},{"path":"chap-ci.html","id":"sauvegarde","chapter":"6 Intégration continue","heading":"6.2.4.7 Sauvegarde","text":"Le résultat du tricot, placé dans le dossier docs de la machine virtuelle en charge de l’intégration continue, doit être préservé pour que la tâche suivante puisse l’utiliser.La dernière étape de la tâche de production utilise l’action upload-artifact pour cela.Le contenu de docs est sauvegardé en tant qu’artefact nommé “_book”.\nLes artefacts sont visibles publiquement sur la page des Actions du projet GitHub.Après sa dernière étape, la machine virtuelle utilisée pour cette étape est détruite.","code":"      - name: Upload artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: _book\n          path: docs/"},{"path":"chap-ci.html","id":"publication","chapter":"6 Intégration continue","heading":"6.2.4.8 Publication","text":"La publication de l’artefact dans la branche gh-pages du projet nécessite une autre tâche.La tâche est nommée “deploy” (le nom est libre).\nElle s’exécute sur une machine virtuelle sous Ubuntu.\nElle ne peut se lancer que si la tâche “renderbook” réussi.\nSes étapes sont les suivantes :Download artifact : Restauration du dossier docs ;Deploy GitHub Pages : copie du dossier docs dans la branche gh-pages par un commit.Cette dernière étape utiliser l’action GitHub-Pages-deploy mise à disposition par l’organisation Cecilapp .\nElle utilise une variable d’environnement, GITHUB_TOKEN, pour s’authentifier et des paramètres :email : l’adresse de messagerie destinataire du rapport d’exécution.\nPour ne pas exposer l’adresse publiquement, elle été stockée dans un secret du projet ;buid_dir : le répertoire à publier ;jekyll:pour créer un fichier vide nommé .nojekyll qui indique aux pages GitHub de ne pas essayer de traiter leur contenu comme un site web Jekyll.GITHUB_TOKEN est un jeton d’authentification fourni par Github Actions pour l’exécution de ce script.\nSes droits sont attribués dans le script par l’entrée permission : ici, le droit d’écrire du contenu dans le projet.","code":"  deploy:\n    runs-on: ubuntu-latest\n    needs: renderbook\n    permissions:\n      contents: write\n    steps:\n      - name: Download artifact\n        uses: actions/download-artifact@v4\n        with:\n          # Artifact name\n          name: _book\n          # Destination path\n          path: docs\n      - name: Deploy to GitHub Pages\n        uses: Cecilapp/GitHub-Pages-deploy@v3\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          email: ${{ secrets.EMAIL }}\n          build_dir: docs\n          jekyll: no"},{"path":"chap-ci.html","id":"sec:confidentielCI","chapter":"6 Intégration continue","heading":"6.2.5 Données confidentielles dans un dépôt public","text":"Si le projet contient des données confidentielles (section 3.6), GitHub Actions doit utiliser la clé privée du projet pour les extraire de leur coffre-fort.La clé privée doit être stockée dans un secret du projet, nommé “RSA”.\nL’étape suivante, à insérer avant l’étape de tricot, écrit la clé dans un fichier pour que le code du projet y ait accès.","code":"      - name: Private key\n        run: |\n          cat(\"${{ secrets.rsa }}\", file=\"NomDuProjet.rsa\"\n        shell: Rscript {0}"},{"path":"chap-ci.html","id":"modèles-de-scripts","chapter":"6 Intégration continue","heading":"6.3 Modèles de scripts","text":"Des modèles de scripts pour tous les types de projets sont présentés ici.La branche gh-pages est créée automatiquement par les scripts.\nVérifier après la première exécution que les pages GitHub sont bien activées sur cette branche (section 3.7).\nSupprimer ensuite le dossier docs s’il existait, pousser la modification sur GitHub et enfin ajouter la ligne suivante au fichier .gitignore pour pouvoir tricoter localement les projets sans perturber GitHub :","code":"docs/"},{"path":"chap-ci.html","id":"sec:memoiR-ci","chapter":"6 Intégration continue","heading":"6.3.1 memoiR","text":"La fonction build_ghworkflow() du package memoiR crée automatiquement les scripts nécessaires à la production des modèles du package.\nLe script est toujours nommé memoir.yml.Ces scripts n’ont pas besoin d’un fichier DESCRIPTION pour l’installation des dépendances mais chaque document doit contenir son le bout de code de paramétrage (Options) la liste de tous les packages nécessaires à son tricot (stockés dans la variable Packages).Tous nécessitent même préparation : les secrets GH_PAT et EMAIL doivent être enregistrés dans le projet GitHub (section 6.2.2).","code":""},{"path":"chap-ci.html","id":"sec:bookdown-ci","chapter":"6 Intégration continue","heading":"6.3.1.1 Projet d’ouvrage","text":"Le flux de travail s’appelle rmarkdown ; sa tâche de production render.","code":"on:\n  push:\n   branches:\n     - master\n\nname: rmarkdown\n\njobs:\n  render:\n    runs-on: macOS-latest\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v4\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n      - name: Install dependencies\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"distill\", \"downlit\", \"memoiR\", \"rmdformats\", \"tinytex\"))\n          tinytex::install_tinytex(bundle = \"TinyTeX\")\n        shell: Rscript {0}\n      - name: Render pdf book\n        env:\n          GITHUB_PAT: ${{ secrets.GH_PAT }}\n        run: |\n          bookdown::render_book(\"index.Rmd\", \"bookdown::pdf_book\")\n        shell: Rscript {0}\n      - name: Render gitbook\n        env:\n          GITHUB_PAT: ${{ secrets.GH_PAT }}\n        run: |\n          bookdown::render_book(\"index.Rmd\", \"bookdown::gitbook\")\n        shell: Rscript {0}\n      - name: Upload artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: ghpages\n          path: docs\n  deploy:\n    runs-on: ubuntu-latest\n    needs: render\n    permissions:\n      contents: write\n    steps:\n      - name: Download artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: ghpages\n          path: docs\n      - name: Deploy to GitHub Pages\n        uses: Cecilapp/GitHub-Pages-deploy@v3\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          email: ${{ secrets.EMAIL }}\n          build_dir: docs\n          jekyll: no"},{"path":"chap-ci.html","id":"articles-et-présentations","chapter":"6 Intégration continue","heading":"6.3.1.2 Articles et présentations","text":"Le flux de travail s’appelle rmarkdown ; sa tâche de production render.L’étape chargée du tricot utilise un script pour lister tous les fichiers .Rmd, les traiter (tous les formats de sortie listés dans leur entête yaml sont produits).\nLa fonction build_githubpages() (voir section 4.3.2) place les résultat dans docs.La tâche de déploiement indique aux pages GitHub d’utiliser Jekyll, c’est-à-dire d’utiliser le fichier README.md comme page d’accueil.","code":"on:\n  push:\n   branches:\n     - master\n\nname: rmarkdown\n\njobs:\n  render:\n    runs-on: macOS-latest\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v4\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n      - name: Install dependencies\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"memoiR\", \"rmdformats\", \"tinytex\"))\n          tinytex::install_tinytex(bundle = \"TinyTeX\")\n        shell: Rscript {0}\n      - name: Render Rmarkdown files\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n        run: |\n          RMD_PATH=($(ls | grep \"[.]Rmd$\"))\n          Rscript -e 'for (file in commandArgs(TRUE)) |>\n              rmarkdown::render(file, \"all\")' ${RMD_PATH[*]}\n          Rscript -e 'memoiR::build_githubpages()'\n      - name: Upload artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: ghpages\n          path: docs\n  deploy:\n    runs-on: ubuntu-latest\n    needs: render\n    permissions:\n      contents: write\n    steps:\n      - name: Download artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: ghpages\n          path: docs\n      - name: Deploy to GitHub Pages\n        uses: Cecilapp/GitHub-Pages-deploy@v3\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          email: ${{ secrets.EMAIL }}\n          build_dir: docs\n          jekyll: yes"},{"path":"chap-ci.html","id":"internationalisation","chapter":"6 Intégration continue","heading":"6.3.1.3 Internationalisation","text":"Si l’étape de tricot nécessite de modifier la langue utilisée par R, par exemple pour afficher correctement la date de production des documents, elle peut être modifiée comme ceci :La sélection des fichiers est ici réalisée par un script R, qui inclut une commande de localisation, ici en Français.Cette étape peut être complétée par la sélection d’un thème GitHub Pages pour que la page d’accueil contienne un lien vers le code :Le thème est ici “Slate”, un des choix proposés par les pages GitHub.","code":"      - name: Render Rmarkdown files\n        run: |\n          Sys.setlocale(\"LC_TIME\", \"fr_FR\")\n          lapply(list.files(pattern=\"*.Rmd\"), \n                 function(file) rmarkdown::render(file, \"all\"))\n          memoiR::build_githubpages()\n        shell: Rscript {0}        run: |\n          echo 'theme: jekyll-theme-slate' > docs/_config.yml"},{"path":"chap-ci.html","id":"débogage","chapter":"6 Intégration continue","heading":"6.3.1.4 Débogage","text":"Il peut arriver que la compilation du fichier .tex pour produire le fichier PDF échoue, bien que le tricot en HTML ne génère pas d’erreur.\nLe compilateur LaTeX est en effet plus exigeant que pandoc (qui produit le fichier HTML).La première vérification consiste à tricoter en PDF localement, sur son poste de travail, le document qui pose problème, avec tinytex.\nLes packages LaTeX doivent être mis à jour pour être les mêmes que ceux utilisés par les actions GitHub : pour cela, exécuter :Si la compilation fonctionne localement mais pas sur Github, il faut inspecter le fichier .log qui enregistre tous les évènements générés par le compilateur, mais ce fichier n’est pas conservé après l’échec de GitHub Actions.\nIl faut donc modifier le script pour copier le fichier dans docs puis créer sauvegarder le résultat malgré l’erreur.L’étape “Upload artifact” est modifiée pour s’exécuter malgré l’échec de l’étape précédente en ajoutant la ligne : :Une étape est ajoutée avant “Upload artifact” pour copier le résultat du tricot et le fichier .log :Après l’échec de l’action, l’artéfact sauvegardé peut être téléchargé à partir de GitHub : il se trouve sur la page de résumé de l’action.\nIl s’agit d’un fichier compressé qui contient tout le dossier docs.","code":"\ntinytex::tlmgr_update()      - name: Upload artifact\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: _book\n          path: docs/      - name: Move files to docs\n        if: always()\n        run: |\n          Rscript -e 'memoiR::build_githubpages()'\n          cp *.log docs"},{"path":"chap-ci.html","id":"sec:blogdown-ci","chapter":"6 Intégration continue","heading":"6.3.2 Site web blogdown","text":"Le fichier appelé blogdown.yml est très similaire.\nLe nom du flux de travail est blogdown et celui de la tâche de production est buildsite.La tâche Build website utilise le package blogdown pour installer Hugo (le générateur de sites web) et ensuite construire le site.Si le site web utilise des données en ligne qui justifient de le mettre à jour périodiquement, GitHub Actions peut être lancé tous les jours, toutes les semaines ou tous les mois en plus des reconstruction déclenchées par une modification du dépôt (voir section 6.2.4.1).\nIci, le site est reconstruit tous les dimanches à 22h.Exemple : la page qui affiche la bibliométrie du site web117 de l’auteur interroge Google Scholar pour afficher les citations des publications.\nLe site est mis à jour toutes les semaines pour que les statistiques soient à jour.","code":"on:\n  push:\n     branches:\n       - master\n  schedule:\n    - cron: '0 22 * * 0'\n\nname: blogdown\n\njobs:\n  buildsite:\n    runs-on: macOS-latest\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v4\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n      - name: Install packages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"remotes\", \"blogdown\", \"formatR\"))\n          remotes::install_deps(dependencies = TRUE)\n        shell: Rscript {0}\n      - name: Build website\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_PAT }}\n        run: |\n          blogdown::install_hugo(force = TRUE)\n          blogdown::build_site(local = TRUE, build_rmd = TRUE)\n        shell: Rscript {0}\n      - name: Upload artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: _website\n          path: public/\n  deploy:\n    runs-on: ubuntu-latest\n    needs: buildsite\n    permissions:\n      contents: write\n    steps:\n      - name: Download artifact\n        uses: actions/download-artifact@v4\n        with:\n          # Artifact name\n          name: _website\n          # Destination path\n          path: public\n      - name: Deploy to GitHub Pages\n        uses: Cecilapp/GitHub-Pages-deploy@v3\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        with:\n          build_dir: public\n          email: ${{ secrets.EMAIL }}\n          jekyll: no"},{"path":"chap-ci.html","id":"sec:package-ci6","chapter":"6 Intégration continue","heading":"6.3.3 Packages R","text":"Un script optimal pour la vérification d’un package est le suivant :Le fichier est nommé check.yml.\nIl ne contient qu’une seule tâche, nommée R-CMD-check comme le flux.remotes installe les packages nécessaires à partir du fichier DESCRIPTION.L’étape Roxygenize met à jour la documentation du package.\nLes fichiers mis à jour sont poussés dans la branche principale du projet par l’action add--commit.\nCes deux étapes permettent de garantir que le package est dans un état cohérent, même si l’auteur omis d’exécuter la fonction roxygenize() avant de pousser son code sur GitHub.\nPour éviter de déclencher en boucle la vérification du code poussé de cette façon, le jeton d’accès utilisé est obligatoirement celui du script en cours, créé par GitHub à chaque exécution.\nCe jeton n’par défaut pas le droit de modifier le dépôt.\nIl faut donc le lui donner : sur GitHub, afficher les paramètres du projet et sélectionner “Actions”, “General”.\nDans la section “Workflow permissions”, sélectionner “Read write permissions”.L’étape Check vérifie le package.\nLes avertissements sont traités comme des erreurs.L’étape Test coverage utilise le package covr pour mesurer le taux de couverture et téléverse les résultats sur le site Codecov.Enfin, les deux dernières étapes installent le package puis utilisent pkgdown pour créer le site de documentation du package et le pousser dans la branche gh-pages du projet.Ce script ne contient qu’une tâche : le déploiement du site de documentation est directement exécuté par pkgdown.\nSon succès est affiché par un badge à afficher dans le fichier README.md (voir section 6.4)Des scripts plus complexes sont proposés par R-lib118, notamment pour exécuter les tests sur plusieurs systèmes d’exploitation et plusieurs versions de R.\nCes tests poussés sont à effectuer avant de soumettre à CRAN (section 5.11) mais consomment trop de ressource pour un usage systématique.","code":"on:\n  push:\n    branches:\n      - master\n\nname: R-CMD-check\n\njobs:\n  R-CMD-check:\n    runs-on: macOS-latest\n    steps:\n      - name: Pull the repository\n        uses: actions/checkout@v4\n      - name: Install R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n      - name: Install R packages\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"remotes\", \"roxygen2\", \"rcmdcheck\", \"covr\", \"pkgdown\"))\n          remotes::install_deps(dependencies = TRUE)\n        shell: Rscript {0}\n      - name: Update the documentation\n        run: roxygen2::roxygenize()\n        shell: Rscript {0}\n      - name: Commit and push the repository\n        uses: EndBug/add-and-commit@v9\n      - name: Check the package\n        run: rcmdcheck::rcmdcheck(args = \"--no-manual\", error_on = \"warning\")\n        shell: Rscript {0}\n      - name: Test coverage\n        run: covr::codecov(type=\"all\")\n        shell: Rscript {0}\n      - name: Install the package\n        run: R CMD INSTALL .\n      - name: Pkgdown\n        run: |\n          git config --local user.email \"actions@github.com\"\n          git config --local user.name \"GitHub Actions\"\n          Rscript -e 'pkgdown::deploy_to_branch(new_process = FALSE)'"},{"path":"chap-ci.html","id":"sec:ci-pr","chapter":"6 Intégration continue","heading":"6.3.4 Pull requests","text":"Les requêtes de tirage peuvent être testées par des scripts très proches pour vérifier qu’elles ne génèrent pas d’erreurs avant de les fusionner.Une méthode efficace consiste à créer un nouveau script dans le dossier .github/workflows/, en partant d’une copie du script existant.\nLe nouveau script sera nommé pr.yml.\nLe déclenchement doit être modifié : pull_request remplace push :","code":"on:\n  pull_request:\n     branches:\n       - master"},{"path":"chap-ci.html","id":"sec:memoiR-pr-ci","chapter":"6 Intégration continue","heading":"6.3.4.1 memoiR","text":"Les scripts de vérification des documents créés par memoiR doivent être coupés après l’étape Render gitbook : l’artefact ne doit pas être sauvegardé et la tâche de déploiement doit être supprimée.\nLe script est donc le suivant :","code":"on:\n  pull_request:\n    branches:\n      - master\n\nname: rmarkdown\n\njobs:\n  render:\n    runs-on: macOS-latest\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v4\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n      - name: Install dependencies\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"distill\", \"downlit\", \"memoiR\", \"rmdformats\", \"tinytex\"))\n          tinytex::install_tinytex(bundle = \"TinyTeX\")\n        shell: Rscript {0}\n      - name: Render pdf book\n        env:\n          GITHUB_PAT: ${{ secrets.GH_PAT }}\n        run: |\n          bookdown::render_book(\"index.Rmd\", \"bookdown::pdf_book\")\n        shell: Rscript {0}\n      - name: Render gitbook\n        env:\n          GITHUB_PAT: ${{ secrets.GH_PAT }}\n        run: |\n          bookdown::render_book(\"index.Rmd\", \"bookdown::bs4_book\")\n        shell: Rscript {0}\n      # Don't upload the artifact and don't deploy\n"},{"path":"chap-ci.html","id":"sec:package-pr-ci6","chapter":"6 Intégration continue","heading":"6.3.4.2 Packages R","text":"Les scripts de vérification des packages ne doivent pas pousser les mises à jour de leur documentation par Roxygenize2, ni déployer leur mise à jour du site pkgdown dans les pages GitHub.\nLe taux de couverture n’pas à être mesuré.\nLe script est le suivant :Quand des requêtes de tirage sont soumises, le test correspondant est lancé et ses résultats intégrés à la discussion.","code":"on:\n  pull_request:\n    branches:\n      - master\n\nname: R-CMD-check\n\njobs:\n  R-CMD-check:\n    runs-on: macOS-latest\n    steps:\n      - name: Pull the repository\n        uses: actions/checkout@v4\n      - name: Install R\n        uses: r-lib/actions/setup-r@v2\n      - name: Install pandoc\n        uses: r-lib/actions/setup-pandoc@v2\n      - name: Install R packages\n        run: |\n          options(pkgType = \"binary\")\n          options(install.packages.check.source = \"no\")\n          install.packages(c(\"remotes\", \"roxygen2\", \"rcmdcheck\", \"covr\", \"pkgdown\"))\n          remotes::install_deps(dependencies = TRUE)\n        shell: Rscript {0}\n      - name: Update the documentation\n        run: roxygen2::roxygenize()\n        shell: Rscript {0}\n        # Don't push\n      - name: Check the package\n        run: rcmdcheck::rcmdcheck(args = \"--no-manual\", error_on = \"warning\")\n        shell: Rscript {0}\n      # Don't test coverage\n      - name: Install the package\n        run: R CMD INSTALL .\n      - name: Pkgdown\n        # Build the package site locally\n        run: Rscript -e 'pkgdown::build_site()'"},{"path":"chap-ci.html","id":"sec:ci-badges","chapter":"6 Intégration continue","heading":"6.4 Ajouter des badges","text":"Le succès des Actions GitHub est visible en ajoutant un badge dans le fichier README.md, juste après le titre du fichier.\nSur la page du projet, choisir “Actions” puis sélectionner l’action (dans “Workflows”).\nCliquer sur le bouton “…” puis sur “Create Status Badge”.\nColler le code Markdown :Le nom du flux été déclaré dans l’entrée name: du fichier de configuration des actions GitHub.Le taux de couverture mesuré par Codecov peut aussi être affiché par un badge :","code":"# Nom du projet\n![bookdown](https://github.com/<GitHubID>/<Depot>/workflows/<NomDuFlux>/badge.svg)[![codecov](https://codecov.io/github/<GitHubID>/\n  <Depot>/branch/master/graphs/badge.svg)]\n  (https://codecov.io/github/<GitHubID>/<Depot>)"},{"path":"chap-shiny.html","id":"chap-shiny","chapter":"7 Shiny","heading":"7 Shiny","text":"Shiny permet de publier sous la forme d’un site web une application interactive utilisant du code R.\nLe site peut fonctionner localement, sur le poste de travail d’un utilisateur qui le lance à partir de RStudio, ou en ligne, sur un serveur dédié exécutant Shiny Server119.De façon basique, un formulaire permet de saisir les arguments d’un fonction et une fenêtre de visualisation d’afficher les résultats du calcul.L’utilisation d’une application Shiny rend très simple l’exécution du code, y compris pour des utilisateurs étrangers à R, mais limite évidemment les possibilités.","code":""},{"path":"chap-shiny.html","id":"première-application","chapter":"7 Shiny","heading":"7.1 Première application","text":"Dans RStudio, créer une application avec le menu “File > New File > Shiny Web App…”, saisir le nom de l’application “MonAppShiny” et sélectionner le dossier où la placer.Le nom de l’application servi à créer un dossier qu’il faut maintenant transformer en projet (menu des projets en haut à droite de RStudio, “New Project > Existing Directory”, sélectionner le dossier de l’application).Le fichier de l’application nommé app.R contient deux fonctions : ui() qui définit l’interface graphique et server() qui contient le code R à exécuter.\nL’application peut être lancée en cliquant sur “Run App” dans la fenêtre du code.\nFigure 7.1: Application Shiny Old Faithful Geyser Data.\nLa correspondance entre la fenêtre affichée (figure 7.1) et le code de la fonction ui() est simple à voir :le titre de l’application est affiché par la fonction titlePanel() ;le curseur qui fixe le nombre de barres de l’histogramme est créé par sliderInput() ;la fonction sidebarLayout() fixe la disposition des éléments de la page, sidebarPanel pour les contrôles de saisie et mainPanel() pour l’affichage du résultat.Le résultat est affiché par la fonction plotOutput() dont l’argument est le nom d’un élément de output, la variable remplie par la fonction server().Toute modification d’un élément de l’interface, précisément d’un élément affiché par une fonction dont le nom se termine par Input() (il en existe pour tous les types d’entrées, par exemple textInput()) de Shiny provoque l’exécution de server() et la mise à jour des éléments de output.","code":""},{"path":"chap-shiny.html","id":"application-plus-élaborée","chapter":"7 Shiny","heading":"7.2 Application plus élaborée","text":"","code":""},{"path":"chap-shiny.html","id":"méthode-de-travail","chapter":"7 Shiny","heading":"7.2.1 Méthode de travail","text":"Une application est créée en choisissant :une disposition de la fenêtre (layout) ;les contrôles de saisie des paramètres (intput) ;les contrôles d’affichage des résultats (output).Le code pour traiter les entrées et produire les sorties est ensuite écrit dans server().Le tutoriel de RStudio120 est très détaillé et doit être utilisé pour aller plus loin.","code":""},{"path":"chap-shiny.html","id":"exemple","chapter":"7 Shiny","heading":"7.2.2 Exemple","text":"Cette application simple utilise le package scholar pour interroger Google Scholar et obtenir les données bibliométriques d’un auteur à partir de son identifiant.Le fichier app.R contient tout le code et est construit progressivement ici.\nL’application complète, avec des sorties graphiques en plus de sa version simplifiée présentée ici est disponible sur GitHub121.Le début du code consiste à préparer l’exécution de l’application en chargeant les packages nécessaires :Le code de l’application complète intègre une fonction pour installer les packages manquants, à n’exécuter que quand l’application est exécutée sur un poste de travail (sur un serveur, la gestion des packages n’est pas du ressort de l’application).L’interface utilisateur est la suivante :La fenêtre de l’application est fluide, c’est-à-dire qu’elle se réorganise seule quand sa taille varie, et est composée d’un panneau latéral (pour la saisie et l’affichage de texte) et d’un panneau principal, pour l’affichage de graphiques.Les éléments du panneau latéral sont :un texte d’aide : helpText() ;un champ de texte à saisir, textInput(), dont les arguments sont le nom, le texte affiché, et la valeur par défaut (l’identifiant d’un auteur) ;un saut de ligne : br() ;des contrôles de sortie au format HTML : uiOutput(), dont l’argument unique est le nom.Le panneau principal contient deux contrôles de sortie graphiques, plotOutput() dont l’argument est aussi le nom.Le code à exécuter pour traiter les entrées et produire les sorties est dans la fonction server().Les informations nécessaires aux champs de sortie $name et $h (nom de l’auteur et indice h) sont obtenus par la fonction get_profile() du package scholar.\nCette fonction interroge la page web Google Scholar de l’auteur et extrait les valeurs du résultat : c’est une traitement lourd, qu’il vaut mieux n’exécuter qu’une seule fois plutôt que deux, dans les fonctions renderUI() chargées de calculer les valeurs de output$h et output$name.Le code le plus simple pour le faire serait le suivant :La difficulté de la programmation d’une application Shiny est que tout calcul se référant à un élément de l’interface d’entrée doit être réactif.\nSi ce dernier code était exécuté, le message d’erreur suivant apparaît :\n“Operation allowed without active reactive context. (tried something can done inside reactive expression observer.)”.En pratique, l’exécution du code est lancée par la modification d’un contrôle d’entrée (ici : intput$AuthorID).\nLe code faisant référence à un de ces contrôles doit être en permanence en attente d’une modification : il doit donc placé dans des fonctions particulières comme renderPlot() dans l’application Old Faithful Geyser Data ou renderUI() ici.\nLe code suivant s’exécuterait sans erreur :L’appel à la valeur du contrôle input$AuthorID bien lieu dans une fonction réactive (mais get_profile() devrait être utilisé une deuxième fois dans le calcul de output$h, ce que nous voulons éviter).\nLa fonction h2(AuthorProfile$name) produit du code HTML, un paragraphe de titre de niveau 2 dont la valeur est passée en argument.Toutes les fonctions dont le nom commence par render dans le package shiny sont réactives, et chacune est destinée à produire un type de sortie différent, par exemple du texte (renderText()) ou du code HTML (renderUI()).Si du code est nécessaire pour calculer des variables communes à plusieurs contrôles de sortie (output$name et output$h), il doit lui-même être réactif.\nDeux fonctions sont très utiles :observeEvent() surveille les changements d’un contrôle d’entrée et exécute du code quand ils se produisent ;reactiveVal() permet de définir une variable réactive, qui sera modifiée par le code de observeEvent() et entraînera à son tour l’exécution d’autres fonctions réactives qui utilisent sa valeur.Le code optimal crée donc une variable réactive pour y stocker le résultat de l’interrogation de Google Scholar :La variable réactive est vide à ce stade.\nSon utilisation est ensuite celle d’une fonction : AuthorProfile(x) lui attribue la valeur x et AuthorProfile(), sans argument, renvoie sa valeur.\nLa fonction observeEvent() est déclenchée quand input$AuthorID est modifié et exécute le code passé en deuxième argument, ici la mise à jour de AuthorProfile.Enfin, les fonctions renderUI() qui fournissent les valeurs des contrôles de sortie utilisent la valeur de AuthorProfile :Remarquer les parenthèses de AuthorProfile(), variable réactive, par opposition à la syntaxe AuthorProfile$name pour une variable classique.La valeur de output$h est un lien internet, <href=... en HTML, écrit par la fonction () du package htmltools utilisé par renderUI().Le lien est vers la page Google Scholar de l’auteur.\nLa valeur affichée est son indice h.\nL’argument target = \"_blank\" indique que le lien doit être ouvert dans une nouvelle fenêtre du navigateur.Le graphique output$citations est créé par la fonction réactive renderPlot().\nLes données fournies par la fonction get_citation_history() de scholar (qui interroge l’API de Google Scholar) sont traitées par ggplot().Enfin, le graphique output$network est un graphique vide dans cette version simplifiée de l’application.L’application complète reprend ce code en y ajoutant le traitement des erreurs dans le cas où le code de l’auteur n’existe par sur Google Scholar et le graphique du réseau des co-auteurs.","code":"\n# Prepare the application ####\n# Load packages\nlibrary(\"shiny\")\nlibrary(\"tidyverse\")\n# UI ####\nui <- fluidPage(\n  # Application title\n  titlePanel(\"Bibliometrics\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Enter the Google Scholar ID of an author.\"),\n      textInput(\"AuthorID\", \"Google Scholar ID\", \"4iLBmbUAAAAJ\"),\n      # End of input\n      br(),\n      # Display author's name and h\n      uiOutput(\"name\"),\n      uiOutput(\"h\")\n    ),\n    # Show plots in the main panel\n    mainPanel(\n      plotOutput(\"network\"),\n      plotOutput(\"citations\")\n    )\n  )\n)\n# Server logic ####\nserver <- function(input, output) {\n  # Run the get_profile function only once ####\n  # Store the author profile\n  AuthorProfile <- reactiveVal()\n  # Update it when input$AuthorID is changed\n  observeEvent(input$AuthorID, \n               AuthorProfile(get_profile(input$AuthorID)))\n  \n  # Output ####\n  output$name <- renderUI({\n    h2(AuthorProfile()$name)\n  })\n  \n  output$h <-\n    renderUI({\n      a(href = paste0(\n        \"https://scholar.google.com/citations?user=\", \n        input$AuthorID),\n        paste(\"h index:\", AuthorProfile()$h_index),\n        target = \"_blank\"\n      )\n    })\n  \n  output$citations <- renderPlot({\n    get_citation_history(input$AuthorID)  %>%\n      ggplot(aes(year, cites)) +\n      geom_segment(aes(xend = year, yend = 0),\n                   size = 1,\n                   color =\n                     'darkgrey') +\n      geom_point(size = 3, color = 'firebrick') +\n      labs(title = \"Citations per year\",\n           caption = \"Source: Google Scholar\")\n  })\n  \n  output$network <- renderPlot({\n    ggplot() + geom_blank()\n  })\n}\n  # Run the get_profile function only once ####\n  # Store the author profile\n  AuthorProfile <- get_profile(input$AuthorID)\n# Output ####\noutput$name <- renderUI({\n    AuthorProfile <- get_profile(input$AuthorID)\n    h2(AuthorProfile$name)\n})\n# Store the author profile\nAuthorProfile <- reactiveVal()\n# Update it when input$AuthorID is changed\nobserveEvent(input$AuthorID, AuthorProfile(get_profile(input$AuthorID)))\n# Output ####\noutput$name <- renderUI({\n    h2(AuthorProfile()$name)\n})\noutput$h <- renderUI({\n    a(href = paste0(\"https://scholar.google.com/citations?user=\",\n        input$AuthorID), paste(\"h index:\", AuthorProfile()$h_index),\n        target = \"_blank\")\n})"},{"path":"chap-shiny.html","id":"sec:hebergement-shiny","chapter":"7 Shiny","heading":"7.3 Hébergement","text":"Une application Shiny n’est pas forcément hébergée par un serveur web : elle peut être exécutée sur les postes de travail des utilisateurs s’ils disposent de R.Pour un usage plus large, un serveur dédié est nécessaire.\nShinyapps.io122 est un service de RStudio qui permet d’héberger gratuitement 5 applications Shiny avec un temps de fonctionnement maximal de 5 heures par mois.Il faut tout d’abord ouvrir un compte sur le site, de préférence avec ses identifiants GitHub.\nPour permettre la gestion des applications en ligne directement depuis RStudio, il faut installer ensuite le package rsconnect et le paramétrer :Le code exact, avec le nom d’utilisateur et le jeton à utiliser, sont affichés sur la page d’accueil de Shinyapps.io : cliquer sur “Show Secret”, copier le code et le coller dans la console de RStudio pour l’exécuter.\nUn bouton “Publish” est disponible juste à droite du bouton “Run App”.\nCliquer dessus et valider la publication (figure 7.2).\nFigure 7.2: Publication de l’application Shiny sur Shinyapps.io.\nL’application est maintenant accessible à l’adresse https://prenom-nom.shinyapps.io/MonAppShiny/L’application “Bibliometrics” ne fonctionne pas sur Shinyapps.io parce que la façon dont le package Scholar interroge Google Scholar n’est pas supportée.\nLa plupart des applications Shiny fonctionnent sans difficulté, tant qu’elles ne nécessitent pas de fonctionnalités réseau complexes.","code":"\nrsconnect::setAccountInfo(name = \"prenom.nom\", token = \"xxx\",\n    secret = \"<SECRET>\")"},{"path":"chap-enseigner.html","id":"chap-enseigner","chapter":"8 Enseigner avec R","heading":"8 Enseigner avec R","text":"R, RStudio et GitHub fournissent des outils pour enseigner.Le package learnr permet de réaliser des tutoriels interactifs.verra aussi comment utiliser les salles de classe GitHub (GitHub Classrooms) qui permettent de diffuser à une classe (une liste d’étudiants disposant d’un compte GitHub) un modèle de dépôt (un début de projet R) que chaque étudiant devra développer et publier.\nLes outils de la salle de classe permettent d’évaluer le travail fourni assez simplement.","code":""},{"path":"chap-enseigner.html","id":"learnr","chapter":"8 Enseigner avec R","heading":"8.1 learnr","text":"learnr permet de rendre interactifs les bouts de code de n’importe quel document produit par R Markdown en HTML, en les transformant en applications Shiny.\nLa documentation sur le site de RStudio123 est très claire et ne sera pas reprise ici : nous verrons seulement comment commencer et comment diffuser les tutoriels.","code":""},{"path":"chap-enseigner.html","id":"premier-tutoriel","chapter":"8 Enseigner avec R","heading":"8.1.1 Premier tutoriel","text":"Utiliser comme pour tous les documents le menu “File > New File > RMarkdown…” et créer un nouveau document à partir d’un modèle “Interactive Tutorial”.\nL’assistant crée un dossier du nom choisi, à transformer en projet R et passer sous contrôle de source, comme pour tous les documents vus précédemment (voir section 4.3.2).Pour exécuter le tutoriel, cliquer sur le bouton “Run Document” qui se trouve à place habituelle du bouton “Tricoter”.Les tutoriels peuvent inclure des exercices, qui sont des bouts de code avec l’option exercise=TRUE.\nCes exercices sont affichés sous la forme d’une fenêtre de code modifiable et exécutable par l’utilisateur.\nDes indices peuvent être donnés124, un bouton ajouté pour afficher la solution, une limite de temps peut être fixée125, et le code comme son résultat peuvent être comparés à une valeur attendue126.Des quizz127 peuvent être ajoutés, sous la forme de questionnaires à choix multiples ou uniques.La progression de l’utilisateur dans le tutoriel (code saisi, réponses aux questions…) est sauvegardée par learnr sur le poste de travail.\nUn tutoriel peut être arrêté puis repris sans perte de données.\nEn revanche, il n’y pas de moyen simple de récupérer ces données pour une évaluation par le formateur par exemple.","code":""},{"path":"chap-enseigner.html","id":"diffusion","chapter":"8 Enseigner avec R","heading":"8.1.2 Diffusion","text":"Les tutoriels peuvent être diffusés en copiant les fichiers ou en indiquant aux utilisateurs de cloner les projets GitHub qui les contiennent.Ils peuvent aussi être hébergés sur Shinyapps.io (voir section 7.3).Enfin, ils peuvent être inclus dans un package128.","code":""},{"path":"chap-enseigner.html","id":"github-classrooms","chapter":"8 Enseigner avec R","heading":"8.2 GitHub Classrooms","text":"GitHub Classrooms permet de diffuser à un public étudiant des dépôts GitHub à modifier et de contrôler le résultat.\nLes applications sont aussi bien l’apprentissage de R que la production de documents, pour un travail personnel ou un examen par exemple.","code":""},{"path":"chap-enseigner.html","id":"inscription","chapter":"8 Enseigner avec R","heading":"8.2.1 Inscription","text":"Pour commencer à utiliser l’outil, il faut ouvrir un compte.\nSur le site de GitHub Classrooms129, cliquer sur “Sign ” et utiliser son compte GitHub pour s’authentifier.","code":""},{"path":"chap-enseigner.html","id":"organisations","chapter":"8 Enseigner avec R","heading":"8.2.2 Organisations","text":"L’étape suivant consiste à créer une organisation GitHub.\nUne organisation GitHub contient essentiellement des membres (titulaires d’un compte GitHub) et des dépôts accessibles à l’adresse https://github.com/Organisation/Depot.La façon la plus simple de travailler consiste à créer une organisation par cours mais d’autres approches sont possibles dans des structures utilisant intensivement l’outil.\nL’organisation crée pour l’exemple est ici “Cours-R”130.Une adresse de messagerie est nécessaire (utiliser la même que celle de son compte GitHub) et l’organisation doit être déclarée comme appartenant à son compte personnel.Si l’organisation n’est pas visible sur la page de GitHub Classrooms, cliquer sur “Grant us access”.","code":""},{"path":"chap-enseigner.html","id":"nouvelle-salle-de-classe","chapter":"8 Enseigner avec R","heading":"8.2.3 Nouvelle salle de classe","text":"Une salle de classe (classroom) est peuplée d’étudiants qui recevront des tâches (assignments) à exécuter.Cliquer sur New Classroom.\nSélectionner l’organisation en charge de l’administration de la salle de classe.Saisir le nom de la salle de classe : une bonne pratique est de la préfixer par le nom du cours et d’ajouter le nom de la session, par exemple “Cours-R-2020-EdGuyane”.Ne pas ajouter de collaborateurs (ce sera possible plus tard), et saisir éventuellement la liste des étudiants (un nom par ligne, possible plus tard aussi).\nLa classe est créée.Toutes les salles de classe sont visibles depuis la page d’accueil de GitHub Classrooms131.\nCliquer sur un nom pour en ouvrir une.\nLe bouton “Settings” permet de changer son nom ou de la supprimer.\nLe bouton “TAs Admins” permet d’ajouter des collaborateurs, c’est-à-dire d’autres utilisateurs GitHub qui pourront administrer la salle de classe.Le bouton “Students” permet d’ajouter des étudiants.\nLa liste de nom est libre, sans format obligatoire.\nCliquer sur “Create Roster” pour l’activer.\nLes noms doivent ensuite être liés à des comptes GitHub : ce travail peut être fait par l’administrateur ou par les étudiants eux-mêmes quand ils recevront la première tâche à effectuer.\nChaque étudiant doit avoir un compte sur GitHub.","code":""},{"path":"chap-enseigner.html","id":"préparer-un-modèle-de-dépôt","chapter":"8 Enseigner avec R","heading":"8.2.4 Préparer un modèle de dépôt","text":"Une tâche est un dépôt GitHub à modifier.\nPar exemple132, créer un dépôt contenant un projet R avec un fichier Markdown décrivant le travail à faire et éventuellement une partie du code nécessaire pour y parvenir, les autres fichiers du modèle R Markdown utilisé et un fichier de données.Ouvrir les propriétés du dépôt sur GitHub et cocher la case Template Repository pour en faire un modèle.","code":""},{"path":"chap-enseigner.html","id":"assigner-une-tâche","chapter":"8 Enseigner avec R","heading":"8.2.4.1 Assigner une tâche","text":"Ouvrir une salle de classe et cliquer sur “New Assignment”.Saisir un titre explicite pour les étudiants, une date limite optionnelle et choisir “Individual Assignment”.Par défaut, le nom de la tâche sert de préfixe pour le nom des dépôts des étudiants mais il peut être remplacé par un préfixe choisi.\nQuand les étudiants rendront leur travail, tous les dépôts de toutes les tâches seront stockés dans l’organisation.Le dépôt crée sur le compte de chaque étudiant peut être privé ou public, selon que l’souhaite que les étudiants puissent voir le travail des autres ou non.\nDonner le droit d’administration et rendre le site public si les étudiants doivent pouvoir activer les pages GitHub pour présenter le résultat de leur travail.\nCliquer sur “Continue”.Sélectionner le dépôt modèle (starter code) puis cliquer sur “Continue” puis “Create Assignment”.La nouvelle tâche est créée.\nElle est associée à un lien d’invitation qu’il faut copier et envoyer aux étudiants.\nQuand ils cliqueront sur le lien, ils atteindront une page GitHub qui leur permettra d’associer leur compte à un nom de la liste (aucun contrôle n’est possible : le premier connecté peut s’associer à n’importe quel nom).\nIls pourront ensuite créer un nouveau projet RStudio à partir du dépôt GitHub créé automatiquement par GitHub Classrooms, modifier ce projet selon les consignes de travail et le pousser sur GitHub.\nLe dépôt se trouve sur le compte de l’organisation à laquelle la classe est reliée, et est suffixé par l’identifiant GitHub de l’étudiant.","code":""},{"path":"chap-enseigner.html","id":"contrôler-le-travail-des-étudiants","chapter":"8 Enseigner avec R","heading":"8.2.4.2 Contrôler le travail des étudiants","text":"Il est possible d’afficher chaque dépôt crée par les étudiants à partir de la page de la tâche sur GitHub Classrooms.\nSi le travail à produire est un document rédigé, demander aux étudiants de le placer dans les pages GitHub du dépôt pour le lire directement en ligne.L’assistant GitHub Classrooms133 permet de télécharger en une fois tous les dépôts des étudiants pour les corriger sur son poste de travail.","code":""},{"path":"chap-conclusion.html","id":"chap-conclusion","chapter":"9 Conclusion","heading":"9 Conclusion","text":"L’environnement de travail de R et RStudio permet de produire tous types de documents avec un langage unique.L’objectif de reproductibilité des résultats est atteint en intégrant les traitements statistiques et la rédaction.\nLe travail collaboratif est permis par l’utilisation systématique du contrôle de source et de GitHub.\nLa présentation des résultats est assurée par les pages GitHub et des modèles de documents couvrant la majorité des besoins.Pour les pauses, R fournit même quelques jeux dans le package fun, dont le célèbre démineur :Ce document n’pas pour objectif d’être exhaustif sur les possibilités de R mais plutôt de présenter une méthode de travail et des moyens simples de l’appliquer rapidement.\nse reportera aux ouvrages plus détaillés cités dans le texte pour approfondir tel ou tel point.Il est mis à jour régulièrement en fonction de l’évolution des outils disponibles.","code":"\n# Installation du package\ninstall.packages(\"fun\")\n# Ouverture d'une fenêtre X et exécution\nif (interactive()) {\n    if (.Platform$OS.type == \"windows\")\n        x11() else x11(type = \"Xlib\")\n    fun::mine_sweeper()\n}"},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
