# Intégration continue {#chap:ci}

L'intégration continue consiste à confier à un service externe la tâche de vérifier un package, produire des documents Markdown pour les pages web d'un dépôt GitHub ou tricoter entièrement un site web à partir du code.

Toutes ces tâches peuvent être accomplies localement sur le poste de travail mais prennent du temps et risquent de ne pas être répétées à chaque mise à jour.
Dans le cadre de l'intégration continue, elles le sont systématiquement, de façon transparente pour l'utilisateur.
En cas d'échec, un message d'alerte est envoyé.

La mise en place de l'intégration continue se justifie pour des projets lourds, avec des mises à jour régulières.
plutôt que pour des projets contenant un simple document Markdown rarement modifié.

## Outils

### GitHub Actions

L'outil utilisé le plus fréquemment pour des projets R déposés sur GitHub était *Travis CI*[^ci-1] mais le service est devenu payant en 2021.

[^ci-1]: <https://travis-ci.org/>

Les Actions GitHub remplacent avantageusement Travis. 
Ce service est intégré à GitHub.

### Codecov

Pour évaluer le taux de couverture du code des packages R, c'est-à-dire la proportion du code testé d'une façon ou d'une autre (exemples, tests unitaires, vignette), le service *Codecov*[^ci-2] s'intègre parfaitement à GitHub.

[^ci-2]: <https://codecov.io/>

Il faut ouvrir un compte, de préférence en s'authentifiant par GitHub.

### GitHub Pages

Les pages web de GitHub peuvent être hébergées dans le répertoire `docs` de la branche master du projet: c'est la solution retenue quand elle sont produites sur le poste de travail.

Si elles sont produites par intégration continue, elle le seront obligatoirement dans une branche dédiée appelée `gh-pages`.


## Principes

Un projet de document est traité en exemple.
L'objectif est de faire tricoter par GitHub un projet Markdown.
Cette pratique est appropriée pour les projets d'ouvrages, qui nécessitent beaucoup de ressources pour leur construction.
Dans ce type de projet, le code est tricoté par knitr pour produire plusieurs documents, typiquement aux formats HTML et PDF, accessibles sur les pages GitHub.
Quand les documents sont produits localement, ils sont placés dans le dossier `docs` et poussés sur GitHub.

Pour que GitHub s'en charge, quelques réglages sont nécessaires.


### Obtention d'un jeton d'accès personnel {#sec:pat}

Pour écrire sur GitHub, le service d'intégration continue devra s'authentifier au moyen d'une clé privée, appelée *Personal Access Token* (PAT).

Les jetons sont créés sur GitHub, dans les paramètres de son compte d'utilisateur, dans \*Developer Settings, Personal Access Tokens"[^ci-3].

[^ci-3]: <https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line>

Générer un nouveau jeton, le décrire en tant que "GitHub Actions" et lui donner l'autorisation "repo", c'est-à-dire modifier *tous* les dépôts (il n'est pas possible de limiter l'accès à un dépôt particulier).
Le jeton est une chaîne de caractère qui ne pourra pas être relue plus tard: elle doit être sauvegardée comme un mot de passe.


### Secrets du projet {#sec:secrets-ci}

Sur GitHub, afficher les paramètres du projet et sélectionner "Secrets".
Le bouton *New Repository Secret* permet de stocker des variables utilisées dans les scripts des Actions GitHub (visibles publiquement) sans en diffuser la valeur.
Le jeton d'accès personnel est indispensable pour que les Actions GitHub puissent écrire leur production dans le projet.
Créer un secret nommé "GH_PAT" et saisir la valeur du jeton sauvegardée précédemment.
Après avoir cliqué sur *Add Secret*, le jeton ne pourra plus être lu.

Pour permettre l'envoi de messages de succès ou d'échec sans diffuser son adresse de messagerie, créer un secret nommé "EMAIL" qui la contient.


### Activation du dépôt sur CodeCov

L'analyse de la couverture du code des packages est utile pour détecter les portions de code non testées.
En revanche, l'analyse de la couverture des projets de document n'a pas d'intérêt.

Pour activer un dépôt, il faut d'authentifier sur le site de CodeCov avec son compte GitHub.
La liste des dépôts est affichée et peut être actualisée.
Si les dépôts à traiter sont hébergés par une organisation, par exemple les dépôts d'une salle de classe GitHub, il faut actualiser la liste des organisations en suivant les instructions (un lien permet de modifier rapidement les options de GithHub pour autoriser la lecture d'une organisation par Codecov) et à nouveau mettre à jour la liste des dépôts.
Enfin, quand le dépôt recherché est visible, il faut l'activer.
Il est inutile d'utiliser le système de jetons de Codecov.


### Scripter les actions de GitHub

Un flux de travail (*workflow*)  de GitHub est une succession de tâches (*jobs*) comprenant des étapes (*steps*).
Un flux de travail est déclenché par un évènement, généralement chaque *push* du projet, mais aussi à intervalles réguliers (*cron*).

Typiquement, les flux créés ici contiennent deux tâches: la première installe R et les composants nécessaires et exécute des scripts R (ce qui constitue ses étapes successives); la seconde publie des fichiers obtenus dans les pages GitHub.

Les flux de travail sont configurés dans un fichier au format YAML placé dans le dossier `.github/workflows/` du projet.
Les différentes parties du script sont présentées ci-dessous.
Le script complet est celui de ce document, accessible sur GitHub[^ci-10].

[^ci-10]: <https://github.com/EricMarcon/travailleR/blob/master/.github/workflows/bookdown.yml>


#### Déclenchement {#sec:declenchement}

L'action est déclenchée à chaque fois que des mises à jour sont poussées sur GitHub:
```
on:
  push:
     branches:
       - master
```

La branche prise en compte est *master* (à remplacer par *main* le cas échéant).

Pour déclencher l'action périodiquement, il faut utiliser la syntaxe de *cron* (le système de planification des tâches sous Unix):
```
on:
  schedule:
    - cron: '0 22 * * 0'  # every sunday at 22:00
```

Les valeurs successives sont celles des minutes, des heures, du jour (quantième du mois), du mois et du jour de la semaine (0 pour dimanche à 6 pour samedi). 
Les `*` permettent d'ignorer une valeur.

Les entrées `push` et `schedule` peuvent être utilisées ensemble: 
```
on:
  push:
     branches:
       - master
  schedule:
    - cron: '0 22 * * 0'
```

#### Nom du flux de travail

Le nom du flux est libre.
Il sera affiché par le badge qui sera ajouté dans le fichier `README.md` du projet (voir section \@ref(sec:ci-badges)).
```
name: bookdown
```

#### Première tâche

Les tâches sont décrites dans la rubrique `jobs`.
`renderbook` est le nom de la première tâche: il est libre.
Ici, l'action principale consistera à produire un ouvrage bookdown avec la fonction `render_book()`, d'où son nom. 

```
jobs:
  renderbook:
    runs-on: macOS-latest
```

La déclaration `runs-on` décrit le système d'exploitation sur lequel la tâche doit s'exécuter.
Les choix possibles sont Windows, Ubuntu ou MacOS[^ci-11].
L'intégration continue de R sur GitHub utilise habituellement MacOS. 

[^ci-11]: <https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on>


#### Premières étapes

Les étapes sont décrites dans la rubrique `steps`.

```
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2
      - name: Setup R
        uses: r-lib/actions/setup-r@v1
      - name: Install pandoc
        run: |
          brew install pandoc
```

Chaque étape est décrite par son nom (libre) et ce qu'elle réalise. 

La force de GitHub Actions est de permettre l'utilisation d'*actions* écrites par d'autres et stockées dans un projet public GitHub.
Une action est un script accompagné de métadonnées qui décrivent son usage.
Son développement est accompagné par des numéros de version successifs.
On appelle une action par l'instruction `uses:`, le projet GitHub qui la contient et sa version.

Les actions généralistes sont mises à disposition par GitHub dans l'organisation GitHub Actions[^ci-12].
L'action "actions/checkout" permet de se placer dans la branche principale du projet traité par le flux de travail: c'est en général la première étape de tous les flux.

[^ci-12]: https://github.com/actions/

L'action suivante est l'installation de R, mise à disposition par l'organisation R infrastructure[^ci-13].

[^ci-13]: https://github.com/r-lib/

L'installation de pandoc (logiciel extérieur à R mais nécessaire à R Markdown) est réalisée par une commande exécutée par MacOS.
Elle est appelée par `run:` et peut contenir plusieurs lignes (d'où le `|`).
Ce script dépend du système d'exploitation: `brew` est le gestionnaire de paquets de MacOS.


#### Caches

L'installation des packages de R prend du temps, beaucoup s'ils sont installés à partir des sources (la procédure standard sous Ubuntu, mais pas sous MacOS et Windows où les packages binaires sont utilisés par défaut).
Le calcul des bouts de code est en général l'étape la plus longue du flux de travail.
L'action `cache` permet de mettre en cache les résultats des deux opérations.

```
      - name: Cache Renv packages
        uses: actions/cache@v2
        with:
          path: $HOME/.local/share/renv
          key: r-${{ hashFiles('renv.lock') }}
          restore-keys: r-
      - name: Cache bookdown results
        uses: actions/cache@v2
        with:
          path: _bookdown_files
          key: bookdown-${{ hashFiles('**/*Rmd') }}
          restore-keys: bookdown-
```

Le cache est mis à jour en cas de modification d'un package ou d'un bout de code, ce qui nécessite un moyen rapide de vérifier les modifications: une valeur de contrôle (*hashtag*) est calculée par la fonction `hashFiles()` à partir du fichier `renv.lock` (voir ci-dessous) pour les packages et l'ensemble des fichiers `.Rmd` pour les bouts de code.
Tout changement entraîne la réinstallation des packages ou le recalcul de l'ensemble du code: la gestion du cache est moins fine que celle de R sur un poste de travail, qui ne recalcule que les bouts de code modifiés.


#### Packages {#sec:packages-ci}

L'installation des packages est gérée par la fonction `install.packages()`.
Plutôt que d'énumérer les packages à installer dans les arguments de la fonction, source d'erreur, il est préférable d'utiliser le package **renv** pour enregistrer tous les packages utilisés par le projet et les installer en une fois pour l'intégration continue. 
**renv** installera les packages dans la version enregistrée, ce qui permet d'éviter des effets imprévus dus à des versions différentes entre le poste de travail et GitHub Actions.

```
      - name: Install packages
        run: |
          R -e 'install.packages("renv")'
          R -e 'renv::restore()'
```

Il est nécessaire d'installer **renv** sur le poste de travail utilisé pour le développement du projet.

Il faut utiliser un fichier `DESCRIPTION` pour lister les packages de tout projet, comme si c'était un package R.
Pour ce document:
```
Package: travailleR
Title: Travailler avec R
Version: 1.1.0
Authors@R: c(
  person("Eric", "Marcon", , "e.marcon@free.fr", c("aut", "cre"))
  )
URL: https://github.com/EricMarcon/travailleR
Imports:
  bookdown,
  (...)
```

Avant de déclencher le flux de travail, il est nécessaire de créer la liste des packages dans leur version en cours sur le poste de travail:
```{r, eval=FALSE}
renv::snapshot(type="explicit")
```

A sa première utilisation, le package **renv** informe de quelques adaptations de l'environnement de travail, qu'il faut accepter.

Cette commande crée le fichier `renv.lock` qui est utilisé par GitHub Actions pour installer les packages pendant l'intégration continue.
Il pourra être mis à jour à tout moment pour prendre en compte leur mise à jour.


#### Tricot

La production de l'ouvrage est lancée par une commande R. 

```
      - name: Render book
        run: Rscript -e 'bookdown::render_book("index.Rmd", quiet = TRUE)'
```

Les formats à produire sont paramétrés dans `_output.yml`:
```
bookdown::pdf_book:
  (...)
bookdown::gitbook:
  (...)
```

Le fichier PDF doit être produit avant le format GitBook pour que son lien de téléchargement soit ajouté à la barre de menu du site GitBook.


#### Sauvegarde

Le résultat du tricot, placé dans le dossier `docs` de la machine virtuelle en charge de l'intégration continue, doit être préservé pour que la tâche suivante puisse l'utiliser.

La dernière étape de la tâche de production utilise l'action `upload-artifact` pour cela.
```
      - name: Upload artifact
        uses: actions/upload-artifact@v1
        with:
          name: _book
          path: docs/
```

Le contenu de `docs` est sauvegardé en tant qu'*artefact* nommé "_book".
Les artefacts sont visibles publiquement sur la page des Actions du projet GitHub.

Après sa dernière étape, la machine virtuelle utlisée pour cette étape est détruite.


#### Publication

La publication de l'artefact dans la brache `gh-pages` du projet nécessite une autre tâche.

```
  checkout-and-deploy:
    runs-on: ubuntu-latest
    needs: renderbook
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Download artifact
        uses: actions/download-artifact@v1
        with:
          # Artifact name
          name: _book
          # Destination path
          path: docs
      - name: Deploy to GitHub Pages
        uses: Cecilapp/GitHub-Pages-deploy@v3
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          email: ${{ secrets.EMAIL }}
          build_dir: docs
          jekyll: no
```

La tâche est nommée "checkout-and-deploy" (le nom est libre).
Elle s'exécute sur une machine virtuelle sous Ubuntu.
Elle ne peut se lancer que si la tâche "renderbook" a réussi.
Ses étapes sont les suivantes:

- *Checkout*: Placement dans la branche principale du projet;
- *Download artifact*: Restauration du dossier `docs`;
- *Deploy to GitHub Pages*: copie du dossier `docs` dans la branche `gh-pages`.

Cette dernière étape utiliser l'action `GitHub-Pages-deploy` mise à disposition par l'organisation *Cecilapp* .
Elle utilise une variable d'environnement, `GITHUB_TOKEN`, pour s'authentifier et des paramètres:

- *email*: l'adresse de messagerie destinataire du rapport d'exécution.
Pour ne pas exposer l'adresse publiquement, elle a été stockée dans un secret du projet;
- *buid_dir*: le répertoire à publier,
- *jekyll:no* pour créer un fichier vide nommé `.nojekyll` qui indique aux pages GitHub de ne pas essayer de traiter leur contenu comme un site web Jekyll.


## Modèles de scripts

Des modèles de scripts pour tous les types de projets sont présentés ici, en commençant par la version complète du précédent.
Tous nécessitent même préparation:

- les secrets `GH_PAT` et `EMAIL` doivent être enregistrés dans le projet GitHub (section \@ref(sec:secrets-ci));
- un fichier `DESCRIPTION` doit être utilisé pour lister les packages nécessaires (section \@ref(sec:package-description)), quel que soit le type de projet;
- un instantané des packages installés (`renv.lock`) doit être réalisé avec **renv** (section \@ref(sec:packages-ci)).


#### Projet d'ouvrage {#sec:bookdown-ci}

Le flux de travail s'appelle `bookdown`; sa tâche de production `renderbook`.
Le fichier est `bookdown.yml`.

```
on:
  push:
     branches:
       - master

name: bookdown

jobs:
  renderbook:
    runs-on: macOS-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2
      - name: Setup R
        uses: r-lib/actions/setup-r@v1
      - name: Install pandoc
        run: |
          brew install pandoc
      - name: Cache Renv packages
        uses: actions/cache@v2
        with:
          path: $HOME/.local/share/renv
          key: r-${{ hashFiles('renv.lock') }}
          restore-keys: r-
      - name: Cache bookdown results
        uses: actions/cache@v2
        with:
          path: _bookdown_files
          key: bookdown-${{ hashFiles('**/*Rmd') }}
          restore-keys: bookdown-
      - name: Install packages
        run: |
          R -e 'install.packages("renv")'
          R -e 'renv::restore()'
      - name: Render book
        run: Rscript -e 'bookdown::render_book("index.Rmd", quiet = TRUE)'
      - name: Upload artifact
        uses: actions/upload-artifact@v1
        with:
          name: _book
          path: docs/
  checkout-and-deploy:
    runs-on: ubuntu-latest
    needs: renderbook
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Download artifact
        uses: actions/download-artifact@v1
        with:
          # Artifact name
          name: _book
          # Destination path
          path: docs
      - name: Deploy to GitHub Pages
        uses: Cecilapp/GitHub-Pages-deploy@v3
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          email: ${{ secrets.EMAIL }}
          build_dir: docs
          jekyll: no
```


#### Site web blogdown {#sec:blogdown-ci}

Le fichier appelé `blogkdown.yml` est très similaire, mais le contexte est différent: le code du site web est ici dans la branche `source` du dépôt (voir section \@ref(sec:blogdown)).
Le nom du flux de travail est `blogdown` et celui de la tâche de production est `buildsite`.

```
on:
  push:
     branches:
       - source
  schedule:
    - cron: '0 22 * * 0'

name: blogdown

jobs:
  buildsite:
    runs-on: macOS-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2
        with:
          ref: 'source'
      - name: Setup R
        uses: r-lib/actions/setup-r@v1
      - name: Install pandoc
        run: |
          brew install pandoc
      - name: Cache Renv packages
        uses: actions/cache@v2
        with:
          path: $HOME/.local/share/renv
          key: r-${{ hashFiles('renv.lock') }}
          restore-keys: r-
      - name: Install packages
        run: |
          R -e 'install.packages("renv")'
          R -e 'renv::restore()'
      - name: Build website
        run: |
          R -e 'blogdown::install_hugo(force=TRUE)'
          R -e 'blogdown::build_site(local = TRUE, build_rmd = TRUE)'
      - name: Upload artifact
        uses: actions/upload-artifact@v1
        with:
          name: _website
          path: public/
  checkout-and-deploy:
    runs-on: ubuntu-latest
    needs: buildsite
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          ref: 'source'
      - name: Download artifact
        uses: actions/download-artifact@v1
        with:
          # Artifact name
          name: _website
          # Destination path
          path: public
      - name: Deploy to GitHub Pages
        uses: Cecilapp/GitHub-Pages-deploy@v3
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          branch: 'master'
          build_dir: public
          email: ${{ secrets.EMAIL }}
          jekyll: no
```

L'action `checkout` se place dans la branche `source` avec sa variable `ref`.

Il n'est pas possible de mettre en cache les résultats des bouts de code parce qu'ils se trouvent dans les pages `.Rmd` du projet, dont l'emplacement n'est pas prévisible.
Le cache se limite aux packages.

La tâche `Build website` utilise le package **blogdown** pour installer Hugo (le générateur de sites web) et ensuite construire le site.

Enfin, la tâche de déploiement se place dans la branche `source` pour récupérer le dossier `public` produit par la tâche de production et la déploie dans la branche `master` au lieu de la branche `gh-page` habituelle pour respecter l'organisation de GitHub.

Si le site web utilise des données en ligne qui justifient de le mettre à jour périodiquement, GitHub Actions peut être lancé tous les jours, toutes les semaines ou tous les mois en plus des reconstruction déclenchées par une modification du dépôt (voir section \@ref(sec:declenchement)).
Ici, le site est reconstruit tous les dimanches à 22h.

Exemple: la page qui affiche la bibliométrie du site web[^ci-4] de l'auteur interroge Google Scholar pour afficher les citations des publications.
Le site est mis à jour toutes les semaines pour que les statistiques soient à jour.

[^ci-4]: <https://EricMarcon.github.io/fr/publication/>


#### Packages R {#sec:package-ci6}

Le script minimal est:

    language: r

Travis s'appuie sur le fichier `DESCRIPTION` pour installer les packages nécessaires et lance la vérification du package avec l'option `--as-cran`.
La vérification échoue si elle retourne une erreur, un avertissement ou une note.

Les packages supplémentaires, nécessaires aux actions de Travis en cas de succès, sont déclarés dans `r_packages`:

    r_packages: # Packages à installer pour Travis
      - covr    # Interfaçage de Covecov
      - pkgdown # Création du site d'aide des packages R

La partie `after_success` du script permet d'effectuer des tâches seulement dans cette situation: typiquement appeler Codecov pour mesurer le taux de couverture du code et utiliser **pkgdown** pour créer le site web d'aide:

    after_success:
      # Appel à Covecov
      - Rscript -e 'covr::codecov(type ="all")'
      # Dossier du site d'aide
      - mkdir docs
      # Tirer...
      - git fetch origin gh-pages:gh-pages
      # ...dans docs
      - git --work-tree=docs checkout gh-pages -- .
      # Construction du site
      - travis_wait 60 Rscript -e 'pkgdown::build_site()'
      # Fichier vide
      - touch docs/.nojekyll

La construction du site par **pkgdown** est plus compliqué que celle d'un livre produit par **bookdown** parce que deux versions coexistent si le package est hébergé sur CRAN: à la racine du dossier `docs`, la version de production correspondant à la version sur CRAN et, dans `docs/dev`, la version correspondant à la version en cours du package.
Une seule est produite par Travis mais les deux doivent être conservées: il ne faut pas que la version de production, consultée par les utilisateurs du package, soit supprimée quand une version de développement est créée.

La dernière ligne du script consiste à créer un fichier vide nommé `.nojekyll` pour indiquer à GitHub que les pages web produites ne doivent pas être traitées comme le code source d'un site Jekyll, ce qui est le comportement par défaut des pages GitHub.

L'exemple suivant correspond au package **entropart**, déposé sur CRAN.

Fichier `.travis.yml`:

    language: r
    warnings_are_errors: true     # Comportement de CRAN
    cache: packages

    r_packages:     # Packages à installer pour Travis
      - covr        # Interfaçage de Covecov
      - pkgdown     # Pour la création du site d'aide

    after_success:
      - Rscript -e 'covr::codecov(type ="all")' 
      - mkdir docs
      - git fetch origin gh-pages:gh-pages
      - git --work-tree=docs checkout gh-pages -- .
      - travis_wait 60 Rscript -e 'pkgdown::build_site()'
      - touch docs/.nojekyll

    deploy:
      provider: pages
      skip_cleanup: true
      keep_history: true                                   
      token: $GITHUB_TOKEN
      on:
        branch: master
      local_dir: docs

    notifications:
      email:
        recipients:
          - e.marcon@free.fr

Pour des paramétrages particuliers, la documentation complète de Travis peut être consultée[^ci-5].

[^ci-5]: <https://docs.travis-ci.com/user/languages/r/>


### Ajouter des badges {#sec:ci-badges}

Le succès des Actions GitHub est visible en ajoutant un badge dans le fichier `README.md`, juste après le titre du fichier.
Sur la page du projet, choisir "Actions" puis sélectionner l'action (dans "Workflows").
Cliquer sur le bouton *...* puis sur *Create Status Badge*.
Coller le code Markdown:

    # Nom du projet
    ![bookdown](https://github.com/<GitHubID>/<Depot>/workflows/<Action>/badge.svg)

Le taux de couverture mesuré par Codecov peut aussi être affiché par un badge:

    ![codecov](https://codecov.io/github/<GitHubID>/
      <Depot>/branch/master/graphs/badge.svg)]
      (https://codecov.io/github/<GitHubID>/<Depot>)
